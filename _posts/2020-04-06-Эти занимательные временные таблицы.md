---
layout: post
title: Эти занимательные временные таблицы
categories: sqlserver
background: '/img/posts/2020/2020-04-06-%D0%AD%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/logo.png'
---

Кое-что интересное о временных таблицах и работе платформы 1С с ними.

## Мы все их используем

Не важно - новичок Вы или опытный разработчик. Если когда-либо в работе приходилось создавать запросы, то с высокой долей вероятности в них хотя бы раз были использованы временные таблицы. Тот же экзамен "1С:Специалист по платформе" фактически требует их использования при решении задач на экзамене. Сегодня речь будет идти, внезапно, как-раз о временных таблицах и работе платформы 1С с ними.

Мы начнем с простых примеров работы с временными таблицами и действиями платформы на стороне СУБД. А закончим чем-то очень странным и неожиданным.

## Примитивный пример

Временные таблицы рекомендуется использовать для создания стабильных и производительных запросов. В тексте запросов их создание выполняется с помощью ключевого слова "ПОМЕСТИТЬ" для пакета запроса.

```
ВЫБРАТЬ ПЕРВЫЕ 100
	Номенклатура.Ссылка КАК Ссылка,
	Номенклатура.Наименование КАК Наименование
ПОМЕСТИТЬ ВТ_Номенклатура
ИЗ
	Справочник.Номенклатура КАК Номенклатура
;

////////////////////////////////////////////////////////////////////////////////
ВЫБРАТЬ
	ВТ_Номенклатура.Ссылка КАК Ссылка,
	ВТ_Номенклатура.Наименование КАК Наименование
ИЗ                              
	ВТ_Номенклатура КАК ВТ_Номенклатура
```

Здесь в первом пакете запросов мы выбрали первые 100 элементов справочника "Номенклатура" и поместили их во временную таблицу "ВТ_Номенклатура". После чего во втором пакете мы получили данные из ранее созданной временной таблицы и вернули их как результат выборки. Все просто, не так ли?

Если взглянуть на происходящее на стороне СУБД, то мы увидим следующую серию запросов.

```sql
-- Проверка существует ли временная таблица с указанным именем
SELECT 
    1 
WHERE OBJECT_ID('tempdb..#tt36') IS NOT NULL					

-- Создание временной таблицы с зарезервированным именем и необходимой структурой
CREATE TABLE #tt36 (
    _Q_000_F_000RRef BINARY(16), 
    _Q_000_F_001 NVARCHAR(100) COLLATE DATABASE_DEFAULT
)					

-- Выполнение 1 пакета запроса для заполнения временной таблицы
INSERT INTO #tt36 WITH(TABLOCK) (_Q_000_F_000RRef, _Q_000_F_001) SELECT TOP 100
    T1._IDRRef,
    T1._Description
FROM dbo._Reference85 T1
WHERE (T1._Fld774 = @P1) -- Неявный отбор по разделителю данных

-- Получение данных из временной таблицы для результата запроса
SELECT
    T1._Q_000_F_000RRef,
    T1._Q_000_F_001
FROM #tt36 T1 WITH(NOLOCK)					

-- Очистка временной таблицы
TRUNCATE TABLE #tt36	
```

Тоже все относительно просто. Платформа 1С выполняет ряд простых шагов:

* Проверка наличия временной таблицы с зарезервированным именем. Если существует, то будет удалена.
* Создание временной таблицы.
* Далее выполняет запрос из первого пакета для наполнения данных ранее созданной временной таблицы.
* Вторым запросом получает данные из временной таблицы для результата выборки.
* Очищает данные временной таблицы.

В нашем случае последней операцией является очистка временной таблицы, причем платформа делает это автоматически. Так происходит, потому что запрос был окончательно выполнен и за ним можно освободить ресурсы. Очистку данных временной таблицы также можно добавить явно указав инструкции в запросе:

```
;

////////////////////////////////////////////////////////////////////////////////
УНИЧТОЖИТЬ ВТ_Номенклатура
```

Всегда ли платформа действует по таким правилам? Нет. Например, если выполнить этот же запрос еще раз, то количество выполняемых SQL-запросов будет меньше.

```sql
-- Выполнение 1 пакета запроса для заполнения временной таблицы
INSERT INTO #tt36 WITH(TABLOCK) (_Q_000_F_000RRef, _Q_000_F_001) SELECT TOP 100
    T1._IDRRef,
    T1._Description
FROM dbo._Reference85 T1
WHERE (T1._Fld774 = @P1) -- Неявный отбор по разделителю данных				

-- Получение данных из временной таблицы для результата запроса
SELECT
    T1._Q_000_F_000RRef,
    T1._Q_000_F_001
FROM #tt36 T1 WITH(NOLOCK)					

-- Очистка временной таблицы
TRUNCATE TABLE #tt36
```

Платформа увидела, что пустая временная таблица с необходимой структурой уже есть на стороне базы данных для текущего соединения с СУБД и не стала создавать ее заново. Эта оптимизация позволяет работать с временными таблицами наиболее эффективно, не создавая каждый раз их заново.

Также обратите внимание на проверку существования временной таблицы выше. Ранее редко, но метко, можно было нарваться на ошибку уже существующей временной таблицы с именем "#ttN'. Помню такое еще со времен 8.3.6. Теперь это более редкая проблема и это поведение одна из причин изменения ситуации.

Итак, создание временных таблиц выполняется довольно просто. Это относится как в части использования конструкции "ПОМЕСТИТЬ" в запросе, так и в части SQL-запросов платформы 1С. Даже переиспользование ранее созданных временных таблиц не усложняет пример. Но все ли так просто на самом деле?

## Серийное производство

Усложним пример и создадим намного больше временных таблиц в запросе. Вот как это выглядит в контексте 1С.

```
ВЫБРАТЬ ПЕРВЫЕ 100
	Номенклатура.Ссылка КАК Ссылка,
	1 КАК ДругоеЗначение
ПОМЕСТИТЬ ВТ_Номенклатура_1
ИЗ
	Справочник.Номенклатура КАК Номенклатура

ИНДЕКСИРОВАТЬ ПО
	Ссылка
;

////////////////////////////////////////////////////////////////////////////////
ВЫБРАТЬ ПЕРВЫЕ 100
	Номенклатура.Ссылка КАК Ссылка,
	1 КАК ДругоеЗначение
ПОМЕСТИТЬ ВТ_Номенклатура_2
ИЗ
	Справочник.Номенклатура КАК Номенклатура

ИНДЕКСИРОВАТЬ ПО
	Ссылка
;

////////////////////////////////////////////////////////////////////////////////
ВЫБРАТЬ ПЕРВЫЕ 100
	Номенклатура.Ссылка КАК Ссылка,
	1 КАК ДругоеЗначение
ПОМЕСТИТЬ ВТ_Номенклатура_3
ИЗ
	Справочник.Номенклатура КАК Номенклатура

ИНДЕКСИРОВАТЬ ПО
	Ссылка
;

////////////////////////////////////////////////////////////////////////////////
ВЫБРАТЬ
	ВТ_Номенклатура_1.Ссылка КАК Ссылка1,
	ВТ_Номенклатура_2.Ссылка КАК Ссылка2,
	ВТ_Номенклатура_3.Ссылка КАК Ссылка3,
	2 КАК ДругоеЗначение
ПОМЕСТИТЬ ВТ_Результат
ИЗ
	ВТ_Номенклатура_1 КАК ВТ_Номенклатура_1
		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_Номенклатура_2 КАК ВТ_Номенклатура_2
			ЛЕВОЕ СОЕДИНЕНИЕ ВТ_Номенклатура_3 КАК ВТ_Номенклатура_3
			ПО ВТ_Номенклатура_2.Ссылка = ВТ_Номенклатура_3.Ссылка
		ПО ВТ_Номенклатура_1.Ссылка = ВТ_Номенклатура_2.Ссылка
;

////////////////////////////////////////////////////////////////////////////////
УНИЧТОЖИТЬ ВТ_Номенклатура_1
;

////////////////////////////////////////////////////////////////////////////////
УНИЧТОЖИТЬ ВТ_Номенклатура_2
;

////////////////////////////////////////////////////////////////////////////////
УНИЧТОЖИТЬ ВТ_Номенклатура_3
;

////////////////////////////////////////////////////////////////////////////////
ВЫБРАТЬ
	ВТ_Результат.Ссылка1 КАК Ссылка1,
	ВТ_Результат.Ссылка2 КАК Ссылка2,
	ВТ_Результат.Ссылка3 КАК Ссылка3
ИЗ
	ВТ_Результат КАК ВТ_Результат
```

Длинный запрос. В этом примере мы создали 3 временных таблицы, соединили их и результат поместили в четвертую, а после удалили часть временных таблиц и вернули результат. При этом для первых трех таблиц мы добавили индексы. Вот что мы увидим на стороне SQL Server.

```sql
-- Проверка существует ли временная таблица с указанным именем
SELECT 1 WHERE OBJECT_ID('tempdb..#tt41') IS NOT NULL					

-- Создание временной таблицы "ВТ_Номенклатура_1" с зарезервированным именем и необходимой структурой
CREATE TABLE #tt41 (_Q_000_F_000RRef BINARY(16), _Q_000_F_001 NUMERIC(1, 0))					

-- Создание кластерного индекса для временной таблицы "ВТ_Номенклатура_1" по полю "Ссылка"
CREATE CLUSTERED INDEX idx41 ON #tt41 (_Q_000_F_000RRef)					

-- Выполнение 1 пакета запроса для заполнения временной таблицы "ВТ_Номенклатура_1"
INSERT INTO #tt41 WITH(TABLOCK) (_Q_000_F_000RRef, _Q_000_F_001) 
SELECT TOP 100
    T1._IDRRef,
    @P1
FROM dbo._Reference85 T1
WHERE (T1._Fld774 = @P2)				

-- Проверка существует ли временная таблица с указанным именем
SELECT 1 WHERE OBJECT_ID('tempdb..#tt42') IS NOT NULL					

-- Создание временной таблицы "ВТ_Номенклатура_2" с зарезервированным именем и необходимой структурой
CREATE TABLE #tt42 (_Q_001_F_000RRef BINARY(16), _Q_001_F_001 NUMERIC(1, 0))					

-- Создание кластерного индекса для временной таблицы "ВТ_Номенклатура_2" по полю "Ссылка"
CREATE CLUSTERED INDEX idx42 ON #tt42 (_Q_001_F_000RRef)					

-- Выполнение 2 пакета запроса для заполнения временной таблицы "ВТ_Номенклатура_2"
INSERT INTO #tt42 WITH(TABLOCK) (_Q_001_F_000RRef, _Q_001_F_001) 
SELECT TOP 100
    T1._IDRRef,
    @P1
FROM dbo._Reference85 T1
WHERE (T1._Fld774 = @P2)				

-- Проверка существует ли временная таблица с указанным именем
SELECT 1 WHERE OBJECT_ID('tempdb..#tt43') IS NOT NULL					

-- Создание временной таблицы "ВТ_Номенклатура_3" с зарезервированным именем и необходимой структурой
CREATE TABLE #tt43 (_Q_001_F_000RRef BINARY(16), _Q_001_F_001 NUMERIC(1, 0))					

-- Создание кластерного индекса для временной таблицы "ВТ_Номенклатура_3" по полю "Ссылка"
CREATE CLUSTERED INDEX idx43 ON #tt43 (_Q_001_F_000RRef)					

-- Выполнение 3 пакета запроса для заполнения временной таблицы "ВТ_Номенклатура_3"
INSERT INTO #tt43 WITH(TABLOCK) (_Q_001_F_000RRef, _Q_001_F_001) 
SELECT TOP 100
    T1._IDRRef,
    @P1
FROM dbo._Reference85 T1
WHERE (T1._Fld774 = @P2)				

-- Проверка существует ли временная таблица с указанным именем
SELECT 1 WHERE OBJECT_ID('tempdb..#tt44') IS NOT NULL					

-- Создание временной таблицы "ВТ_Результат" с зарезервированным именем и необходимой структурой
CREATE TABLE #tt44 (_Q_001_F_000RRef BINARY(16), _Q_001_F_001RRef BINARY(16), _Q_001_F_002RRef BINARY(16), _Q_001_F_003 NUMERIC(1, 0))					

-- Выполнение 4 пакета запроса для заполнения временной таблицы "ВТ_Результат"
INSERT INTO #tt44 WITH(TABLOCK) (_Q_001_F_000RRef, _Q_001_F_001RRef, _Q_001_F_002RRef, _Q_001_F_003) 
SELECT
    T1._Q_000_F_000RRef,
    T2._Q_001_F_000RRef,
    T3._Q_001_F_000RRef,
    @P1
FROM #tt41 T1 WITH(NOLOCK)
    LEFT OUTER JOIN #tt42 T2 WITH(NOLOCK)
        LEFT OUTER JOIN #tt43 T3 WITH(NOLOCK)
    ON (T2._Q_001_F_000RRef = T3._Q_001_F_000RRef)
        ON (T1._Q_000_F_000RRef = T2._Q_001_F_000RRef)				

-- Очистка временной таблицы "ВТ_Номенклатура_1" c помощью конструкции "УНИЧТОЖИТЬ"
TRUNCATE TABLE #tt41					

-- Очистка временной таблицы "ВТ_Номенклатура_2" c помощью конструкции "УНИЧТОЖИТЬ"
TRUNCATE TABLE #tt42					

-- Очистка временной таблицы "ВТ_Номенклатура_3" c помощью конструкции "УНИЧТОЖИТЬ"
TRUNCATE TABLE #tt43

-- Получение данных из временной таблицы для результата запроса
SELECT
    T1._Q_001_F_000RRef,
    T1._Q_001_F_001RRef,
    T1._Q_001_F_002RRef
FROM #tt44 T1 WITH(NOLOCK)					

-- Очистка временной таблицы ВТ_Результат после выполнения запроса
TRUNCATE TABLE #tt44
```

Главным отличием от предыдущего примера является большее количество временных таблиц и манипуляций с ними. При этом принципы работы те же самые. Из нового стоит выделить создание индекса для временных таблиц. Фактически, это всегда кластерный индекс по указанному набору полей. Стоит ли всегда создавать индексы на временную таблицу? Если кратко, то "НЕТ". Добавлять индексы во временную таблицу нужно только при большом объеме данных и только на те поля, которые используются в соединениях или условиях отборов. И если при подготовке к экзаменам Вам говорят, что для временных таблиц всегда нужно добавлять индексы, то скорее всего это только в контексте экзамена.

В этом примере мы также рассмотрели как работает конструкции "УНИЧТОЖИТЬ". Фактически она также очищает существующую временную таблицу как это делает платформа автоматически при завершении запроса. Давайте пройдем дальше.

## Самый лучший менеджер

Настало время еще более сложных примеров. Ранее мы создавали 3 временных таблицы в одном пакетном запросе. Платформе 1С также позволяет использовать менеджер временных таблиц, тем самым сохраняя временную таблицу между вызовами запросов. Этот прием часто используется при наличии сложной логики запросов к базе данных. Как же платформа работает с этим механизмом?

```
// Подготовим текст запроса
ТекстЗапроса = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Номенклатура.Ссылка КАК Ссылка,
	|	1 КАК НомерМенеджераВТ,
	|	""ПРОВЕРКА"" КАК ПроизвольныйТекст,
	|	""Тест"" КАК ДругоеЗначение
	|ПОМЕСТИТЬ ВТ_Номенклатура
	|ИЗ
	|	Справочник.Номенклатура КАК Номенклатура
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка";

// Выполним запрос и поместим результат во временную таблицу.
// Для сохранения временной таблицы используем менеджер временных таблиц.
МенеджерВТ = Новый МенеджерВременныхТаблиц;
Запрос = Новый Запрос;
Запрос.Текст = ТекстЗапроса; 
Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
Запрос.Выполнить();

// Прочитаем данные из временной таблицы в менеджере ВТ
Запрос = Новый Запрос;
Запрос.Текст = 
	"ВЫБРАТЬ * Из ВТ_Номенклатура КАК Т";
Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
Результат = Запрос.Выполнить();		
Выборка = Результат.Выбрать();
Выборка.Следующий();	
Сообщить(Выборка.НомерМенеджераВТ);

// Очищаем данные менеджера временных таблиц
МенеджерВТ.Закрыть();
```

Здесь мы создали менеджер временных таблиц и присвоили его первому объекту запроса. Текст первого запроса написан таким образом, чтобы результат поместить во временную таблицу "ВТ_Номенклатура". Затем мы создали новый экземпляр запроса и прочитали данные из временной таблицы "ВТ_Номенклатура", которую сформировали ранее. Обращение к существующей временной таблице как-раз и возможно благодаря менеджеру временных таблиц. В завершении мы очистили все сохраненные данные в контексте менеджера ВТ. На стороне SQL Server это выглядит так.

```sql
-- Проверка существует ли временная таблица с указанным именем
SELECT 1 WHERE OBJECT_ID('tempdb..#tt50') IS NOT NULL					

-- Создание временной таблицы с зарезервированным именем и необходимой структурой
CREATE TABLE #tt50 (
        _Q_000_F_000RRef BINARY(16), 
        _Q_000_F_001 NUMERIC(1, 0), 
        _Q_000_F_002 NVARCHAR(8) COLLATE DATABASE_DEFAULT,
        _Q_000_F_003 BINARY(1))					

-- Создание кластерного индекса для временной таблицы
CREATE CLUSTERED INDEX idx50 ON #tt50 (_Q_000_F_000RRef)					

-- Выполнение 1 запроса для заполнения временной таблицы
INSERT INTO #tt50 WITH(TABLOCK) (_Q_000_F_000RRef, _Q_000_F_001, _Q_000_F_002, _Q_000_F_003) 
SELECT TOP 1
    T1._IDRRef,
    @P1,
    @P2,
    0x01
FROM dbo._Reference85 T1
WHERE (T1._Fld774 = @P3)	

-- Выполнение 2 запроса для чтения данных из временной таблицы
SELECT
    T1._Q_000_F_000RRef,
    T1._Q_000_F_001,
    T1._Q_000_F_002,
    T1._Q_000_F_003
FROM #tt50 T1 WITH(NOLOCK)					

-- Очистка данных в контексте менеджера временных таблиц
TRUNCATE TABLE #tt50	
```

Фактически, если выполнить все запросы без менеджера временных таблиц одним пакетом, то сформированные SQL-запросы будут те же самые.

```
ТекстЗапроса = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Номенклатура.Ссылка КАК Ссылка,
	|	1 КАК НомерМенеджераВТ,
	|	""ПРОВЕРКА"" КАК ПроизвольныйТекст,
	|	""Тест"" КАК ДругоеЗначение
	|ПОМЕСТИТЬ ВТ_Номенклатура
	|ИЗ
	|	Справочник.Номенклатура КАК Номенклатура
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_Номенклатура.Ссылка КАК Ссылка,
	|	ВТ_Номенклатура.НомерМенеджераВТ КАК НомерМенеджераВТ,
	|	ВТ_Номенклатура.ПроизвольныйТекст КАК ПроизвольныйТекст,
	|	ВТ_Номенклатура.ДругоеЗначение КАК ДругоеЗначение
	|ИЗ
	|	ВТ_Номенклатура КАК ВТ_Номенклатура";

Запрос = Новый Запрос;
Запрос.Текст = ТекстЗапроса;
Результат = Запрос.Выполнить();		
Выборка = Результат.Выбрать();
Выборка.Следующий();	
Сообщить(Выборка.НомерМенеджераВТ);
```

Таким образом, с помощью менеджера временных таблиц можно создать один раз временную таблицу и использовать ее в других запросах многократно. Удобно, эффективно, производительно. В типовых конфигурациях это используется повсеместно. Но есть интересные особенности как платформа 1С работает с временными таблицами при многопользовательской работе.

## Срывая покровы

Еще несколько очевидных и не очень особенностей работы с временными таблицами.

### Контекст и контроль доступности

Как известно, сервер 1С при работе с СУБД имеет пул соединений. Речь идет именно о пуле соединений с СУБД, а не кластером 1С. У Вас может быть 100 активных сеансов работы с информационной базой и 2 запущенных рабочих процесса (rphost'ы), но при этом соединений со SQL Server может быть 15. На каждый рабочий процесс свой пул соединений. Это все очень условно, но смысл должен быть понятен. То есть количество сеансов НЕ равно количеству соединений с базой данных. Использование пула соединений является очень эффективным и производительным подходом и тут все просто отлично.

<a href="/img/posts/2020/2020-04-06-%D0%AD%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/1.%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9%20%D0%B8%20%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D1%85%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.png" target="_blank">
<img 
  src="/img/posts/2020/2020-04-06-%D0%AD%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/1.%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9%20%D0%B8%20%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D1%85%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.png" 
  title="Схема соединений и рабочих процессов"
  class="img-fluid"
/>
</a>

Есть еще один нюанс. Создаваемые платформой 1С временные таблицы являются локальными. То есть они доступны только в рамках одного соединения с СУБД. Есть также и глобальные временные таблицы, но платформа их не использует. Таким образом, создание и использование временной таблицы происходит всегда в рамках одного соединения с СУБД.

Последнее еще интересней, если рассмотреть это в рамках использования менеджера временных таблиц. Если из кода встроенного языка создать менеджер временных таблиц и выполнять запросы с присвоением этого менеджера ВТ объекту запроса, то можно быть уверенным, что все они будут выполнены в рамках одного соединения с СУБД.

Тут может показаться, что если в разных сеансах 1С создать менеджер временных таблиц, а в нем сохранить временную таблицу с одним названием, допустим, "ВТ_Номенклатура", то эта таблица будет доступна в разных сеансах, если они используют одно соединение с СУБД. На самом деле нет, т.к. платформа еще и сама контролирует доступность временных таблиц в разрезе сеансов и доступность в зависимости от контекста.

```
    // Код сеанса 1
	МенеджерВТ = Новый МенеджерВременныхТаблиц;
	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Номенклатура.Ссылка КАК Ссылка,
		|	1 КАК НомерМенеджераВТ,
		|	""ПРОВЕРКА"" КАК ПроизвольныйТекст,
		|	33 КАК ДругоеЗначение
		|ПОМЕСТИТЬ ВТ_Номенклатура
		|ИЗ
		|	Справочник.Номенклатура КАК Номенклатура
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	Ссылка";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса; 
	Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
	Запрос.Выполнить();
```

```
    // Код сеанса 2
    МенеджерВТ = Новый МенеджерВременныхТаблиц;

    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ * Из ВТ_Номенклатура КАК Т";
    Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
    Результат = Запрос.Выполнить();		
    Выборка = Результат.Выбрать();
    Выборка.Следующий();	
    Сообщить(Выборка.НомерМенеджераВТ);
```

Во втором сеансе будет ошибка:

```
Таблица не найдена "ВТ_Номенклатура"
ВЫБРАТЬ * Из <<?>>ВТ_Номенклатура КАК Т
```

И это логично. Дело даже не в том, что это разные сеансы, а в том что это разные менеджеры временных таблиц. Использовать один менеджер временных таблиц в разных сеансах платформа не позволяет, а контроль доступности осуществляется именно в контексте менеджера ВТ.

### Кэширование

Вы когда-нибудь кэшировали менеджер временных таблиц? В некоторых особых случаях Вы могли бы увидеть вот это.

<a href="/img/posts/2020/2020-04-06-%D0%AD%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/2.%20%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B0%20%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80%D0%B0%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86.png" target="_blank">
<img 
  src="/img/posts/2020/2020-04-06-%D0%AD%D1%82%D0%B8%20%D0%B7%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B/2.%20%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B0%20%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80%D0%B0%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86.png" 
  title="Ошибка менеджера временных таблиц"
  class="img-fluid"
/>
</a>

Текст ошибки:

```
Ошибка конфигурации.
Соединение с сервером баз данных удерживается после окончания вызова сервера 1С:Предприятия.
Возможно, не был освобожден менеджер временных таблиц.
Объект, удерживающий менеджер временных таблиц, помещен в кэш или образовал цепочку
циклических ссылок."
```

Как мы уже говорили выше, для работы менеджера временных таблиц резервируется конкретное соединение с СУБД. Пока менеджер временных таблиц существует, в переменной или в другом кэшированном виде, то для него зарезервировано соединение. Если по каким-либо причинам, например из-за циклических ссылок, платформа не сможет удалить менеджер ВТ и освободить соединение с базой данных, то появится именно такая ошибка. Вы можете воспроизвести ее самостоятельно вот таким образом.

```
&НаКлиенте
Процедура ОшибкаКэшированияВТ(Команда)
	
	ОшибкаКэшированияВТНаСервере();
	
КонецПроцедуры

&НаСервере
Процедура ОшибкаКэшированияВТНаСервере()
	
	// Инициализируем менеджер временных таблиц и выполняем запрос в его контексте
	МенеджерВТ = Новый МенеджерВременныхТаблиц;
	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Номенклатура.Ссылка КАК Ссылка,
		|	1 КАК НомерМенеджераВТ,
		|	""ПРОВЕРКА"" КАК ПроизвольныйТекст,
		|	33 КАК ДругоеЗначение
		|ПОМЕСТИТЬ ВТ_Номенклатура
		|ИЗ
		|	Справочник.Номенклатура КАК Номенклатура
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	Ссылка";	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса; 
	Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
	Запрос.Выполнить();
	
	// Эмулируем появление циклической ссылки, чтобы после завершения серверного 
	// вызова платформа не смогла удалить менеджер ВТ
	Кэш1 = Новый Структура;
	Кэш1.Вставить("МенеджерВТ", МенеджерВТ);
	Кэш1.Вставить("СсылкаНаДругойКэш", Неопределено);	
	Кэш2 = Новый Структура;
	Кэш2.Вставить("МенеджерВТ", МенеджерВТ);
	Кэш2.Вставить("СсылкаНаДругойКэш", Неопределено);	
	Кэш1.СсылкаНаДругойКэш = Кэш2;
	Кэш2.СсылкаНаДругойКэш = Кэш1;
	
КонецПроцедуры
```

Как этого избежать? Нужно следовать простым правилам:

* НЕ кэшировать менеджер временных таблиц там, где кэш сохраняется между вызовами сервера.
* Быть осторожным с циклическими ссылками. В принципе, это относится не только к менеджеру ВТ, но и к любой разработке.
* Вместо кэширования менеджера ВТ подумать над архитектурой. * Возможно кэшируемые в ВТ данные требуют особого хранения в базе для быстрого доступа.

Вот даже с таким можно встретиться.

### Утопи меня в соединениях

И еще один эксперимент. Для каждого менеджера ВТ резервируются соединения с СУБД. Это мы уже говорили. Но это не значит, что на каждый созданный менеджер создается соединение с базой данных. Для эксперимента выполните в одном сеансе вот такой код.

```
	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Номенклатура.Ссылка КАК Ссылка,
		|	1 КАК НомерМенеджераВТ,
		|	""ПРОВЕРКА"" КАК ПроизвольныйТекст,
		|	33 КАК ДругоеЗначение
		|ПОМЕСТИТЬ ВТ_Номенклатура
		|ИЗ
		|	Справочник.Номенклатура КАК Номенклатура
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	Ссылка";
	
	КэшМенеджеровВТ = Новый Соответствие;	
	Для НомерМенеджера = 1 По 10000 Цикл
		
		МенеджерВТ = Новый МенеджерВременныхТаблиц;
		Запрос = Новый Запрос;
		Запрос.Текст = СтрЗаменить(ТекстЗапроса, 
			"1 КАК НомерМенеджераВТ", 
			XMLСтрока(НомерМенеджера) + " КАК НомерМенеджераВТ");
		Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
		Запрос.Выполнить();
		
		КэшМенеджеровВТ.Вставить(НомерМенеджера, МенеджерВТ);
		
	КонецЦикла;
```

Мы создали 10000 новых временных таблиц и менеджеров ВТ! Вы можете это проверить и на стороне СУБД с помощью скриптов, предложенных в конце статьи. Там же есть и скрипты для просмотра количества соединений с сервером баз данных. При этом новых соединений на каждый менеджер ВТ платформа не создала. Все потому что для обслуживания одного сеанса достаточно одного соединения с базой данных. Возможно, для этого правила есть исключения, но мы их сейчас рассматривать не будем.

Как сервер 1С заставить создать дополнительные соединения с БД? Откройте 10 сеансов 1С и запустите этот код в каждом сеансе. Барабанная дробь! Сервер 1С увеличит пул соединений с СУБД до 10 сеансов (может и больше, если ранее соединения уже были созданы). При этом стоит заметить, что пул соединений увеличивается не сразу после старта сеанса 1С, а именно во время создания менеджеров временных таблиц в каждом сеансе. Главное запустить этот код параллельно.

Таким образом, использование временных таблиц и менеджера ВТ может напрямую влиять на размер пула соединений сервера 1С с сервером баз данных.

Только не устраивайте этот спам временными таблицами на рабочем окружении. Поберегите сервер!

## Покажи мне свой товар

Как мы уже говорили ранее, локальная временная таблица (именно такие используются платформой 1С) на уровне СУБД доступны только тому соединению, в рамках которого она была создана. Мы никак не можем прочитать из одного соединения содержимое таблиц другого соединения. Например, Вы с помощью диагностических запросов нашли, что таблица "#tt555" участвует в подозрительном запросе и захотели посмотреть что в ней находится. Но SQL Server не позволит это сделать. Но, как говорится, если сильно хочется, то можно. И вот как!

Для наглядности мы будем немного изменять тексты запросов, которые генерирует платформа. Это только для наглядности. Все что Вы увидите ниже можно применять и на практике. И так, допустим платформа создала временную таблицу и наполнила ее данными во таким способом.

```sql
CREATE TABLE #ttTest (
    column1 BINARY(16), 
    column2 NVARCHAR(100) COLLATE DATABASE_DEFAULT
)

INSERT INTO #ttTest WITH(TABLOCK) (column1, column2) 
SELECT
    0x811FA45D36C581E411E8F9DCD58AB12F AS_IDRRef,
    'Этот текст должен видеть только администратор!' AS _Description
```

С помощью этого скрипта мы можем узнать где именно эта временная таблица хранится в базе TempDB вплоть до адреса страниц в файле базы данных.

```sql
SELECT
    T.name,
    T.[object_id],
    AU.type_desc,
    AU.first_page,
    AU.data_pages,
    P.[rows]
FROM tempdb.sys.tables AS T
JOIN tempdb.sys.partitions AS P
    ON P.[object_id] = T.[object_id]
JOIN tempdb.sys.system_internals_allocation_units AS AU
ON  (
        AU.type_desc = N'IN_ROW_DATA'
        AND AU.container_id = P.partition_id
    )
    OR
    (
        AU.type_desc = N'ROW_OVERFLOW_DATA'
        AND AU.container_id = P.partition_id
    )
    OR
    (
        AU.type_desc = N'LOB_DATA' 
        AND AU.container_id = P.hobt_id
    )
WHERE T.name LIKE N'#ttTest%'; -- Здесь отбор по имени временной таблицы
```

Предположим, что результат мы получили следующий.

| Имя временной таблицы       | Идентификатор объекта | Тип данных  | Адрес первой страницы | Количество страниц с данными | Количество записей в таблице |
|-----------------------------|-----------------------|-------------|-----------------------|------------------------------|------------------------------|
| #ttTest________00000000EAFD | -1137577394           | IN_ROW_DATA | 0x481E01000800        | 1                            | 1                            |

Очень интересно :) Но что же это значит? Расшифруем.

1. Имя временной таблицы (name) - это полное имя временной таблицы с учетом идентификатора соединения с базой данных. Именно благодаря такому формированию имени можно создавать временные таблицы с одинаковым именем в разных сессиях, т.к. по факту имена у них все же будут отличаться. Хоть последнее и не будет заметно при их использовании.
2. Идентификатор объекта (object_id) - идентификатор объекта временной таблицы.
3. Тип данных (type_desc) - какие данные хранятся в этом объекте. В нашем случае это таблица с записями.
4. Адрес первой страницы (first_page) - адрес первой страницы. Это важная часть нашего эксперимента. В нашем случае это значение "0x481E01000800". Сохранен в виде 6 байтового значения, где каждый байт представлен двумя шестнадцатеричными символами. Для расшифровки нужно читать его справа на лево. Если его расшифровать, то получим следующее (для конвертации hex в число можно использовать этот сервис):
    * 00 08 - это идентификатор файла базы данных TempDB, где эта таблица сохранения. В нашем случае это 8.
    * 00 01 1E 48 - это идентификатор начальной страницы. В нашем случае это 73288.
5. Количество страниц с данными (data_pages) - сколько страниц по 8 КБ занимает таблица.
6. Количество записей в таблице (rows) - сколько записей во временной таблице.

Это все данные что нам нужны для получения содержимого таблицы из другой сессии. Теперь выполним следующий скрипт, подставив найденные параметры.

```sql
DBCC TRACEON (3604); -- Вывод сообщений

-- Служебная процедура для работы со страницами
-- https://www.mssqltips.com/sqlservertip/1578/using-dbcc-page-to-examine-sql-server-table-and-index-data/
DBCC PAGE (
    tempdb, -- база данных
    8, -- Идентификатор файла
    73288, -- Идентификатор начальной страницы
    3) -- Как отобразить результат
WITH TABLERESULTS; -- Возвращаем результат в таблицу
```

В ответ мы получили большое количество записей. Вот последние 8. Остальные записи вида "BUFFER:" и "PAGE HEADER:" нас не интересуют, сразу перейдем к данным.

| ParentObject                  | Object                                                                            | Field   | VALUE                                                                                  |
|-------------------------------|-----------------------------------------------------------------------------------|---------|----------------------------------------------------------------------------------------|
| Slot 0 Offset 0x60 Length 119 | Memory Dump @0x0000003EC487A060                                                   |         | 0000000000000000:   30001400 811fa45d 36c581e4 11e8f9dc d58ab12f  0....¤]6Åä.èùÜÕŠ±/   |
| Slot 0 Offset 0x60 Length 119 | Memory Dump @0x0000003EC487A060                                                   |         | 0000000000000014:   02000001 0077002d 0442043e 04420420 00420435  .....w.-.B.>.B. .B.5 |
| Slot 0 Offset 0x60 Length 119 | Memory Dump @0x0000003EC487A060                                                   |         | 0000000000000028:   043a0441 04420420 0034043e 043b0436 0435043d  .:.A.B. .4.>.;.6.5.= |
| Slot 0 Offset 0x60 Length 119 | Memory Dump @0x0000003EC487A060                                                   |         | 000000000000003C:   04200032 04380434 04350442 044c0420 0042043e  . .2.8.4.5.B.L. .B.> |
| Slot 0 Offset 0x60 Length 119 | Memory Dump @0x0000003EC487A060                                                   |         | 0000000000000050:   043b044c 043a043e 04200030 0434043c 0438043d  .;.L.:.>. .0.4.<.8.= |
| Slot 0 Offset 0x60 Length 119 | Memory Dump @0x0000003EC487A060                                                   |         | 0000000000000064:   04380441 04420440 04300442 043e0440 042100    .8.A.B.@.0.B.>.@.!.  |
| Slot 0 Offset 0x60 Length 119 | column1 = [Binary data] Slot 0 Column 1 Offset 0x4 Length 16 Length (physical) 16 |         | 0000003EC487A064:   811fa45d 36c581e4 11e8f9dc d58ab12f           .¤]6Åä.èùÜÕŠ±/       |
| Slot 0 Offset 0x60 Length 119 | Slot 0 Column 2 Offset 0x1b Length 92 Length (physical) 92                        | column2 | Этот текст должен видеть только администратор!                                         |

В предпоследней строке с описанием "column1 = [Binary data] Slot 0 Column 1 Offset 0x4 Length 16 Length (physical) 16" содержится значение идентификатора в первой колонке "811fa45d 36c581e4 11e8f9dc d58ab12f". В последней строке с описанием "Slot 0 Column 2 Offset 0x1b Length 92 Length (physical) 92" содержится значение второй колонки "Этот текст должен видеть только администратор!". 

Дело сделано! Мы прочитали содержимое временной таблицы другой сессии. Да, это не очень удобно в таком виде получать содержимое таблицы с большим количеством записей. Но здесь был продемонстрирован принцип, а инструменты для удобства можно создавать отдельно. Также есть и еще одно важное ограничение: использовать служебную процедуру "PAGE" можно только с правами "sysadmin". Это стоит учитывать в работе. То есть этот способ доступен только для администратора или разработчика с соответствующими правами.

А Вам слабо? :)

## И немного диагностики

Выше не раз упоминались некоторые скрипты, которые использовались для получения данных о временных таблицах. Продублируем их здесь для удобства.

```sql
-- Список всех временных таблиц
SELECT
	[name] AS [TableName],
	[object_id] AS [ObjectId],
	[schema_id] AS [SchemaId],
	[parent_object_id] AS [ParentObjectId],
	[type] AS [TableType],
	[create_date] AS [Created],
	[modify_date] AS [Modified],
	[is_published] AS [IsPublished],
	[is_schema_published] AS [IsSchemaPublished]
FROM tempdb.sys.objects
WHERE [is_ms_shipped] = 0
```

```sql
-- Все соединения СУБД
DECLARE @AllConnections TABLE(
    SPID INT,
    Status VARCHAR(MAX),
    LOGIN VARCHAR(MAX),
    HostName VARCHAR(MAX),
    BlkBy VARCHAR(MAX),
    DBName VARCHAR(MAX),
    Command VARCHAR(MAX),
    CPUTime INT,
    DiskIO INT,
    LastBatch VARCHAR(MAX),
    ProgramName VARCHAR(MAX),
    SPID_1 INT,
    REQUESTID INT
)

INSERT INTO @AllConnections EXEC sp_who2

SELECT * FROM @AllConnections
```

```sql
-- Информация о хранении временных таблиц
SELECT
    T.name,
    T.[object_id],
    AU.type_desc,
    AU.first_page,
    AU.data_pages,
    P.[rows]
FROM tempdb.sys.tables AS T
JOIN tempdb.sys.partitions AS P
    ON P.[object_id] = T.[object_id]
JOIN tempdb.sys.system_internals_allocation_units AS AU
ON  (
        AU.type_desc = N'IN_ROW_DATA'
        AND AU.container_id = P.partition_id
    )
    OR
    (
        AU.type_desc = N'ROW_OVERFLOW_DATA'
        AND AU.container_id = P.partition_id
    )
    OR
    (
        AU.type_desc = N'LOB_DATA' 
        AND AU.container_id = P.hobt_id
    )
WHERE T.name LIKE N'#ttTest%'; -- Здесь отбор по имени временной таблицы
```

```sql
-- Использующие tempdb-сессии
SELECT
    st.dbid AS QueryExecutionContextDBID,
    DB_NAME(st.dbid) AS QueryExecContextDBNAME,
    st.objectid AS ModuleObjectId,
    SUBSTRING(st.TEXT,
        dmv_er.statement_start_offset/2 + 1,
        (CASE WHEN dmv_er.statement_end_offset = -1
        THEN LEN(CONVERT(NVARCHAR(MAX),st.TEXT)) * 2
        ELSE dmv_er.statement_end_offset
        END - dmv_er.statement_start_offset)/2) AS Query_Text,
    dmv_tsu.session_id ,
    dmv_tsu.request_id,
    dmv_tsu.exec_context_id,
    (dmv_tsu.user_objects_alloc_page_count - dmv_tsu.user_objects_dealloc_page_count) AS OutStanding_user_objects_page_counts,
    (dmv_tsu.internal_objects_alloc_page_count - dmv_tsu.internal_objects_dealloc_page_count) AS OutStanding_internal_objects_page_counts,
    dmv_er.start_time,
    dmv_er.command,
    dmv_er.open_transaction_count,
    dmv_er.percent_complete,
    dmv_er.estimated_completion_time,
    dmv_er.cpu_time,
    dmv_er.total_elapsed_time,
    dmv_er.reads, dmv_er.writes,
    dmv_er.logical_reads,
    dmv_er.granted_query_memory,
    dmv_es.HOST_NAME,
    dmv_es.login_name,
    dmv_es.program_name
FROM sys.dm_db_task_space_usage dmv_tsu
    INNER JOIN sys.dm_exec_requests dmv_er
    ON (dmv_tsu.session_id = dmv_er.session_id AND dmv_tsu.request_id = dmv_er.request_id)
    INNER JOIN sys.dm_exec_sessions dmv_es
    ON (dmv_tsu.session_id = dmv_es.session_id)
CROSS APPLY sys.dm_exec_sql_text(dmv_er.sql_handle) st
WHERE (dmv_tsu.internal_objects_alloc_page_count + dmv_tsu.user_objects_alloc_page_count) > 0
ORDER BY (dmv_tsu.user_objects_alloc_page_count - dmv_tsu.user_objects_dealloc_page_count) + (dmv_tsu.internal_objects_alloc_page_count - dmv_tsu.internal_objects_dealloc_page_count) DESC
```

Список не большой, но может пригодиться.

## Будьте здоровы!

Временные таблицы - очень интересный объект и то как с ним работает платформа 1С. Конечно, мы не раскрыли тему полностью, но, надеюсь, что-нибудь интересное Вы нашли. 

Спасибо за внимание и будьте здоровы!
