---
layout: post
title: Файловые группы MS SQL Server и 1С:Предприятие 8.x
categories: [SQL Server, 1C]
---

# О чем речь

Речь будет идти об использовании файловых групп MS SQL Server в связке с информационной базой 1С:Предприятие 8.x, примерах их использования и некоторых других особенностях.

## Что такое файловые группы

Как известно, каждая база данных имеет как минимум два файла: файл данных и журнала. В файле данных хранятся таблицы с данными, индексы, представления и др. В файлах журналов содержится информация, используемая для поддержки транзакций в базе данных.
Файлов данных может быть несколько, при этом файлы могут быть объединены в файловые группы, упрощающие их администрирование и распределение.

Таким образом, с помощью файловых групп можно эффективно управлять файлами базы данных. Более подробную информацию можно [прочитать здесь](https://docs.microsoft.com/ru-ru/sql/relational-databases/databases/database-files-and-filegroups?view=sql-server-2017).

## Особенности для баз 1С:Предприятия

Платформа 1С:Предприятия не имеет официальной поддержки работы с файловыми группами MS SQL Server. Поэтому стоит учитывать следующее:
* При реструктуризациях таблиц платформа всегда выполняет операции на файловой группе по умолчанию, поэтому настройки могут быть сброшены.
* Для переноса существующих таблиц в другую файловую группу потребуются дополнительные действия, в том числе может понадобиться ручное пересоздание таблицы.
* Использование средств СУБД, которые явно не рекомендованы фирмой "1С" является нарушением лицензионного соглашения.

Более подробно о каждом пункте поговорим далее.

# Исходные данные

## Структура базы

Все примеры будем выполнять на SQL-базе "JustDoIt", сформированной платформой 1С для простой конфигурации из двух справочников.

![Таблицы справочников в конфигурации 1С](/images/2018-06-17-FileGroupsAnd1C\Таблицы1СиSQL.png)

Как можно увидеть, в первом справочнике все реквизиты имеют простые типы, которые не используют BLOB'ы на стороне базы данных. Второй же справочник содержит два реквизита с типом "Неограниченная строка" (тип *nvarcahr(max)*) и "Хранилище значений" (тип *varbinary(max)* для новых версий платформы 1С и *image* для старый версий), при работе с которыми используются BLOB'ы и это влияет на создание файловых групп для этих таблиц. 

## Наполнение тестовыми данными

Для наполнения тестовыми данными таблиц воспользуется простым алгоритмом на языке платформы 1С:

```bsl
ПредыдущаяСсылка = Справочники.ТаблицаПростая.ПустаяСсылка();
Для Сч = 1 По 3000000 Цикл
	
	НовОбъект = Справочники.ТаблицаПростая.СоздатьЭлемент();
	НовОбъект.РеквизитСтрока = "Элемент " + Сч;
	НовОбъект.РеквизитЧисло = Сч;
	НовОбъект.РеквизитБулево = ?(Сч % 2 = 0, Истина, Ложь);
	НовОбъект.РеквизитДатаВремя = ТекущаяДата();
	НовОбъект.РеквизитСсылка = ПредыдущаяСсылка;
	НовОбъект.Записать();
	ПредыдущаяСсылка = НовОбъект.Ссылка;
	
	НовОбъектBLOB = Справочники.Таблица_BLOB.СоздатьЭлемент();
	НовОбъектBLOB.РеквизитСтрока = "Элемент " + Сч;
	НовОбъектBLOB.РеквизитНеограниченнаяСтрока = "Элемент " + Сч + " " + Формат(ТекущаяДата(), "ДЛФ=DDT");		
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, НовОбъект);
	СтрокаXML = ЗаписьXML.Закрыть();	
	НовОбъектBLOB.РеквизитХранилищеЗначений = Новый ХранилищеЗначения(СтрокаXML);
	
	НовОбъектBLOB.Записать();
	
КонецЦикла;
```

В результате получим базу с заполненными таблицами.

| Имя справочника | Имя таблицы  | Количество записей | Размер данных (МБ) | Размер индексов (МБ) | Зарезервировано (МБ) | Неиспользовано (МБ) |
| ------------- | -------------  | ------------- | ------------- | ------------- | ------------- | ------------- |
| Справочник.ТаблицаПростая | _Reference18  | 3 000 000 | 570 | 534 | 1105 | 1 |
| Справочник.Таблица_BLOB | _Reference19  | 3 000 000 | 3992 | 525 | 4518 | 1 |

То что нужно! Теперь перейдем непосредственно к примеру.

# Реализация

Все действия мы будем выполнять через скрипты без использования пользовательского интерфейса. Этот подход предпочтительнее, т.к. позволяет выполнять настройки с большим контролем и с расширенными возможностями. Никто Вам не запрещает использовать интерфейс SQL Managment Studio :)

## Создание файловой группы

Это самый простой шаг. Создадим файловую группу "SECONDARY" для нашей тестовой базы.

```sql
USE [master]

ALTER DATABASE [JustDoIt] ADD FILEGROUP [SECONDARY]
```

## Добавление нового файла
Далее добавим новый файл базы с принадлежностью к новой файловой группе.

```sql
USE [master]

ALTER DATABASE [JustDoIt] ADD FILE ( 
    -- Имя файла
	NAME = N'JustDoIt_Additional', 
    -- Путь к файлу
	FILENAME = N'D:\DBs\JustDoIt_Additional.mdf' , 
    -- Начальный размер файла
	SIZE = 50000000KB,
    -- Автоприращения файла при увеличении размера данных
	FILEGROWTH = 100000KB ) 
TO FILEGROUP [SECONDARY]
```

## Перемещение таблицы в файловую группу

Рассмотрим два случая по перемещению таблиц и индексов в другую файловую группу. Первый случай - обычная таблица, а второй - таблицам с типом данных, которых хранится в отдельном BLOB'е.

### Обычные таблицы

В качестве примера обычной таблицы возьмем "_Reference18" (Справочник.ТаблицаПростая), в которой отсутствуют BLOB'ы. Поскольку таблица имеет кластерный индекс, то в этом случае, все что необходимо сделать - это пересоздать его в новой файловой группе.

```sql
USE [JustDoIt]
GO

-- Удаляем ограничения по ключу
ALTER TABLE [dbo].[_Reference18] DROP CONSTRAINT [PK___Referen__AC8ED0C49AB0EE5C]
GO

-- Пересоздаем кластерный индекс в файловой группе SECONDARY
ALTER TABLE [dbo].[_Reference18] ADD PRIMARY KEY CLUSTERED 
(
	[_IDRRef] ASC
)WITH (
	PAD_INDEX = OFF, 
	STATISTICS_NORECOMPUTE = OFF, 
	SORT_IN_TEMPDB = OFF, 
	IGNORE_DUP_KEY = OFF, 
	ONLINE = OFF, 
	ALLOW_ROW_LOCKS = ON, 
	ALLOW_PAGE_LOCKS = ON
) ON [SECONDARY] -- Указание файловой группы назначения
GO
```

То же самое проделаем со всеми остальными индексами таблицы.

```sql
DROP INDEX [_Reference18_1] ON [dbo].[_Reference18]
GO
CREATE NONCLUSTERED INDEX [_Reference18_1] ON [dbo].[_Reference18]
(
	[_PredefinedID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, 
	SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, 
	ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) 
ON [SECONDARY] -- Указание файловой группы назначения
GO

-- Пересоздаем второй индекс
DROP INDEX [_Reference18_2] ON [dbo].[_Reference18]
GO
CREATE UNIQUE NONCLUSTERED INDEX [_Reference18_2] ON [dbo].[_Reference18]
(
	[_Code] ASC,
	[_IDRRef] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, 
	IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, 
	ALLOW_PAGE_LOCKS = ON) 
ON [SECONDARY] -- Указание файловой группы назначения
GO

-- Пересоздаем третий индекс
DROP INDEX [_Reference18_3] ON [dbo].[_Reference18]
GO
CREATE UNIQUE NONCLUSTERED INDEX [_Reference18_3] ON [dbo].[_Reference18]
(
	[_Description] ASC,
	[_IDRRef] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, 
	IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, 
	ALLOW_PAGE_LOCKS = ON) 
ON [SECONDARY] -- Указание файловой группы назначения
GO
```

После, посмотрев состав файловых групп, мы увидим в группе "SECONDARY" новые объекты.

| Таблица | Имя объекта | Файловая группа |
|----------|----------|----------|
|_Reference18|PK___Referen__AC8ED0C40CE5F12A|SECONDARY|
|_Reference18|_Reference18_1|SECONDARY|
|_Reference18|_Reference18_2|SECONDARY|
|_Reference18|_Reference18_3|SECONDARY|

Все индексы, в том числе и кластерный индекс, были перенесены в новую файловую группу. Т.к. кластерный индекс фактически содержит данные таблицы, то вместе с ним в новую файловую группу были перенесены все данные.

### Таблицы с BLOB'ами

Таблица с BLOB'ами - это "_Reference19" (Справочник.Таблица_BLOB). Здесь особыми полями, которые хранятся в виде BLOB'ов, являются "_Fld26" (неограниченная строка nvarchar(max)) и "_Fld27" (двоичные данные varbinary(max)). Данные остальных полей, а также индексов, можно перенести в новую файловую группу простым пересозданием кластерных и остальных индексов, о чем было написано в предыдущем примере. Но вот поля, хранящиеся в виде BLOB'ов перенесены не будут, т.к. для них нужно указывать отдельную текстовую файловую группу в свойствах таблицы.

Для существующей таблицы текстовую файловую группу изменить нельзя, поэтому единственным правильным вариантом остается пересоздание таблицы и индексов для нее с последующим перемещением данных из старой таблицы в новую.

Простейший скрипт для выполнения такой операции представлен ниже.

```sql
BEGIN TRANSACTION
GO
-- Создаем таблицу с такой же структурой как исходная таблица
CREATE TABLE dbo.Tmp__Reference19
	(
	_IDRRef binary(16) NOT NULL,
	_Version timestamp NOT NULL,
	_Marked binary(1) NOT NULL,
	_PredefinedID binary(16) NOT NULL,
	_Code nvarchar(9) NOT NULL,
	_Description nvarchar(25) NOT NULL,
	_Fld25 nvarchar(255) NOT NULL,
	_Fld26 nvarchar(MAX) NOT NULL,
	_Fld27 varbinary(MAX) NOT NULL
	)  
    ON [SECONDARY] -- Основная файловая группа
	TEXTIMAGE_ON SECONDARY -- Файловая группа text/image
GO
-- Указываем разрешенный метод укрупнения блокировки для таблицы 
-- TABLE - Укрупнение блокировки будет выполняться на уровне 
-- гранулярности таблицы независимо от того, секционирована таблица или нет.
ALTER TABLE dbo.Tmp__Reference19 SET (LOCK_ESCALATION = TABLE)
GO
-- Переносим данные из исходной таблицы в новоую
IF EXISTS(SELECT * FROM dbo._Reference19)
	 EXEC(
		'INSERT INTO dbo.Tmp__Reference19 (
		 	_IDRRef, _Marked, _PredefinedID, _Code, _Description, _Fld25, _Fld26, _Fld27)
		SELECT _IDRRef, _Marked, _PredefinedID, _Code, _Description, _Fld25, _Fld26, _Fld27 
		FROM dbo._Reference19 WITH (HOLDLOCK TABLOCKX)')
GO
-- Удаляем старую таблицу
DROP TABLE dbo._Reference19
GO
-- Переименовываем новую таблицу, что имя совпадало с именем старой таблицы
EXECUTE sp_rename N'dbo.Tmp__Reference19', N'_Reference19', 'OBJECT' 
GO
-- Добавляем кластерный индекс
ALTER TABLE dbo._Reference19 ADD CONSTRAINT
	PK___Referen__AC8ED0C42B334E1B PRIMARY KEY CLUSTERED 
	(
	_IDRRef
	) WITH( 
        STATISTICS_NORECOMPUTE = OFF, 
        IGNORE_DUP_KEY = OFF, 
        ALLOW_ROW_LOCKS = ON, 
        ALLOW_PAGE_LOCKS = ON) 
    ON [SECONDARY]

GO
-- Далее создаем оставшиеся индексы
CREATE NONCLUSTERED INDEX _Reference19_1 ON dbo._Reference19
	(
	_PredefinedID
	) WITH( 
        STATISTICS_NORECOMPUTE = OFF, 
        IGNORE_DUP_KEY = OFF, 
        ALLOW_ROW_LOCKS = ON, 
        ALLOW_PAGE_LOCKS = ON) 
    ON [SECONDARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX _Reference19_2 ON dbo._Reference19
	(
	_Code,
	_IDRRef
	) WITH( 
        STATISTICS_NORECOMPUTE = OFF, 
        IGNORE_DUP_KEY = OFF, 
        ALLOW_ROW_LOCKS = ON, 
        ALLOW_PAGE_LOCKS = ON) 
    ON [SECONDARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX _Reference19_3 ON dbo._Reference19
	(
	_Description,
	_IDRRef
	) WITH( 
        STATISTICS_NORECOMPUTE = OFF, 
        IGNORE_DUP_KEY = OFF, 
        ALLOW_ROW_LOCKS = ON, 
        ALLOW_PAGE_LOCKS = ON) 
    ON [SECONDARY]
GO
COMMIT
```

После выполнения скрипта по нашему примеру все объекты, связанные с таблицей "_Reference19", будут перенесены в файловую группу "SECONDARY":

| Таблица | Имя объекта | Файловая группа |
|----------|----------|----------|
|_Reference19|PK___Referen__AC8ED0C42B334E1B|SECONDARY|
|_Reference19|_Reference19_1|SECONDARY|
|_Reference19|_Reference19_2|SECONDARY|
|_Reference19|_Reference19_3|SECONDARY|

Скрипт нужно дорабатывать в зависимости от задачи. Например, если в исходной таблице большой объем данных, то целесообразней переносить порциями. 

Для экономии времени скрипт пересоздания таблицы можно сгенерировать с помощью конструктора SQL Managment Studio, но после этого его обязательно необходимо проверить на соответствие Вашей задаче.

## Уменьшение размера основного файла

Для уменьшения размера основного файла данных нужно выполнить операцию "SHRINKDATABASE". На рабочем окружении обычно такие операции не выполняются, т.к. могут привести к деградации производительности из-за увеличения фрагментации индексов. Поэтому нужно использовать ее с осторожностью и только при крайней необходимости.

```sql
USE [JustDoIt]
GO
DBCC SHRINKFILE (N'JustDoIt' , 1000)
GO
```

После этой операции основной файл данных уменьшится на общий размер данных таблиц и индексов, которые были перемещены в другую файловую группу.

# Особенности сопровождения

Рассмотрим несколько нюансов в части сопровождения сделанных настроек.

## Просмотр файловых групп
Для просмотра списка объектов и их принадлежности к определенным файловым группам можно использовать скрипт ниже.
```sql
SELECT 
    o.[name] AS "Table",
    o.[type] AS "Type", 
    i.[name] AS "ObjectName", 
    i.[index_id] AS "IndexID", 
    f.[name] AS "FileGroupName"
FROM sys.indexes i
    INNER JOIN sys.filegroups f
    ON i.data_space_id = f.data_space_id
    INNER JOIN sys.all_objects o
    ON i.[object_id] = o.[object_id] 
WHERE i.data_space_id = f.data_space_id
    -- Only user created tables
    AND o.type = 'U'
```

## Внимание, реструктуризация!

Для того, чтобы не попасть в ситуацию, когда внезапно настройки файловых групп перестали действовать для Вашей базы 1С, нужно соблюдать несколько правил:
*	Перед каждой реструктуризацией проверять, что в нее не входят таблицы из других файловых групп.
*	При необходимости выполнить реструктуризацию на таблице в нестандартной файловой группе следует разделить операцию на несколько шагов: 
	* Сначала выполнить реструктуризацию тех объектов, которые находятся в файловой группе "PRIMARY"
	* Сменить файловую группу по умолчанию для базы с помощью такого скрипта
	```sql
	USE [JustDoIt]
	GO
	IF NOT EXISTS (
		SELECT name FROM sys.filegroups WHERE is_default=1 AND name = N'SECONDARY')	
		ALTER DATABASE [JustDoIt] MODIFY FILEGROUP [SECONDARY] DEFAULT
	GO
	```
	* Далее выполнить реструктуризацию таблиц, которые находятся в файловой группе "SECONDARY"
	* Вернуть файловую группу по умолчанию на "PRIMARY"
	```sql
	USE [JustDoIt]
	GO
	IF NOT EXISTS (
		SELECT name FROM sys.filegroups WHERE is_default=1 AND name = N'PRIMARY')	
		ALTER DATABASE [JustDoIt] MODIFY FILEGROUP [PRIMARY] DEFAULT
	GO
	```
	* Profit! :)
* Для защиты от случайных реструктуризаций можно сделать глобальный триггер, перехватывающий создание таблиц. В нем проверять по имени таблицы и файловой группы возможность реструктуризации. Если она невозможна, то выводить ошибку. Подробнее на этом варианте останавливаться сейчас не будем.

## Бэкап! Бэкап!

Стандартный способ создание резервной копии базы - это полная копия файла базы данных. Пример следующего скрипта как-раз демонстрирует создание полной резервной копии.
```sql
BACKUP DATABASE [JustDoIt] TO  DISK = N'F:\Backup\JustDoIt.bak' 
	WITH NOFORMAT, 
	NOINIT,  
	NAME = N'JustDoIt-FullBackup', 
	SKIP, 
	NOREWIND, 
	NOUNLOAD,  
	STATS = 10
```

При использовании файловых групп появляются дополнительные возможности создания резервных копий. Вместо бэкапирования всего файла можно создать копию отдельной файловой группы "SECONDARY":

```sql
BACKUP DATABASE [JustDoIt] 
	-- Файловая группа для бэкапирования
	FILEGROUP = N'SECONDARY' 
	TO  DISK = N'F:\Backup\JustDoIt.bak'
	 WITH NOFORMAT, 
	 NOINIT,  
	 NAME = N'JustDoIt-SecondaryFileGroup', 
	 SKIP, 
	 NOREWIND, 
	 NOUNLOAD,  
	 STATS = 10
```

В скрипте можно указать сразу несколько файловых групп для бэкапирования:
```sql
BACKUP DATABASE [JustDoIt]
	-- Перечисляем файловые группы 
	FILEGROUP = N'PRIMARY',  
	FILEGROUP = N'SECONDARY' 
	TO  DISK = N'F:\Backup\JustDoIt.bak' 
	WITH NOFORMAT, 
	NOINIT,  
	NAME = N'JustDoIt-TwoFileGroups', 
	SKIP, 
	NOREWIND, 
	NOUNLOAD,  
	STATS = 10
```

Таким образом использование файловых групп создает обширные возможности для кастомизации стратегии бэкапирования. Более подробную информацию можно [узнать здесь](https://docs.microsoft.com/ru-ru/sql/relational-databases/backup-restore/back-up-files-and-filegroups-sql-server?view=sql-server-2017).

## Нарушение лицензионного соглашения

Да, к сожалению, это так... Если Вы начинаете вмешиваться в работу базы данных 1С средствами СУБД, то в большинстве случаев это считается нарушением [лицензионного соглашения](http://v8.1c.ru/predpriyatie/questions_licence.htm#lrvs1cpp) фирмы "1С", пункт 65 которого гласит:

>Лицензионное соглашение не позволяет использовать недокументированные фирмой "1С" средства для построения решений на платформе 1С:Предприятие. Это означает, что средства СУБД (или любые другие внесистемные средства) можно использовать только в том случае, если документация по продуктам линейки "1С:Предприятие" (включая 1С:ИТС) содержит явную рекомендацию использовать данное средство для решения данной задачи.
>
>Во всех остальных случаях лицензионное соглашение позволяет использовать для построения решений только штатные средства платформы. В частности, можно обращаться к данным информационной базы только при помощи объектов "1С:Предприятия", специально предназначенных для работы с данными (запросы, справочники, документы и т.д.). Нельзя обращаться к данным информационной базы напрямую, минуя уровень объектов работы с данными "1С:Предприятия" - например при помощи средств СУБД или при помощи внешних компонент, которые реализуют прямой доступ к СУБД. Это ограничение распространяется на любые действия с данными, в том числе на изменение их структуры, а так же на чтение или изменение самих данных информационной базы или служебных данных "1С:Предприятия".
>
>Данное ограничение необходимо для обеспечения стабильности работы механизмов системы, осуществления поддержки и возможности перехода на новые версии "1С:Предприятия".

На практике это может вылиться в отказ в оказании технической поддержки со стороны фирмы "1С".

**Ответственность за это только на Вас!**

# Стоит ли оно того?

В тех случаях, когда у Вас небольшая база, небольшое количество транзакций и просто устраивает текущая производительность, то стоит трижды подумать о необходимости использования файловых групп. Скорее всего они Вам не нужны.

Однако, если база у Вас большая, то в целях разделения ее на разные диски, улучшения производительности, совершенствования стратегии бэкапирования и использование [секционирования таблиц](https://docs.microsoft.com/ru-ru/sql/relational-databases/partitions/partitioned-tables-and-indexes?view=sql-server-2017) - файловые группы это то что нужно!

**Автор не несет ответственности за все действия, выполняемые по материалам данной статьи!**
**Будьте внимательны!!!**
