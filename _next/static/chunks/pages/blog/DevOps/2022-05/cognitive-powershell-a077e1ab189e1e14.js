(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1445],{85543:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/DevOps/2022-05/cognitive-powershell",function(){return t(55576)}])},55576:function(e,n,t){"use strict";t.r(n);var o=t(85893),a=t(44853);t(67294);var s=t(74313),l=t(29209);n.default=()=>(0,o.jsxs)(a.Xg,{blogcentered:!0,children:[(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Мы снова здесь!"}),(0,o.jsxs)(a.xv,{p:!0,children:["В прошлогодней статье ",(0,o.jsx)("b",{children:(0,o.jsx)("u",{children:(0,o.jsx)(a.e9,{newTab:!0,href:"/pages/blog/DevOps/2021-05/amusing-powershell.tsx",children:"“Занимательный PowerShell”"})})})," мы уже говорили про применение мощного скриптового языка PowerShell для решения насущных задач."]}),(0,o.jsx)(a.xv,{p:!0,children:"Сегодня мы пробежимся по новым скриптам и задачам, которые с их помощью можно решить. От задач связанных с платформой 1С, так и до более отдаленных."}),(0,o.jsx)(a.xv,{p:!0,children:"В этот раз мы не будем рассматривать настройку окружения, различных инструментов для разработки скриптов на PowerShell и связанные с этим темы. Все это Вы можете посмотреть в предыдущей статье."}),(0,o.jsx)(a.xv,{p:!0,children:"Итак, ближе к делу!"}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Удаляйте журналы вовремя"}),(0,o.jsx)(a.xv,{p:!0,children:"Все мы знаем, что журналы регистрации платформа 1С хранит в каталоге кластера, а точнее в подкаталогах каждой информационной базы. Это не относится к файловым базам, но они нам не интересны."}),(0,o.jsx)(a.xv,{p:!0,children:"С учетом того, что остается только текстовый вариант журнала, ведь из-за известных проблем SQLite-формата сама фирма “1С” отказывается от него (но это не точно?), встает задача периодической очистки файлов для освобождения места."}),(0,o.jsx)(a.xv,{p:!0,children:"Чтобы делать очистку от старых записей журнала регистрации без остановки службы сервера 1С можно включить разделение файлов журнала по периоду. Например, по дням. Делается это в конфигураторе."}),(0,o.jsx)(a.Ee,{className:"my-4",src:"/public/imp_assets/DevOps/2022-05/cognitive-powershell/1. Разделение журнала регистрации.png",alt:"Разделение журнала регистрации",size:l.h2.MEDIUM}),(0,o.jsx)(a.xv,{p:!0,children:"Тогда на каждый день мы будем получать новые файлы. В большинстве случаев старые файлы не будут заняты серверными процессами платформы 1С и могут быть спокойно удалены."}),(0,o.jsx)(a.xv,{p:!0,children:"Затем берем скрипт очистки от файлов журнала регистрации."}),(0,o.jsx)(a.xv,{p:!0,children:"В скрипте указываем количество дней, сколько должны файлы журнала регистрации храниться. Также можно указать ниже отбор по имени информационной базы."}),(0,o.jsx)(a.xv,{p:!0,children:"Скрипт находит установленные службы 1С, для каждой из них анализирует каталог кластера и во всех каталогах с файлами журналов регистрации удаляет файлы формата “*.lgp”. Путь к каталогам журналов регистрации получаем через анализ файла конфигурации кластера."}),(0,o.jsx)(s.Z,{code:'\n$limit = (Get-Date).AddDays(-15) # Файлы старше 15 дней\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$services1C | % {\n    $serviceExecPath = $services1C.PathName;\n\n    $hash = [ordered]@{}\n    $serviceExecPath.Split("-").Trim() | Where-Object { $_.Contains(" ") } | ForEach-Object { \n        $name, $value = $_ -split \'\\s+\', 2\n        $hash[$name] = $value\n    }\n\n    $clusterPath = $hash.d -replace \'"\', \'\'\n    $clusterRegPort = $hash.regport\n    $clusterRegPath = "$clusterPath\\reg_$clusterRegPort"\n    $clusterConfigFile = "$clusterRegPath\\1CV8Reg.lst"\n    $clusterConfigFileExists = Test-Path $clusterConfigFile -PathType Leaf\n    if($clusterConfigFileExists -eq $false)\n    {\n        $clusterConfigFile = "$clusterRegPath\\1CV8Clst.lst"\n    }\n    $clusterConfigFileExists = Test-Path $clusterConfigFile -PathType Leaf\n    if($clusterConfigFileExists -eq $true)\n    {\n        Select-String -Path $clusterConfigFile \'{[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12},\\"[A-Za-z0-9-_]+\\"\' -AllMatches | \n        Foreach-Object {$_.Matches} | \n        ForEach-Object {\n            $parsedString = $_.Value -split ","\n            $ibGuid = $parsedString[0] -replace "{", "" \n            $ibName = $parsedString[1] -replace \'"\', ""\n            \n            # Фильтр по имени базы. По умолчанию все базы\n            if($ibName -like "*")\n            {\n                $eventLogPath = "$clusterRegPath\\$ibGuid\\1Cv8Log"\n                $eventLogPathExists = Test-Path $eventLogPath -PathType Container\n                if($eventLogPathExists -eq $true)\n                {\n                    Write-Host "Infobase for clearing event log: $ibName"\n                    Write-Host "Event log path: $eventLogPath"            \n        \n                    $logFilesData = Get-ChildItem -Path $eventLogPath *.lgp -Force | \n                    Where-Object { !$_.PSIsContainer -and $_.CreationTime -lt $limit } \n                    Write-Host "Log files to remove:"\n                    $logFilesData                    \n                    $logFilesData | Remove-Item -Force\n\n                    $logFilesIndexes = Get-ChildItem -Path $eventLogPath *.lgx -Force | \n                    Where-Object { !$_.PSIsContainer -and $_.CreationTime -lt $limit } \n                    Write-Host "Log indexes files to remove:"\n                    $logFilesIndexes                    \n                    $logFilesIndexes | Remove-Item -Force\n                }\n            }\n        }\n    } else\n    {\n        Write-Host "Cluster config file not found: $clusterConfigFile"\n    }\n}\n                ',className:"my-5",language:"powershell"}),(0,o.jsx)(a.xv,{p:!0,children:"Под специфичные случаи скрипт можно поменять. Например, явно указав каталоги для очистки или добавив архивирование старых “*.lgp” файлов. В последнем случае не забудьте также сохранить файл с ссылочными данными “1Cv8.lgf”."}),(0,o.jsx)(a.xv,{p:!0,children:"В общем, не стесняйтесь изменять скрипт под себя!"}),(0,o.jsx)(a.xv,{p:!0,children:"Для регулярного запуска можно использовать планировщик Windows, создав в нем задачу с подобной командой:"}),(0,o.jsx)(s.Z,{code:'\npowershell.exe -NoProfile -ExecutionPolicy Bypass -File "<ПутьКФайлуСоСкриптом>.ps1"\n                ',className:"my-5",language:"bash"}),(0,o.jsx)(a.xv,{p:!0,children:"Задача решена, теперь поехали дальше."}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Ох уж эти COM-объекты"}),(0,o.jsx)(a.xv,{p:!0,children:"В прошлой статье мы уже рассматривали действия по регистрации, удалению регистрации и проверке работы COM-компоненты платформы 1С. Теперь перейдем на другой уровень!"}),(0,o.jsx)(a.xv,{p:!0,children:"Всем известно, что на одном сервере могут быть зарегистрированы COM-компоненты разных версий платформы 1С. Но почему бы не автоматизировать этот процесс и выполнять регистрацию COM-компонентов по одному щелчку."}),(0,o.jsx)(a.xv,{p:!0,children:"Принцип действия такой:"}),(0,o.jsxs)(a.aV,{children:[(0,o.jsx)("li",{children:"Указываем список COM-компонентов для регистрации с именем (должно быть уникальным); путем до comcntr.dll нужной версии; а также именем и пользователем операционной системы, от имени которого будет работать компонента."}),(0,o.jsx)("li",{children:"Затем для каждой настройки устанавливается COM+-приложение."}),(0,o.jsx)("li",{children:"Далее регистрируется компонента в приложении."}),(0,o.jsx)("li",{children:"Обновляются настройки доступа."}),(0,o.jsx)("li",{children:"И на последнем шаге корректируются настройки реестра, т.к. установка каждой новой COM-компоненты ломает настройки ранее установленных COM’ов."})]}),(0,o.jsx)(a.xv,{p:!0,children:"При этом, если ранее приложение и компонента уже были установлены, то предварительно они будут удалены."}),(0,o.jsx)(s.Z,{code:'\n# Предварительно перечислеяем COM-компоненты для регистрации с их путями до DLL, а также параметры авторизации для каждого приложения (пользователя и пароль)\n# По указанному имени после регистрации можно будет обращаться к этому COM-компоненту из скриптов или самой платформы 1С.\n# Поле CLSID не нужно заполнять (!!!). Оно будет заполнено автоматически присвоенным ID при регистрации компоненты.\n$dllForRegistration =\n@(\n    [pscustomobject]@{Name="V8.2.19.130.COMConnector";DLLPath="C:\\Program Files\\1cv82\\8.2.19.130\\bin\\comcntr.dll";UserName="yy\\ypermitin";UserPassword="";CLSID=""},\n    [pscustomobject]@{Name="V8.3.6.2530.COMConnector";DLLPath="C:\\Program Files\\1cv8\\8.3.6.2530\\bin\\comcntr.dll";UserName="yy\\ypermitin";UserPassword="";CLSID=""},\n    [pscustomobject]@{Name="V8.3.8.2442.COMConnector";DLLPath="C:\\Program Files\\1cv8\\8.3.8.2442\\bin\\comcntr.dll";UserName="yy\\ypermitin";UserPassword="";CLSID=""}\n);\n\nfunction InstallApplication($comAdmin, $comObjectName, $DLLPath, $username = "", $userpassword = "") {\n\n    $AppID = "{$(New-Guid)}".ToUpper();\n    $AppName = $comObjectName -replace ".", "_";\n    $AppDesc = "Application for COM-component ""$AppName""";\n\n    $Apps = $comAdmin.GetCollection("Applications")\n    $Apps.Populate();\n\n    $AppFound = $false\n    $AppFoundedObject = $null\n    $AppFoundIndex = -1;\n    foreach ($App in $Apps ) {\n        $AppFoundIndex = $AppFoundIndex + 1;\n        if ($App.Name -eq $AppName ) {\n            $AppFound = $true;\n            $AppFoundedObject = $App;     \n            break;       \n        }\n    }\n\n    if($null -ne $AppFoundedObject)\n    {\n        $Apps.Remove($AppFoundIndex);\n        $Apps.SaveChanges();\n        Write-Host "$AppName removed" -ForegroundColor Red\n        $AppFound = $false;\n    }\n\n    $NewApp = $null\n    if (!($AppFound)) {\n        $NewApp = $Apps.Add()\n        $NewApp.Value("ID") = $AppID\n        $NewApp.Value("Name") = $AppName\n        $NewApp.Value("Description") = $AppDesc\n        $NewApp.Value("ApplicationAccessChecksEnabled") = $True\n        $NewApp.Value("AccessChecksLevel") = 1 #Component level\n        $NewApp.Value("Activation") = "Local"\n\n        if(![string]::IsNullOrEmpty($username) -and ![string]::IsNullOrEmpty($userpassword))\n        {\n            $NewApp.Value("Identity") = $username;\n            $NewApp.Value("Password") = $userpassword;\n        }\n\n        $Apps.SaveChanges() # | Out-Null\n        Write-Host "$AppName successfully registered" -ForegroundColor Green\n    }\n    Else {\n        Write-Host "$AppName already exists, skipping" -ForegroundColor Green\n    }\n\n    $registeredApplication = [pscustomobject]@{\n        AppId=$AppID;\n        AppName=$AppName;\n        AppDesc=$AppDesc;\n        NewApp=$NewApp;\n        DLLPath = $DLLPath;\n        COMObjectName = $comObjectName;\n    }\n    $registeredApplication\n}\n\nfunction InstallComponent($comAdmin, $registeredApplication) {\n    $AppDLL = $registeredApplication.DLLPath;\n    $AppID = $registeredApplication.AppId;   \n    $comAdmin.InstallComponent($AppID, $AppDLL, "", "");\n    \n    $Apps = $comAdmin.GetCollection("Applications")\n    $Apps.Populate();\n        \n    $Comps = $Apps.GetCollection("Components", $AppID)\n    $Comps.Populate();\n    ForEach ($Comp in $Comps) {\n        $comAdmin.AliasComponent($AppID, $($Comp.Key), $AppID, $($registeredApplication.COMObjectName), "") | Out-Null;\n        break;\n    }\n\n    $Comps = $Apps.GetCollection("Components", $AppID)\n    $Comps.Populate();\n    $CompIndex = -1;\n    $newCreatedComponent = $null;\n    ForEach ($Comp in $Comps) {\n        $CompIndex = $CompIndex + 1;\n        if($Comp.Name -ne $registeredApplication.COMObjectName)\n        {\n            $Comps.Remove($CompIndex);\n            $Comps.SaveChanges() | Out-Null;\n        } else\n        {\n            $newCreatedComponent = $Comp;\n        }\n    }\n\n    $registeredComponent = [pscustomobject]@{\n        CLSID = $newCreatedComponent.Key\n        Name = $newCreatedComponent.Name\n    }\n    $registeredComponent\n}\n\nfunction ConfigureSecurity($comAdmin, $registeredApplication, $registeredComponent, $username = "") {\n\n    $AppID = $registeredApplication.AppId;   \n    $CLSID = $registeredComponent.CLSID\n\n    $Apps = $comAdmin.GetCollection("Applications")\n    $Apps.Populate();\n\n    # Добавляем права доступа на приложение и компоненты.\n    #https://msdn.microsoft.com/en-us/library/windows/desktop/ms678849%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n    $Roles = $Apps.GetCollection("Roles", $AppID)\n    $Roles.Populate();\n\n    $found = $false\n    foreach ( $Role in $Roles ) {\n        if ($Role.Key -eq "CreatorOwner") {\n            $found = $true\n        }\n    }\n    if (!($found)) {\n        $Role = $Roles.Add()\n        $Role.Value("Name") = "CreatorOwner"\n    }\n    $Roles.SaveChanges() | Out-Null;\n\n    if(![string]::IsNullOrEmpty($username))\n    {\n        $Users = $Roles.GetCollection("UsersInRole", "CreatorOwner")\n        $User = $Users.Add()\n        $User.Value("User") = $username\n        $Users.SaveChanges() | Out-Null;\n\n        $Comps = $apps.GetCollection("Components", $AppID)\n        $Comps.Populate();\n\n        ForEach ($Comp In $Comps ) {\n          If ($Comp.Key -eq $CLSID) {\n              $ComponentFound = $True\n          }\n        }\n        If ($ComponentFound ) {\n            $RolesForComponent = $Comps.GetCollection("RolesForComponent", $CLSID)\n            $RoleForComponent = $RolesForComponent.Add()\n            $RoleForComponent.Value("Name") = "CreatorOwner"\n            $RolesForComponent.SaveChanges() | Out-Null;\n        }\n        Else {\n            Write-Warning "CLSID $CLSID not found"\n        }\n    }\n}\n\n$comAdmin = New-Object -comobject COMAdmin.COMAdminCatalog\n\n# Выполнение регистрации всех компонентов\n$dllForRegistration | ForEach-Object {   \n    # Создаем приложение COM+ для каждой версии COM-компоненты\n    $registeredApplication = InstallApplication $comAdmin $($_.Name) $($_.DLLPath) $($_.UserName) $($_.UserPassword)\n\n    # Регистрируем COM-компонету в приложении и корректируем ее псевдоним\n    $registeredComponent = InstallComponent $comAdmin $registeredApplication\n    $_.CLSID = $registeredComponent.CLSID;\n\n    # Обновить настройки доступа\n    ConfigureSecurity $comAdmin $registeredApplication $registeredComponent $($_.UserName)\n}\n\n# Корректруем настройки реестра, "сломанные" после регистрации нескольких COM-компонентов 1C\n$dllForRegistration | ForEach-Object {\n    $destDLLPath = $($_.DLLPath);\n    $itemCLSIDKey = "Registry::HKEY_CLASSES_ROOTCLSID$($_.CLSID)"\n    if(Test-Path -Path $itemCLSIDKey)\n    {\n        $ItemCLSID = Get-Item -Path $itemCLSIDKey\n        $procInfo = Get-ItemProperty "$($ItemCLSID.PSPath)InprocServer32" -ErrorAction SilentlyContinue\n        if($procInfo)\n        {\n            $dllPath = $procInfo.\'(default)\'\n            if($destDLLPath -ne $dllPath)\n            {\n                Set-ItemProperty "$($ItemCLSID.PSPath)InprocServer32" -Name \'(default)\' -Value $destDLLPath\n                Write-Host "Fixed DLL path for ""$($_.Name)"" to ""$($destDLLPath)"" from ""$dllPath""" -ForegroundColor Green\n            }\n        }\n    }\n}\n                ',className:"my-5",language:"powershell"}),(0,o.jsx)(a.xv,{p:!0,children:"В результате мы получим установленные, зарегистрированные и готовые к использованию COM-компоненты платформы 1С. А если нужно будет добавить новую, то просто в скрипте дописываем настройку и запускаем еще разок!"}),(0,o.jsx)(a.xv,{p:!0,children:"В большинстве случаев перезагрузка сервера после этих манипуляций не нужна, но быть готовым к этому нужно."}),(0,o.jsx)(a.xv,{p:!0,children:"Таким образом, одним кликом можно устанавливать множество COM-компонентов разных версий платформ 1С. И доустанавливать новые версии тоже. Не забывайте запускать скрипт с нужными привилегиями. Классная картина, не правда ли."}),(0,o.jsx)(a.Ee,{className:"my-4",src:"/public/imp_assets/DevOps/2022-05/cognitive-powershell/2. COM-компоненты нескольких версий.png",alt:"COM-компоненты нескольких версий",size:l.h2.MEDIUM}),(0,o.jsx)(a.xv,{p:!0,children:"Но зарегистрировать и установить - это одно дело. Иногда нужно еще и узнать какие COM-компоненты уже зарегистрированы в системе. И тут могут быть сложности, ведь регистрацию можно выполнить как с помощью утилиты “regsvr32.exe”, так и с помощь оснастки “Службы компонентов” (та, что на скрине выше). Так узнаем же!"}),(0,o.jsx)(a.xv,{p:!0,children:"Скрипт ниже получит список всех зарегистрированных COM-компонентов, покажет их CLSID, путь к DLL-файлу “comcntr.dll”, а также название инструмента, с помощью которого компонента была зарегистрирована (службы компонентов (comexp.msc) или утилита regsvr32.exe)."}),(0,o.jsx)(a.xv,{p:!0,children:"Скрипт анализирует реестр на наличие установленных COM-компонентов."}),(0,o.jsx)(s.Z,{code:'\n$allComObjects = [System.Collections.ArrayList]@()\n\n# Поиск COM-компонентов, зарегистрированных с помощью regsvr32.exe\nGet-ChildItem HKLM:\\Software\\Classes -ea 0 | \n    Where-Object { \n        $_.PSChildName -match \'^\\w+.\\w+$\' -and \n        (Get-ItemProperty "$($_.PSPath)\\CLSID" -ea 0)\n    } | ForEach-Object {\n        $COMName = $_.PSChildName    \n        $CLSIDProperty = Get-ItemProperty "$($_.PSPath)\\CLSID"    \n        $CLSID = $CLSIDProperty.\'(default)\' -replace \'{\', \'\' -replace \'}\', \'\'\n        \n        if($CLSID)\n        {\n            $itemCLSIDKey = "Registry::HKEY_CLASSES_ROOT\\CLSID\\{$CLSID}"\n            if(Test-Path -Path $itemCLSIDKey)\n            {\n                $ItemCLSID = Get-Item -Path $itemCLSIDKey\n                $procInfo = Get-ItemProperty "$($ItemCLSID.PSPath)\\InprocServer32" -ErrorAction SilentlyContinue\n                if($procInfo)\n                {\n                    $dllPath = $procInfo.\'(default)\'\n\n                    if($dllPath -like \'*comcntr.dll\')\n                    {\n                        $COMObjectInfo = [PSCustomObject]@{\n                            Name = $COMName\n                            CLSID = $CLSID\n                            DLLPath = $dllPath\n                            RegisteredBy = "regsvr32.exe"\n                        }\n\n                        $allComObjects.Add($COMObjectInfo) | Out-Null\n                    }\n                }\n            }\n        }\n    }\n\n# Поиск COM-компонентов, зарегистрированных с помощью службы компонентов\n$comAdmin = New-Object -com ("COMAdmin.COMAdminCatalog.1")\n$applications = $comAdmin.GetCollection("Applications") \n$applications.Populate() \nforeach ($application in $applications)\n{\n\n    $components = $applications.GetCollection("Components",$application.key)\n    $components.Populate()\n    foreach ($component in $components)\n    {\n        $dllName = $component.Value("DLL")\n        if($dllName -like "*comcntr.dll")\n        {\n            $COMName = $component.Name\n            $CLSID = $component.Key -replace "{", "" -replace "}", ""\n            #$component            \n\n            $COMObjectInfo = [PSCustomObject]@{\n                Name = $COMName\n                CLSID = $CLSID\n                DLLPath = $dllName\n                RegisteredBy = "comexp.msc"\n            }\n\n            $allComObjects.Add($COMObjectInfo) | Out-Null\n        }\n    }\n}\n\n$allComObjects | Format-Table\n                ',className:"my-5",language:"powershell"}),(0,o.jsx)(a.xv,{p:!0,children:"Это может быть полезно перед установкой новых COM-компонентов, чтобы знать текущую ситуацию на сервере."}),(0,o.jsx)(a.xv,{p:!0,children:"Также бывают случаи, когда компоненту одновременно регистрируют как с помощью regsvr32.exe, так и с помощью службы компонентов (comexp.msc). Что может приводить к их некорректной работе. Возможно, Вы даже сталкивались с тем, что компоненту зарегистрировали, сервер перезапустили, но все равно она не работает. Возможно, это тот самый случай."}),(0,o.jsx)(a.xv,{p:!0,children:"Вот такой результат мы можем получить."}),(0,o.jsx)(a.Ee,{className:"my-4",src:"/public/imp_assets/DevOps/2022-05/cognitive-powershell/3. Список зарегистрированных COM-компонентов.png",alt:"Список зарегистрированных COM-компонентов",size:l.h2.MEDIUM}),(0,o.jsx)(a.xv,{p:!0,children:"Но и это еще не все! Иногда можно столкнуться с непонятными ошибками при регистрации компонентов. В качестве кардинального решения можно удалить все зарегистрированные компоненты, перезагрузить сервер и начать заново. В этом нам поможет новый скрипт!"}),(0,o.jsx)(a.xv,{p:!0,children:"Весь код здесь уже должен быть знаком по предыдущим скриптам. В реестре ищем зарегистрированные компоненты, а потом удаляем их нужным способом."}),(0,o.jsx)(s.Z,{code:'\n$allComObjects = [System.Collections.ArrayList]@()\n\n# Поиск COM-компонентов, зарегистрированных с помощью regsvr32.exe\nGet-ChildItem HKLM:\\Software\\Classes -ea 0 | \n    Where-Object { \n        $_.PSChildName -match \'^\\w+\\.\\w+$\' -and \n        (Get-ItemProperty "$($_.PSPath)\\CLSID" -ea 0)\n    } | ForEach-Object {\n        $COMName = $_.PSChildName    \n        $CLSIDProperty = Get-ItemProperty "$($_.PSPath)\\CLSID"    \n        $CLSID = $CLSIDProperty.\'(default)\' -replace \'{\', \'\' -replace \'}\', \'\'\n        \n        if($CLSID)\n        {\n            $itemCLSIDKey = "Registry::HKEY_CLASSES_ROOT\\CLSID\\{$CLSID}"\n            if(Test-Path -Path $itemCLSIDKey)\n            {\n                $ItemCLSID = Get-Item -Path $itemCLSIDKey\n                $procInfo = Get-ItemProperty "$($ItemCLSID.PSPath)\\InprocServer32" -ErrorAction SilentlyContinue\n                if($procInfo)\n                {\n                    $dllPath = $procInfo.\'(default)\'\n\n                    if($dllPath -like \'*comcntr.dll\')\n                    {\n                        $COMObjectInfo = [PSCustomObject]@{\n                            Name = $COMName\n                            CLSID = $CLSID\n                            DLLPath = $dllPath\n                            RegisteredBy = "regsvr32.exe"\n                        }\n\n                        $allComObjects.Add($COMObjectInfo) | Out-Null\n                    }\n                }\n            }\n        }\n    }\n\n# Поиск COM-компонентов, зарегистрированных с помощью службы компонентов\n$comAdmin = New-Object -com ("COMAdmin.COMAdminCatalog.1")\n$applications = $comAdmin.GetCollection("Applications") \n$applications.Populate() \nforeach ($application in $applications)\n{\n\n    $components = $applications.GetCollection("Components",$application.key)\n    $components.Populate()\n    foreach ($component in $components)\n    {\n        $dllName = $component.Value("DLL")\n        if($dllName -like "*comcntr.dll")\n        {\n            $COMName = $component.Name\n            $CLSID = $component.Key -replace "{", "" -replace "}", ""         \n\n            $COMObjectInfo = [PSCustomObject]@{\n                Name = $COMName\n                CLSID = $CLSID\n                DLLPath = $dllName\n                RegisteredBy = "comexp.msc"\n            }\n\n            $allComObjects.Add($COMObjectInfo) | Out-Null\n        }\n    }\n}\n\n$allComObjects | ForEach-Object {\n    if($_.RegisteredBy -eq "regsvr32.exe")    \n    {\n        $unregCommand = "regsvr32.exe /u ""$($_.DLLPath)""";\n        cmd /c "$unregCommand"\n        Write-Host "Регистрация компоненты ""$($_.Name)"" успешно отменена!" -ForegroundColor Red\n    } elseif($_.RegisteredBy -eq "comexp.msc")  \n    {\n        $comAdmin = New-Object -comobject COMAdmin.COMAdminCatalog\n        $Apps = $comAdmin.GetCollection("Applications")\n        $Apps.Populate();\n        $AppName = $_.Name -replace ".", "_";\n        $AppFoundedObject = $null\n        $AppFoundIndex = -1;\n        foreach ($App in $Apps ) {\n            $AppFoundIndex = $AppFoundIndex + 1;\n            if ($App.Name -eq $AppName ) {\n                $AppFoundedObject = $App;     \n                break;       \n            }\n        }\n        if($null -ne $AppFoundedObject)\n        {\n            $Apps.Remove($AppFoundIndex) | Out-Null;\n            $Apps.SaveChanges() | Out-Null;\n            Write-Host "$AppName removed" -ForegroundColor Red\n        }\n\n        Write-Host "Регистрация компоненты ""$($_.Name)"" успешно отменена!" -ForegroundColor Red\n    }\n}\n                ',className:"my-5",language:"powershell"}),(0,o.jsx)(a.xv,{p:!0,children:"Проще простого!"}),(0,o.jsx)(a.xv,{p:!0,children:"Теперь Вы можете массово регистрировать и удалять COM-компоненты платформы 1С разных версий, а также просто получать список всех зарегистрированных компонентов на сервере."}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Немного Outlook"}),(0,o.jsx)(a.xv,{p:!0,children:"Что мы все об 1С?! Давайте посмотрим на другие задачи. Например, работу с Microsoft Outlook. Этот замечательный почтовый клиент из пакета MS Office есть во многих компаниях. И частенько можно получить задачу по загрузке контактов и групп контактов в почтовый клиент из файлов или других источников."}),(0,o.jsx)(a.xv,{p:!0,children:"Ниже пример скрипта как загружать контакты и группы."}),(0,o.jsx)(a.xv,{p:!0,children:"В примере скрипта можно найти пример создания контактов и групп контактов с заполнением основных полей."}),(0,o.jsx)(s.Z,{code:'\n# Исходные данные контактов, которые могут быть получены любым доступным способом (API, загрузка из файла и т.д.)\n$contactsByGroup = @{}\n$department = "Тюмень"\n$contactListForGroup = New-Object System.Collections.Generic.List[System.Object];\n$contactsByGroup.Add($department, $contactListForGroup);\n$contactsByGroup[$department].Add(@{\n    innerPhone = "+79220000000"\n    fullName   = "Джон Генри"\n    email      = "john123@corp.ru"\n}); \n\n# Инициализация объекта приложения\n$outlook = new-object -com Outlook.Application -ea 1;\n# Текущая сессия рабоыт с приложением\n$outlookSession = $outlook.session;\n# Каталог контактов по умолчанию\n$contactsFolder = $outlookSession.GetDefaultFolder(10);\n\n$contactsByGroup.Keys | ForEach-Object {\n    $contactGroupName = $_;\n\n    # Выполняем поиск группы контактов. Если не смогли найти, то создаем.\n    # В этом случае группа контактов - это список рассылки. Также можно создавать группу контактов,\n    # вложенную непосредственно в группу. Тут кому как удобно.\n    $subfolerItem = $null\n    try\n    {\n        $subfolerItem = $contactsFolder.Items.Item($contactGroupName);\n        $subfolerItem.Delete();\n    } catch\n    {\n        # Действий не требуется\n    }\n\n    $dl = $contactsFolder.Items.Add("IPM.DistLIst");\n    $dl.DLName = $contactGroupName;\n    $dl.Save()  | Out-Null;\n    $subfolerItem = $contactsFolder.Items.Item($contactGroupName);\n\n    <#\n    # Это пример создания вложенной группы.\n    $subfolerItem = $null\n    try\n    {\n        $subfolerItem = $contactsFolder.Folders.Item($contactGroupName);\n        $subfolerItem.Delete();\n    } catch\n    {\n        # Действий не требуется\n    }\n    $dl = $contactsFolder.Folders.Add("IPM.DistLIst");\n    $dl.DLName = $contactGroupName;\n    $dl.Save() | Out-Null;\n    $subfolerItem = $contactsFolder.Folders.Item($contactGroupName);\n    #>\n\n    # Обходим контакты в кажой группе и создаем их. При этом в группу контактов (группу рассылки)\n    #  добавляем нужные данные контактов.\n    $contactsByGroup[$contactGroupName] | ForEach-Object {\n        Write-Host "Контакт $($_.email) ($contactGroupName)..."\n\n        $fullName = $_.fullName.Trim();  \n        $email = $_.email.Trim();     \n\n        # Если контакт уже существует, то удаляем его, чтобы создать заново.\n        @($contactsFolder.Items).\n            Where{ $_.MessageClass -eq "IPM.Contact" }.            \n            Where{ $_.Email1Address -eq $email } | \n            ForEach-Object {\n                $_.Delete();\n                Write-Host " УДАЛЕН!"\n            }      \n\n        Write-Host " Начало создания контакта..."\n        $newcontact = $contactsFolder.Items.Add()\n        $newcontact.Title = $fullName;\n        $newcontact.Email1Address = $_.email;\n        $newcontact.Email1DisplayName = "$fullName ($email)"\n        $newcontact.BusinessTelephoneNumber = $_.innerPhone;\n        $newcontact.Department = $contactGroupName;\n        $newcontact.Companies = "Моя компания"\n        $newcontact.FullName = $fullName;\n        # Заполняем другие свойства контакта в зависимости от задачи.\n        $newcontact.Save();\n        Write-Host " Контакт СОЗДАН!"\n        \n        # Создаем объект получаетеля для группы рассылки.\n        # Если создается группа контактов, то это действие не требуется.\n        # Получатель определяется по EMAIL, который передается в конструктор.\n        $recipientByContact = $outlookSession.CreateRecipient($email);\n        $recipientByContact.Resolve(); # Сопоставляем адрес с уже сущестующим контактом\n        # $recipientByContact.Resolved # Тут должно быть TRUE, чтобы контакт был добавлен в список рассылки\n        if($recipientByContact)\n        {\n            $subfolerItem.AddMember($recipientByContact);\n            $subfolerItem.Save() | Out-Null;\n        }\n    }    \n}\n                ',className:"my-5",language:"powershell"}),(0,o.jsxs)(a.xv,{p:!0,children:["Ничего сложного! ",":)"]}),(0,o.jsxs)(a.xv,{p:!0,children:["Да, это намного проще, чем регистрировать COM-компоненты 1С разных версий ",":)","."]}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Работаем с сервисами Yandex"}),(0,o.jsx)(a.xv,{p:!0,children:"У компании “Яндекс” множество полезных сервисов. С ними можно работать из bash, 1С и любых других языков и платформ, в том числе и из PowerShell."}),(0,o.jsx)(a.xv,{p:!0,children:"В скрипте ниже пример обращения к сервису перевода из Яндекс.Облака."}),(0,o.jsxs)(a.xv,{p:!0,children:["Для понимания происходящего в скрипте ниже рекомендую также ознакомиться с ",(0,o.jsx)("b",{children:(0,o.jsx)("u",{children:(0,o.jsx)(a.e9,{newTab:!0,href:"https://yandex.ru/dev/webmaster/doc/dg/concepts/About.html",children:"официальной документацией"})})}),", в которой можно найти ссылки на описание работы и с другими сервисами. Не только переводчиком. Тут можно прочитать ",(0,o.jsx)("b",{children:(0,o.jsx)("u",{children:(0,o.jsx)(a.e9,{newTab:!0,href:"/pages/blog/DevOps/2022-04/yandex-disk-and-bash.tsx",children:"про получение IAM-токенов"})})}),"."]}),(0,o.jsx)(s.Z,{code:"\n# Шаг 1. Убедиться, что платежный аккаунт находится в статусе ACTIVE или TRIAL_ACTIVE (https://console.cloud.yandex.ru/billing?section=accounts)\n\n# Шаг 2. Получите OAuth-токен в сервисе Яндекс.OAuth. Для этого перейдите по ссылке, нажмите Разрешить и скопируйте полученный OAuth-токен.\n$yandexPassportOauthToken = \"<OAuthТокен>\"\n\n# Шаг 3. Получаем IAM-токен (https://cloud.yandex.ru/docs/iam/operations/iam-token/create). \n# В примере ниже это будет выполняться через API, а не CLI.\n# Время жизни IAM-токена — не больше 12 часов, но рекомендуется запрашивать его чаще, например каждый час.\n$Body = @{ yandexPassportOauthToken = \"$yandexPassportOauthToken\" } | ConvertTo-Json -Compress\n$iamToken = Invoke-RestMethod -Method 'POST' -Uri 'https://iam.api.cloud.yandex.net/iam/v1/tokens' -Body $Body -ContentType 'Application/json' | Select-Object -ExpandProperty iamToken\n\n# Шаг 4. Получаем идентификатор облака. В примере берем только первый элемент.\n$cloudInfo = Invoke-RestMethod -Method 'GET' -Uri 'https://resource-manager.api.cloud.yandex.net/resource-manager/v1/clouds' -Headers @{Authorization = \"Bearer $iamToken\"} -Body $Body -ContentType 'Application/json'\n$cloudId = $cloudInfo.clouds[0].id\n\n# Шаг 5. Получаем идентификатор любого каталога, на который у аккаунта есть роль editor или выше.\n# Чтобы получить список каталогов с идентификаторами, воспользуйтесь методом list для ресурса Folder.\n$folderInfo = Invoke-RestMethod -Method 'GET' -Uri \"https://resource-manager.api.cloud.yandex.net/resource-manager/v1/folders?cloud_id=$cloudId\" -Headers @{Authorization = \"Bearer $iamToken\"} -Body $Body -ContentType 'Application/json'\n$folderId = $folderInfo.folders[0].id\n\n# Шаг 6. Переводим текст\n# Пошаговая инструкция https://cloud.yandex.ru/docs/translate/operations/translate\n# Официальная документация https://cloud.yandex.ru/docs/translate/?utm_source=console&utm_medium=empty-page&utm_campaign=translate\n$sourceLanguage = 'ru'; # Язык назначения\n$targetLanguage = 'en'; # Язык назначения\n$text = \"Привет из космоса!\", \"Все будет хорошо!\", \"1С великолепна!!!\"\n$postData = @{\n    sourceLanguageCode = $sourceLanguage\n    targetLanguageCode = $targetLanguage    \n    texts = $text\n    folderId = $folderId\n    glossaryConfig = @{\n        glossaryData = @{\n            glossaryPairs = @(\n                @{\n                    sourceText = \"1С великолепна\"\n                    translatedText = \".NET is awesome\"\n                }\n            )\n        }\n    }\n}\n$postDataAsJson = $postData | ConvertTo-Json -Depth 5\n$operationResult = Invoke-RestMethod -Method 'POST' -ContentType 'application/json; charset=UTF-8' -Uri 'https://translate.api.cloud.yandex.net/translate/v2/translate' -Headers @{Authorization = \"Bearer $iamToken\"} -Body $postDataAsJson # -OutFile \"D:\\Trash\\result.log\"\n$operationResult\n\nWrite-Host \"Результаты перевода текста.\"\n$operationResult.translations\n$operationResult.translations | ForEach-Object {\n    $_.text\n}\n                ",className:"my-5",language:"powershell"}),(0,o.jsx)(a.xv,{p:!0,children:"В примере для разнообразия также используем глоссарий. В результате этот текст:"}),(0,o.jsx)(s.Z,{code:'\n"Привет из космоса!"\n"Все будет хорошо!"\n"1С великолепна!!!"\n                ',className:"my-5",language:"text"}),(0,o.jsx)(a.xv,{p:!0,children:"Будет переведен вот в этот:"}),(0,o.jsx)(s.Z,{code:"\nРезультат перевода:\nGreetings From Outer Space!\nEverything will be fine!\n.NET is awesome!!!\n                ",className:"my-5",language:"text"}),(0,o.jsxs)(a.xv,{p:!0,children:["Профит! ",":)"]}),(0,o.jsx)(a.xv,{p:!0,children:"Используя этот пример можно обращаться и к другим сервисом Яндекса."}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Заблокирован ли файл?"}),(0,o.jsx)(a.xv,{p:!0,children:"Еще задачей может быть проверка заблокирован ли файл другим приложением."}),(0,o.jsx)(a.xv,{p:!0,children:"С помощью функции Test-FileLock можно проверить занят ли файл."}),(0,o.jsx)(s.Z,{code:'\nfunction Test-FileLock {\n    param (\n        [parameter(Mandatory = $true)][string]$Path,\n        [parameter(Mandatory = $false)][System.IO.FileAccess]$AccessType = [System.IO.FileAccess]::Read\n    )\n    $oFile = New-Object System.IO.FileInfo $Path\n  \n    if ((Test-Path -Path $Path) -eq $false) {\n        return $false\n    }\n  \n    try {\n        # [System.IO.FileAccess]::Read - проверяется возможность доступа к файлу только на чтение\n        # Если нужно проверить доступ на запись, то параметр можно заменить на [System.IO.FileAccess]::ReadWrite\n        $oStream = $oFile.Open([System.IO.FileMode]::Open, $AccessType, [System.IO.FileShare]::ReadWrite)\n  \n        if ($oStream) {\n            $oStream.Close()\n        }\n        return $false\n    }\n    catch {\n        # Файл заблокирован процессом\n        return $true\n    }\n}\n\n$testFile = "C:\\swapfile.sys"\n$fileLocked = Test-FileLock $testFile ([System.IO.FileAccess]::ReadWrite)\nif ($fileLocked -eq $true) {\n    Write-Host "Файл заблокирован другим приложением."\n}\n                ',className:"my-5",language:"powershell"}),(0,o.jsx)(a.xv,{p:!0,children:"Может быть полезно во многих случаях."}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Надежное копирование файлов"}),(0,o.jsxs)(a.xv,{p:!0,children:["Для надежного копирования файлов по сети можно использовать утилиты ",(0,o.jsx)("b",{children:(0,o.jsx)("u",{children:(0,o.jsx)(a.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows-server/administration/windows-commands/robocopy",children:"Robocopy"})})}),". Из PowerShell это выглядит так."]}),(0,o.jsx)(a.xv,{p:!0,children:"В официальной документации можно найти описание всех параметров."}),(0,o.jsx)(s.Z,{code:'\n$source="C:\\source"\n$dest="D:\\destination"\n\n$what = @("/COPYALL","/B","/SEC","/MIR")\n$options = @("/R:0","/W:0","/NFL","/NDL")\n\n$cmdArgs = @("$source","$dest",$what,$options)\nrobocopy @cmdArgs\n                ',className:"my-5",language:"powershell"}),(0,o.jsx)(a.xv,{p:!0,children:"Сценарии использования тоже очень разнообразные: от копирования бэкапов, то синхронизации каталогов между серверами."}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Сессии Windows"}),(0,o.jsx)(a.xv,{p:!0,children:"И под конец самый простой пример - получаем список сессий Windows и завершаем их по необходимости."}),(0,o.jsx)(a.xv,{p:!0,children:"Простые шаги."}),(0,o.jsx)(s.Z,{code:"\n# Список сессий Windows\n\nquery user\n\n# Завершение пользовательского сеанса Windows по ID\n\nlogoff <ID сессии>\n                ",className:"my-5",language:"bash"}),(0,o.jsxs)(a.xv,{p:!0,children:["Простое решение ",":)"]}),(0,o.jsx)(a.xv,{title:!0,className:"mt-10 md:text",children:"Хватит, пожалуй"}),(0,o.jsx)(a.xv,{p:!0,children:"Порция примеров работы с PowerShell закончена. Но кейсов использования этого прекрасного инструмента бесконечное количество. Все самое интересное можно найти в официальной документации, GitHub и на других просторах интернета."}),(0,o.jsx)(a.xv,{p:!0,children:"PowerShell еще вернется! Удачи в делах и хорошего настроения!"})]})},87855:function(e,n,t){"use strict";var o,a;t.d(n,{b:function(){return o}}),(a=o||(o={})).Min="350px",a.Standard="700px",a.Large="1000x",a.Unlimited=""},74313:function(e,n,t){"use strict";var o=t(37340),a=t(85893),s=t(67294),l=t(14965),r=t(41240),i=t(41686),c=t(87855);function p(){let e=(0,o._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return p=function(){return e},e}function $(){let e=(0,o._)(["\n        max-height: ","\n    "]);return $=function(){return e},e}n.Z=e=>{let{code:n,className:o,language:d,maxHeight:m=c.b.Standard}=e;(void 0!==t.g?t.g:window).Prism=l.p1,t(61354),t(79016),t(2731),t(35266),t(92927),t(51315),t(57874),t(86862);let u=null!=m?m:c.b.Standard,h=i.ZP.pre(p()),C=(0,i.ZP)(h)($(),u);return(0,a.jsx)("div",{className:(0,r.GF)("bg-blue-500 md:p-1 p-2",o),children:(0,a.jsx)("div",{className:"shadow-lg",children:(0,a.jsx)(l.y$,{theme:l.np.vsDark,code:n.trim(),language:null!=d?d:d="tsx",children:e=>{let{className:n,style:t,tokens:o,getLineProps:l,getTokenProps:r}=e;return(0,a.jsx)(C,{className:n,style:t,children:o.map((e,n)=>(0,s.createElement)("div",{...l({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,s.createElement)("span",{...r({token:e,key:n}),key:Math.random()}))))})}})})})}},44853:function(e,n,t){"use strict";t.d(n,{Ee:function(){return r},Xg:function(){return s},Y7:function(){return $},aV:function(){return c},e9:function(){return p},o_:function(){return d},tf:function(){return m},ty:function(){return i},xv:function(){return l}});var o=t(5152),a=t.n(o);let s=a()(()=>Promise.all([t.e(9686),t.e(4738),t.e(4838),t.e(1664),t.e(8765)]).then(t.bind(t,28765)),{loadableGenerated:{webpack:()=>[28765]}}),l=a()(()=>Promise.all([t.e(9511),t.e(935)]).then(t.bind(t,30935)),{loadableGenerated:{webpack:()=>[30935]}}),r=a()(()=>Promise.all([t.e(328),t.e(7651)]).then(t.bind(t,47651)),{loadableGenerated:{webpack:()=>[47651]}}),i=a()(()=>Promise.all([t.e(9686),t.e(6979)]).then(t.bind(t,16979)),{loadableGenerated:{webpack:()=>[16979]}}),c=a()(()=>Promise.all([t.e(4159),t.e(7355)]).then(t.bind(t,87355)),{loadableGenerated:{webpack:()=>[87355]}}),p=a()(()=>Promise.all([t.e(1664),t.e(3220)]).then(t.bind(t,53220)),{loadableGenerated:{webpack:()=>[53220]}});a()(()=>t.e(3140).then(t.bind(t,43140)),{loadableGenerated:{webpack:()=>[43140]}});let $=a()(()=>Promise.all([t.e(2004),t.e(736)]).then(t.bind(t,50736)),{loadableGenerated:{webpack:()=>[50736]}}),d=a()(()=>Promise.all([t.e(8331),t.e(8876),t.e(7354),t.e(839),t.e(5394),t.e(5533)]).then(t.bind(t,48641)),{loadableGenerated:{webpack:()=>[48641]}}),m=a()(()=>Promise.all([t.e(8331),t.e(1664),t.e(7354),t.e(839),t.e(8496)]).then(t.bind(t,48496)),{loadableGenerated:{webpack:()=>[48496]}})}},function(e){e.O(0,[4104,2888,9774,179],function(){return e(e.s=85543)}),_N_E=e.O()}]);