(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5706],{6030:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/DevOps/2021-05/amusing-powershell",function(){return s(2648)}])},2648:function(e,n,s){"use strict";s.r(n);var t=s(5893),r=s(9305);s(7294);var a=s(850),o=s(7105);n.default=()=>(0,t.jsxs)(r.Xg,{blogcentered:!0,children:[(0,t.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Оглавление"}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#what-and-why",children:"Что это и зачем"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#about-installation",children:"Немного об установке"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#instruments",children:"Инструментарий"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#tasks",children:"Спектр задач"})})})}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#install-and-configure-1C",children:"Установка и настройка 1С"})})}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#install-and-configure-1C-list",children:"Список установленных версий платформы"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#install-and-configure-1C-command",children:"Установка одной командой"})})})})]})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#manage-service",children:"Управление службой"})})}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#manage-service-list",children:"Список установленных служб с информацией"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#manage-service-action",children:"Запуск, остановка, перезапуск"})})})})]})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#com-component",children:"Старый, добрый COM"})})}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#com-component-check",children:"Проверка регистрации COM"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#com-component-reg",children:"Регистрация COM"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#com-component-unreg",children:"Отмена регистрации COM"})})})})]})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster",children:"Кластер под контролем"})})}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-info",children:"Информация о кластере"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-reg-run",children:"Регистрация и запуск консоли управления кластером"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-teminate-sessions",children:"Завершаем все сеансы"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-cleat-session-data",children:"Очистка сеансовых данных"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-block-infobases",children:"Блокировка всех информационных баз"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-data-size-check",children:"Контроль размера данных кластера"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-sessions-to-postgresql",children:"Сохраняем ифнормацию о сеансах в базу PostgreSQL"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#cluster-working-processes-to-postgresql",children:"Сохраняем ифнормацию о рабочих процессах в базу PostgreSQL"})})})})]})]}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#start-1c",children:"Запуск 1С"})})})}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#greate-sql-server",children:"Великий SQL Server"})})}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#greate-sql-server-dbatools",children:"Пример работы с модулем DBATools"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#greate-sql-server-shrink",children:"Пример создания сжатой тествой базы со скрытым shrink’ом"})})})})]})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#postgresql",children:"Совсем немного PostgreSQL"})})}),(0,t.jsx)(r.aV,{children:(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#postgresql",children:"Пример вызова psql"})})})})})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#api",children:"Вызов стороннего API"})})}),(0,t.jsx)(r.aV,{children:(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#api-zabbix",children:"Пример вызова API сервера Zabbix"})})})})})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#bot",children:"Собственный бот"})})}),(0,t.jsx)(r.aV,{children:(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#bot-telegram",children:"Отправка сообщений в Telegram"})})})})})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#email",children:"Отправка писем"})})}),(0,t.jsx)(r.aV,{children:(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#email-yandex",children:"Отправка электронной почты"})})})})})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#proc",children:"Контролируй процессы"})})}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#proc-list",children:"Список процессов"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#proc-kill",children:"Убить нельзя помиловать"})})})})]})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#port",children:"Проверка свободного порта"})})}),(0,t.jsx)(r.aV,{children:(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#port-free",children:"Свободный ли порт?"})})})})})]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#remote",children:"Удаленное управление"})})}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#remote-setup",children:"Простейший пример настройки"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#remote-use",children:"Как использовать"})})})})]})]}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#more",children:"Еще, еще, еще"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#nope",children:"Меньше костылей"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{href:"#theend",children:"В самом конце"})})})})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"what-and-why",title:!0,className:"mt-10 md:text",children:"Что это и зачем"}),(0,t.jsxs)(r.xv,{p:!0,children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/powershell/scripting/overview?view=powershell-7.3",children:"PowerShell"})})})," - это средство автоматизации от компании Microsoft с ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://github.com/PowerShell/PowerShell",children:"открытым исходным кодом"})})}),", которое поддерживается в Windows, Linux, MacOS и даже под ARM. Представляет из себя объектно-ориентированный программный движок и скриптовый язык с интерфейсом командной строки."]}),(0,t.jsx)(r.xv,{p:!0,children:"Обладает обширными возможностями и позволяет решать практически любые задачи администрирования. Благодаря тесной интеграции с платформой .NET позволяет использовать все ее возможности. А огромное сообщество гарантирует большое количество готовых скриптов и модулей на любой вкус, цвет, платформу и требования. Из-за всего этого имеет достаточно большую распространенность и сферу применения."}),(0,t.jsx)(r.xv,{p:!0,children:"Фактически, статья показывает как начать разработку скриптов на PowerShell, с каких материалов можно начать и дает примеры скриптов для старта."}),(0,t.jsx)(r.xv,{p:!0,children:"Упор был сделан на контекст платформы 1С (но есть информация и по SQL Server, PostgreSQL и общим вопросам администрирования), чтобы показать наличие уже готовых инструментов для решений администрирования и не уходить с головой в “около1Сные” скриптовые движки. Не мучайте администраторов, развивайтесь, коллеги! Становитесь частью экомистемы и команды, а не отдельным изолированным миром, тогда и наладяться отношения системных администраторов и разработчиков 1С."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"about-installation",title:!0,className:"mt-10 md:text",children:"Немного об установке"}),(0,t.jsxs)(r.xv,{p:!0,children:["Процесс установки PowerShell различается в зависимости от ОС, ее версии и т.д. Подробнее об установке и обновлении текущих версий рекомендую посмотреть ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/powershell/scripting/install/installing-powershell?view=powershell-7.3",children:"официальную документацию."})})})]}),(0,t.jsx)(r.xv,{p:!0,children:"Стоит отметить, что в операционной системе Windows есть встроенный движок “Windows PowerShell”, который уже немного отстает от актуальных версий. Иногда можно встретить путаницу между Windows PowerShell и актуальной версией PowerShell, которая выпускается уже в кроссплатформенном варианте. Все примеры скриптов ниже тестировались именно на Windows PowerShell, но все новые разработки и скрипты стараюсь делать на актуальных версиях PowerShell, что и Вам рекомендую."}),(0,t.jsx)(r.xv,{p:!0,children:"Подробно расписывать шаги установки смысла нет - посмотрите ссылку выше. Там подробная инструкция как для Windows, так и для Linux."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"instruments",title:!0,className:"mt-10 md:text",children:"Инструментарий"}),(0,t.jsxs)(r.xv,{p:!0,children:["Еще немного хотелось бы сказать об инструментах для работы с PowerShell. В составе Windows с древних времен идет среда разработки “Windows PowerShell ISE”, которой, конечно, можно пользоваться и сейчас. Но даже по внешнему виду можно понять, что она достаточно архаично выглядит, да и большинства удобств современных IDE там просто не найти. Поэтому лучший выбор - это использование ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://code.visualstudio.com/",children:"Visual Studio Code."})})})]}),(0,t.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/DevOps/2021-05/amusing-powershell/logo.png",alt:"Visual Studio Code",size:o.h2.MEDIUM}),(0,t.jsxs)(r.xv,{p:!0,children:["Достаточно установить расширение “PowerShell” и Вы получите отладку, удобный редактор с автоподсказками и многое другое. В статье ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/powershell/scripting/dev-cross-plat/vscode/using-vscode?view=powershell-7.3",children:"“Использование Visual Studio Code для разработки в PowerShell” "})})})," можно найти подробное описание что и как устанавливать, чтобы получить рабочую среду разработки. Также там есть описание дополнительных шагов настройки, которые в некоторых случаях могут понадобиться. Все вышесказанное актуально как для Windows, так и для Linux."]}),(0,t.jsxs)(r.xv,{p:!0,children:["Еще немного слов про терминал. Как известно, в Windows работа с терминалом всегда была не очень удобной. Но с появлением ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://apps.microsoft.com/store/detail/9N0DX20HK701?hl=ru-ru&gl=RU",children:"Windows Terminal"})})})," ситуация изменилась, хоть еще и есть куда стремиться. Теперь, как минимум, мы можем открывать несколько терминалов в одном окне и с разным типом. Вот, например, сразу один терминал PowerShell, два под Linux (через подсистему WSL) и один это старый добрый CMD."]}),(0,t.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/DevOps/2021-05/amusing-powershell/Windows Terminal.png",alt:"Windows Terminal",size:o.h2.MEDIUM}),(0,t.jsx)(r.xv,{p:!0,children:"Под Linux список инструментов для работы с терминалом намного больше и сами инструменты функциональней. Для себя использую простой терминал Gnome. Вот можете выбрать себе более подходящий."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"tasks",title:!0,className:"mt-10 md:text",children:"Спектр задач"}),(0,t.jsx)(r.xv,{p:!0,children:"И целой книги не хватит, чтобы описать и пройтись по всему спектру задач, которые решает PowerShell. Но мы и не собирались. Ниже приведено несколько скриптов, которые позволяют примерно понять что и зачем можно делать. Также они могут быть стартовой точкой для начала написания собственных скриптов или целых решений автоматизации."}),(0,t.jsx)(r.xv,{p:!0,children:"Это лишь примеры скриптов, не являющиеся готовым решением, поэтому они не оформляются в какой-либо отдельный модуль или пакет. Скорее всего в Вашей ситуации их придется дорабатывать."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"install-and-configure-1C",title:!0,className:"mt-10 md:text",children:"Установка и настройка 1С"}),(0,t.jsx)(r.xv,{p:!0,children:"Начнем с простого - списка установленных версий 1С и команда установки."}),(0,t.jsx)(r.xv,{id:"install-and-configure-1C-list",subtitle:!0,className:"mt-10 md:text",children:"Список установленных версий платформы"}),(0,t.jsx)(r.xv,{p:!0,children:"Из реестра Windows можно узнать список всех установленных версий 1С (32 и 64 битных)."}),(0,t.jsx)(a.Z,{code:"\n    $installedApps = New-Object System.Collections.ArrayList\n\n    Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |  \n    Where-Object {  ($_.DisplayName -like \"*1C:Предприятие*\") -or ($_.DisplayName -like \"*1C:Enterprise*\") } |\n    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation |\n    ForEach-Object {\n        $installedApps.Add(\n            [PSCustomObject] @{\n                'DisplayName' = $_.DisplayName\n                'DisplayVersion' = $_.DisplayVersion\n                'Publisher' = $_.Publisher\n                'InstallDate' = $_.InstallDate\n                'InstallLocation' = $_.InstallLocation\n            }\n        ) | Out-Null;\n    }\n\n    Get-ItemProperty HKLM:\\oftware\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall* | \n    Where-Object {  ($_.DisplayName -like \"*1C:Предприятие*\") -or ($_.DisplayName -like \"*1C:Enterprise*\") } |\n    Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation |\n    ForEach-Object {\n        $installedApps.Add(\n            [PSCustomObject] @{\n                'DisplayName' = $_.DisplayName\n                'DisplayVersion' = $_.DisplayVersion\n                'Publisher' = $_.Publisher\n                'InstallDate' = $_.InstallDate\n                'InstallLocation' = $_.InstallLocation\n            }\n        ) | Out-Null;\n    }\n\n    $installedApps | Format-Table –AutoSize\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(a.Z,{code:"\n    <# Пример вывода\n\n    DisplayName                             DisplayVersion Publisher InstallDate InstallLocation\n    -----------                             -------------- --------- ----------- ---------------\n    1C:Предприятие 8 (x86-64) (8.3.16.1063) 8.3.16.1063    1С-Софт   20200106    C:\\Program Files\\1cv8\\8.3.16.1063    1C:Предприятие 8 (8.3.12.1924)          8.3.12.1924    1С-Софт   20200224    C:\\Program Files (x86)\\1cv8\\8.3.12.1924    1C:Предприятие 8 (8.3.5.1517)           8.3.5.1517     1C        20200110    C:\\Program Files (x86)\\1cv8\\8.3.5.1517    1C:Предприятие 8 (8.3.6.2530)           8.3.6.2530     1C        20200221    C:\\Program Files (x86)\\1cv8\\8.3.6.2530    #>\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Теперь мы можем легко получить список установленных версий платформы 1С на хосте."}),(0,t.jsx)(r.xv,{id:"install-and-configure-1C-command",subtitle:!0,className:"mt-10 md:text",children:"Установка одной командой"}),(0,t.jsx)(r.xv,{p:!0,children:"Как известно, установщики приложений от 1С имеют возможность запуска с указанием параметров в командной строке. Воспользуемся этим."}),(0,t.jsx)(a.Z,{code:'\n    $installFilesDirectory = "C:\\Soft\\1C" # Каталог, где находится установочные файлы\n    Set-Location $installFilesDirectory;\n\n    $msiInstallerPath = "$installFilesDirectory\\1CEnterprise 8 (x86-64).msi"\n    $adminstallrelogonPath = "$installFilesDirectory\\adminstallrelogon.mst"\n    $lang1049Path = "$installFilesDirectory\\1049.mst"\n\n    $DESIGNERALLCLIENTS = 1\n    $THICKCLIENT=1\n    $THINCLIENTFILE=1\n    $THINCLIENT=1\n    $WEBSERVEREXT=0\n    $SERVER=0\n    $CONFREPOSSERVER=0\n    $CONVERTER77=0\n    $SERVERCLIENT=0\n    $LANGUAGES=\'RU\'\n\n    $params = \'/i\', \n            $msiInstallerPath,\n            # Сокращенный интерфейс. По сути, при установке пользователь увидит только бегущую полосу прогресса. Можно указать /qn и юзер вообще ничего при установке не увидит.\n            \'/qr\', \n            # Здесь мы подключаем рекомендованную фирмой 1С трансформацию adminstallrelogon.mst и пакет русского языка 1049.mst\n            "TRANSFORMS=$adminstallrelogonPath;$lang1049Path", \n            # Это основные компоненты 1С:Предприятия, включая компоненты для администрирования, конфигуратор и толстый клиент. Без этого параметра ставится всегда только тонкий клиент, независимо от следующего параметра\n            "DESIGNERALLCLIENTS=$DESIGNERALLCLIENTS",\n            "THICKCLIENT=$THICKCLIENT", # Толстый клиент\n            "THINCLIENTFILE=$THINCLIENTFILE", # Тонкий клиент, файловый вариант\n            "THINCLIENT=$THINCLIENT", # Тонкий клиент\n            "WEBSERVEREXT=$WEBSERVEREXT", # Модули расширения WEB-сервера\n            "SERVER=$SERVER", # Сервер 1С:Предприятия\n            "CONFREPOSSERVER=$CONFREPOSSERVER", # Сервер хранилища конфигураций\n            "CONVERTER77=$CONVERTER77", # Конвертер баз 1С:Предприятия 7.7\n            "SERVERCLIENT=$SERVERCLIENT", # Администрирование сервера\n            "LANGUAGES=$LANGUAGES" # Язык установки – русский.\n            $params\n    & msiexec.exe @params\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Примерно этот же способ используют для установки 1С на множестве компьютеров, только каталог с установщиком находится в сетевом каталоге. Но вариантов установки, конечно же, много."}),(0,t.jsx)(r.xv,{p:!0,children:"Проще простого, не так ли?"})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"manage-service",title:!0,className:"mt-10 md:text",children:"Управление службой"}),(0,t.jsx)(r.xv,{p:!0,children:"Частой задачей может быть перезапуск службы 1С или по крайней мере просмотр их списка."}),(0,t.jsx)(r.xv,{id:"manage-service-list",subtitle:!0,className:"mt-10 md:text",children:"Список установленных служб с информацией"}),(0,t.jsx)(r.xv,{p:!0,children:"Просто получим список установленных служб Windows, где файл приложения “ragent.exe”. Искать службу по имени не всегда надежно, ведь их могут зарегистрировать вручную под любым именем."}),(0,t.jsx)(a.Z,{code:"\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like '*'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like \"*ragent.exe*\" };\n\n$obj = [PSCustomObject] @{\n    data = @($services1C | % {\n        $serviceInfo = $_;\n        [PSCustomObject] @{\n            'Name' = $serviceInfo.Name\n            'DisplayName' = $serviceInfo.DisplayName\n            'PathName' = $serviceInfo.PathName\n            'State' = $serviceInfo.State\n        }\n    }) \n}\n\n$obj.data | Format-Table\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Теперь у нас есть список с именем службы, ее состоянием и командой запуска."}),(0,t.jsx)(r.xv,{id:"manage-service-action",subtitle:!0,className:"mt-10 md:text",children:"Запуск, остановка, перезапуск"}),(0,t.jsx)(r.xv,{p:!0,children:"И еще несколько примеров скриптов. Первый - это запуск остановленных служб 1С."}),(0,t.jsx)(a.Z,{code:'\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$obj = [PSCustomObject] @{\n    data = @($services1C | % {\n        $serviceInfo = $_;\n        \n        if($serviceInfo.State -eq \'Stopped\')\n        {\n            $serviceName = $serviceInfo.Name;\n            try\n            {\n                Start-Service $serviceName;\n                Write-Host "Запущена служба ""$serviceName""" -ForegroundColor Green\n            } catch\n            {\n                Write-Host "Ошибка при запуске службы ""$serviceName""" -ForegroundColor Red\n                Write-Host "Подробно:" -ForegroundColor Red\n                Write-Host $Error[0] -ForegroundColor Red\n            }\n        }        \n    }) \n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Далее остановка запущенных служб."}),(0,t.jsx)(a.Z,{code:'\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$obj = [PSCustomObject] @{\n    data = @($services1C | % {\n        $serviceInfo = $_;\n\n        if($serviceInfo.State -eq \'Running\')\n        {\n            $serviceName = $serviceInfo.Name;\n            try\n            {\n                Stop-Service $serviceName;\n                Write-Host "Остановлена служба ""$serviceName""" -ForegroundColor Green\n            } catch\n            {\n                Write-Host "Ошибка при остановке службы ""$serviceName""" -ForegroundColor Red\n                Write-Host "Подробно:" -ForegroundColor Red\n                Write-Host $Error[0] -ForegroundColor Red\n            }\n        }        \n    }) \n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"И, конечно же, перезапуск."}),(0,t.jsx)(a.Z,{code:'\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$obj = [PSCustomObject] @{\n    data = @($services1C | % {\n        $serviceInfo = $_;\n\n        if($serviceInfo.State -eq \'Running\')\n        {\n            $serviceName = $serviceInfo.Name;\n            try\n            {\n                Restart-Service $serviceName;\n                Write-Host "Перезапущена служба ""$serviceName""" -ForegroundColor Green\n            } catch\n            {\n                Write-Host "Ошибка при перезапуске службы ""$serviceName""" -ForegroundColor Red\n                Write-Host "Подробно:" -ForegroundColor Red\n                Write-Host $Error[0] -ForegroundColor Red\n            }\n        }        \n    }) \n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Ничего особого тут нет, ничего сложного."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"com-component",title:!0,className:"mt-10 md:text",children:"Старый, добрый COM"}),(0,t.jsx)(r.xv,{p:!0,children:"До сих пор с 1С во многих компаниях работа выполняется через COM, в том числе и с сервером 1С. Вот несколько команд в помощь для работы с COM."}),(0,t.jsx)(r.xv,{id:"com-component-check",subtitle:!0,className:"mt-10 md:text",children:"Проверка регистрации COM"}),(0,t.jsx)(r.xv,{p:!0,children:"Проверяем наличие зарегистрированных COM-объектов в системе для платформы 8.2 и 8.3."}),(0,t.jsx)(a.Z,{code:'\ntry {\n    $v83COMConnector = New-Object -COMObject "V83.COMConnector"\n    Write-Host "Компонента "V83.COMConnector" зарегистрирована и готова к использованию." -ForegroundColor Green;\n} \ncatch {\n    Write-Host "Компонента "V83.COMConnector" не зарегистрирована." -ForegroundColor Red;\n}\n\ntry {\n    $v82COMConnector = New-Object -COMObject "V82.COMConnector"\n    Write-Host "Компонента "V82.COMConnector" зарегистрирована и готова к использованию." -ForegroundColor Green;\n} \ncatch {\n    Write-Host "Компонента "V82.COMConnector" не зарегистрирована." -ForegroundColor Red;\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Проверяются только компоненты, зарегистрированные по стандартному имени."}),(0,t.jsx)(r.xv,{id:"com-component-reg",subtitle:!0,className:"mt-10 md:text",children:"Регистрация COM"}),(0,t.jsx)(r.xv,{p:!0,children:"Еще один скрипт - это регистрация COM-компоненты. Будьте осторожны, т.к. здесь выполняется регистрация для всех установленных служб 1С. Обычно она одна и поэтому будет зарегистрирована только одна компонента. Но мало ли что у Вас на сервере."}),(0,t.jsx)(a.Z,{code:'\n$allServices1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$allServices1C | % {\n\n    $services1C = $_;\n    $serviceExecPath = $services1C.PathName;\n    $serviceExecPathRagent = $services1C.PathName.split(\'"\')[1];\n    $serviceDirectory = [System.IO.Path]::GetDirectoryName($serviceExecPathRagent);\n    $comcntrPath = "$serviceDirectory\\comcntr.dll";\n    $regCommand = "regsvr32.exe ""$comcntrPath""";\n    $platformVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($serviceExecPathRagent).FileVersion\n\n    Write-Host "Начало регистрации COM-компоненты 1С:Предприятия";\n    Write-Host "Версия платформы: $platformVersion";\n    Write-Host "Путь к DLL: ""$comcntrPath""";\n    Write-Host "Команда регистрации компоненты: ""$regCommand""";\n\n    try\n    {\n        cmd /c "$regCommand"\n        Write-Host "Регистрация компоненты успешно выполнена!" -ForegroundColor Green\n    } catch\n    {\n        Write-Host "Ошибка при регистрации компоненты!" -ForegroundColor Red\n        Write-Host "Подробно:" -ForegroundColor Red\n        Write-Host $Error[0] -ForegroundColor Red\n    }\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Не забывайте запускать скрипт с правами администратора для успешной регистрации COM."}),(0,t.jsx)(r.xv,{id:"com-component-unreg",subtitle:!0,className:"mt-10 md:text",children:"Отмена регистрации COM"}),(0,t.jsx)(r.xv,{p:!0,children:"Аналогичная ситуация при отмене регистрации COM."}),(0,t.jsx)(a.Z,{code:'\n$allServices1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$allServices1C | % {\n\n    $services1C = $_;\n    $serviceExecPath = $services1C.PathName;\n    $serviceExecPathRagent = $services1C.PathName.split(\'"\')[1];\n    $serviceDirectory = [System.IO.Path]::GetDirectoryName($serviceExecPathRagent);\n    $comcntrPath = "$serviceDirectory\\comcntr.dll";\n    $regCommand = "regsvr32.exe /u ""$comcntrPath""";\n    $platformVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($serviceExecPathRagent).FileVersion\n\n    Write-Host "Начало отмены регистрации COM-компоненты 1С:Предприятия";\n    Write-Host "Версия платформы: $platformVersion";\n    Write-Host "Путь к DLL: ""$comcntrPath""";\n    Write-Host "Команда регистрации компоненты: ""$regCommand""";\n\n    try\n    {\n        cmd /c "$regCommand"\n        Write-Host "Отмена регистрации компоненты успешно выполнена!" -ForegroundColor Green\n    } catch\n    {\n        Write-Host "Ошибка при отмене регистрации компоненты!" -ForegroundColor Red\n        Write-Host "Подробно:" -ForegroundColor Red\n        Write-Host $Error[0] -ForegroundColor Red\n    }\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Также необходимы права администратора."}),(0,t.jsxs)(r.xv,{p:!0,children:["COM с нами еще надолго ",":)"]})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"cluster",title:!0,className:"mt-10 md:text",children:"Кластер под контролем"}),(0,t.jsx)(r.xv,{p:!0,children:"Еще немного о взаимодействии с кластером 1С."}),(0,t.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/DevOps/2021-05/amusing-powershell/Кластер под контролем.gif",alt:"Кластер под контролем",size:o.h2.MEDIUM}),(0,t.jsx)(r.xv,{id:"cluster-info",subtitle:!0,className:"mt-10 md:text",children:"Кластер под контролем"}),(0,t.jsx)(r.xv,{p:!0,children:"Получим немного информации о кластере 1С без COM, только по данным службы Windows."}),(0,t.jsx)(a.Z,{code:"\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like '*'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like \"*ragent.exe*\" };\n\n$obj = [PSCustomObject] @{\n    data = @($services1C | % {\n        $serviceInfo = $_\n        $serviceExecPath = $serviceInfo.PathName\n\n        $hash = [ordered]@{}\n        $serviceExecPath.Split(\"-\").Trim() | Where-Object { $_.Contains(\" \") } | ForEach-Object { \n            $name, $value = $_ -split '\\s+', 2\n            $hash[$name] = $value\n        }\n\n        $parsePathAgentExe = $serviceExecPath.Substring(1, $serviceExecPath.Length -1)\n        $parsePathAgentExe = $parsePathAgentExe.Substring(0, $parsePathAgentExe.IndexOf('\"'))\n\n        if(Test-Path $parsePathAgentExe)\n        {\n            $platformVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($parsePathAgentExe).FileVersion\n        } else\n        {\n            $platformVersion = \"\"\n        }\n        \n        $clusterPath = $hash.d -replace '\"', ''\n        $clusterRegPort = $hash.regport\n        $clusterPort = $hash.port\n        $clusterPortRange = $hash.range\n        $clusterRegPath = \"$clusterPath\\reg_$clusterRegPort\"\n\n        [PSCustomObject] @{\n            'Name' = $serviceInfo.Name\n            'DisplayName' = $serviceInfo.DisplayName            \n            'State' = $serviceInfo.State\n            'Version' = $platformVersion\n            'ClusterPath' = $clusterPath\n            'ClusterRegPort' = $clusterRegPort\n            'ClusterPort' = $clusterPort\n            'ClusterPortRange' = $clusterPortRange\n            'ClusterRegPath' = $clusterRegPath\n            'PathName' = $serviceInfo.PathName\n        }\n    }) \n}\n\n$obj.data | Format-Table\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Теперь мы можем получить имя службы, состояние, версию платформы, путь к каталогу кластера 1С, используемые порты и каталог кластера."}),(0,t.jsx)(r.xv,{id:"cluster-reg-run",subtitle:!0,className:"mt-10 md:text",children:"Регистрация и запуск консоли кластера"}),(0,t.jsx)(r.xv,{p:!0,children:"Бывает ли у Вас такое, что используется несколько версий 1С и необходимо запускать консоль администрирования серверов 1С разных версий? Этот скрипт должен помочь."}),(0,t.jsx)(a.Z,{code:'\n<#\nРегистрация и запуск консоли администрирования нужной версии платформы 1С\n#>\n\n$installedApps = New-Object System.Collections.ArrayList\nGet-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |  \nWhere-Object {  ($_.DisplayName -like "*1C:Предприятие*") -or ($_.DisplayName -like "*1C:Enterprise*") } |\nSelect-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation |\nForEach-Object {\n    $installedApps.Add(\n        [PSCustomObject] @{\n            \'DisplayName\' = $_.DisplayName\n            \'DisplayVersion\' = $_.DisplayVersion\n            \'Publisher\' = $_.Publisher\n            \'InstallDate\' = $_.InstallDate\n            \'InstallLocation\' = $_.InstallLocation\n        }\n    ) | Out-Null;\n}\nGet-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall* | \nWhere-Object {  ($_.DisplayName -like "*1C:Предприятие*") -or ($_.DisplayName -like "*1C:Enterprise*") } |\nSelect-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation |\nForEach-Object {\n    $installedApps.Add(\n        [PSCustomObject] @{\n            \'DisplayName\' = $_.DisplayName\n            \'DisplayVersion\' = $_.DisplayVersion\n            \'Publisher\' = $_.Publisher\n            \'InstallDate\' = $_.InstallDate\n            \'InstallLocation\' = $_.InstallLocation\n        }\n    ) | Out-Null;\n}\n\n$menu = @{}\nfor ($i=1;$i -le $installedApps.count; $i++) \n{ \n    Write-Host "$i. $($installedApps[$i-1].DisplayName) ($($installedApps[$i-1].InstallLocation))" \n    $menu.Add($i,($installedApps[$i-1]))\n}\n[int]$answer = Read-Host \'Выберите установленную платформу 1С\'\n$selection = $menu.Item($answer)\n\nif($null -ne $selection)\n{\n    $installLocation = $selection.InstallLocation\n    $redminPath = Join-Path -Path $installLocation -ChildPath "bin\\radmin.dll"\n    $1cv8Path = (get-item $installLocation).parent.FullName\n    $commonPath = Join-Path -Path $1cv8Path -ChildPath "common"    \n    $consolePath = ""    \n\n    $foundMscFiles = Get-Childitem –Path $commonPath | Where-Object { $_.Name -like "1CV8 Servers*.msc" }\n    \n    if($null -ne $foundMscFiles -and $foundMscFiles.Length -ge 0)\n    {\n        $consolePath = Join-Path -Path $commonPath -ChildPath $foundMscFiles[0].Name\n    } else\n    {\n        Write-Host "Не найдена оснастка консоли администрирования (1CV8 Servers*.msc) в каталоге: $commonPath" -BackgroundColor Red\n        return\n    }    \n\n    if(Test-Path $redminPath)\n    {\n        Write-Host "Начало регистрации компоненты radmin.dll" -BackgroundColor Blue\n        regsvr32 /s $redminPath\n        Write-Host "Успешно зарегистрирована компонента radmin.dll" -BackgroundColor Green\n\n        C:\\Windows\\System32\\mmc.exe $consolePath\n    } else\n    {\n        Write-Host "Не найдена компонент radmin.dll по пути: $redminPath" -BackgroundColor Red\n    }\n} else\n{\n    Write-Host "Выбрано некорректное значение." -BackgroundColor Red\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Для регистрации компонентов нужны права администратора. А куда без них…"}),(0,t.jsx)(r.xv,{id:"cluster-teminate-sessions",subtitle:!0,className:"mt-10 md:text",children:"Завершаем все сеансы"}),(0,t.jsx)(r.xv,{p:!0,children:"Пример скрипта, который завершит все сеансы 1С на сервере. Взаимодействие происходит через COM."}),(0,t.jsx)(a.Z,{code:'\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$services1C | % {\n    $serviceInfo = $_;\n    $serviceExecPath = $services1C.PathName;\n    $serviceExecPathRagent = $services1C.PathName.split(\'"\')[1]\n    \n    $hash = [ordered]@{}\n    $serviceExecPath.Split("-").Trim() | Where-Object { $_.Contains(" ") } | ForEach-Object { \n        $name, $value = $_ -split \'s+\', 2\n        $hash[$name] = $value\n    }\n\n    if([System.IO.File]::Exists($serviceExecPathRagent) -ne $true)\n    {        \n        break\n    }\n    \n    $platformVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($serviceExecPathRagent).FileVersion        \n    $clusterPath = $hash.d -replace \'"\', \'\'\n    $clusterRegPort = $hash.regport\n    $clusterPort = $hash.port\n    $clusterPortRange = $hash.range\n    $clusterRegPath = "$clusterPath\reg_$clusterRegPort"\n\n    $agentPort = $clusterPort;\n    $agentAddress = "localhost";\n    $clusterAdminName = ""; # Имя администратора кластера\n    $clusterAdminPassword = ""; # Пароль администратора кластера\n    $fullAgentAddress = "tcp://" + $agentAddress + ":" + $agentPort;\n\n    $COMConnector = $null;\n    try {\n        if($platformVersion -like "8.2.*")\n        {            \n            $COMConnector = New-Object -COMObject "V82.COMConnector"\n        }\n        if($platformVersion -like "8.3.*")\n        {\n            $COMConnector = New-Object -COMObject "V83.COMConnector"\n        }\n\n        if($null -ne $COMConnector) {\n            $serverAgent = $COMConnector.ConnectAgent($fullAgentAddress);\n            $clusterList = $ServerAgent.GetClusters();\n            foreach ($cluster in $clusterList) {\n                $serverAgent.Authenticate($Cluster, $clusterAdminName, $clusterAdminPassword)        \n\n                $serverSessionsData = $serverAgent.GetSessions($cluster);\n                $serverSessions = $serverSessionsData.Count;\n                $serverSessionsData | ForEach-Object {                \n                    $itemSession = $_;\n                    $serverAgent.TerminateSession($cluster, $itemSession)\n\n                    $userName = $itemSession.userName\n                    $sessionId = $itemSession.SessionID\n                    Write-Host "Завершен сеанс $sessionId. Пользователь: $userName" -ForegroundColor Green\n                }                \n            }\n        }\n\n        $COMConnector = $null\n    } \n    catch {\n        Write-Host "Ошибка при выполнении скрипта." -ForegroundColor Red;\n        Write-Host "Подробно:" -ForegroundColor Red\n        Write-Host $Error[0] -ForegroundColor Red\n    }\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsxs)(r.xv,{p:!0,children:["Будьте осторожны при запуске. Не сбросьте сеансы в рабочей базе в рабочее время ",":)"]}),(0,t.jsx)(r.xv,{id:"cluster-cleat-session-data",subtitle:!0,className:"mt-10 md:text",children:"Очистка сеансовых данных"}),(0,t.jsx)(r.xv,{p:!0,children:"Периодически приходится чистить каталог сеансовых данных, особенно если встречаются непонятные “глюки” в работе сервера 1С."}),(0,t.jsx)(a.Z,{code:'\n<#\nОчистка сеансовых данных 1С\n#>\n\n$services1C = Get-WmiObject win32_service | ? { $_.Name -like \'*\' } |\nSelect Name, DisplayName, State, PathName | \nWhere-Object { $_.PathName -Like "*ragent.exe*" };\n\n$services1C | % {\n    $serviceInfo = $_\n    $serviceName = $serviceInfo.Name\n\n    # 1. Останавливаем службу 1С\n    Write-Host "Stop service 1C: $serviceName" -BackgroundColor Blue\n    Stop-Service -Name $serviceName -NoWait\n    $svc = Get-Service $serviceName\n    Write-Host $svc.Status\n    $svc.WaitForStatus(\'Stopped\')\n    Write-Host $svc.Status\n    # Дополнительное ожидание для освобождения файлов процессами после остановки службы\n    Start-Sleep 15\n\n    # 2. Ищем путь к каталогу с сеансовыми данными\n    $serviceExecPath = $serviceInfo.PathName\n    $hash = [ordered]@{}\n    $serviceExecPath.Split("-").Trim() | Where-Object { $_.Contains(" ") } | ForEach-Object { \n        $name, $value = $_ -split \'\\s+\', 2\n        $hash[$name] = $value\n    }\n    $clusterPath = $hash.d -replace \'"\', \'\'\n    $clusterRegPort = $hash.regport\n    $clusterRegDirectory = Join-Path -Path $clusterPath -ChildPath "reg_$clusterRegPort"            \n    $storageSessionDataSizeMb = 0\n    Get-ChildItem $clusterRegDirectory | \n    Where-Object { $_.Name -like "snccntx*" } |\n    ForEach-Object {\n        $storageSessionDataPath = Join-Path -Path $clusterRegDirectory -ChildPath $_\n\n        # 3. Удаляем каталоги с сеансовыми данными\n        Write-Host "Remove session storage directory: $storageSessionDataPath" -BackgroundColor Blue\n        Remove-Item -LiteralPath $storageSessionDataPath -Force -Recurse\n    }\n\n    # 4. Запускаем службу 1С\n    Write-Host "Start service 1C: $serviceName" -BackgroundColor Blue\n    Start-Service -Name $serviceName\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"COM не нужен, но права администратора все равно нужны для остановки и запуска служб."}),(0,t.jsx)(r.xv,{id:"cluster-block-infobases",subtitle:!0,className:"mt-10 md:text",children:"Блокировка всех информационных баз"}),(0,t.jsx)(r.xv,{p:!0,children:"Еще один пример работы через COM - блокировка работы со всеми информационными базами."}),(0,t.jsx)(a.Z,{code:'\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$services1C | % {\n    $serviceInfo = $_;\n    $serviceExecPath = $services1C.PathName;\n    $serviceExecPathRagent = $services1C.PathName.split(\'"\')[1]\n\n    $hash = [ordered]@{}\n    $serviceExecPath.Split("-").Trim() | Where-Object { $_.Contains(" ") } | ForEach-Object { \n        $name, $value = $_ -split \'\\s+\', 2\n        $hash[$name] = $value\n    }\n\n    if([System.IO.File]::Exists($serviceExecPathRagent) -ne $true)\n    {        \n        break\n    }\n    \n    $platformVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($serviceExecPathRagent).FileVersion        \n    $clusterPath = $hash.d -replace \'"\', \'\'\n    $clusterRegPort = $hash.regport\n    $clusterPort = $hash.port\n    $clusterPortRange = $hash.range\n    $clusterRegPath = "$clusterPath\reg_$clusterRegPort"\n\n    $agentPort = $clusterPort;\n    $agentAddress = "localhost";\n    $clusterAdminName = ""; # Имя администратора кластера\n    $clusterAdminPassword = ""; # Пароль администратора кластера\n    $fullAgentAddress = "tcp://" + $agentAddress + ":" + $agentPort;\n\n    $COMConnector = $null;\n    try {\n        if($platformVersion -like "8.2.*")\n        {            \n            $COMConnector = New-Object -COMObject "V82.COMConnector"\n        }\n        if($platformVersion -like "8.3.*")\n        {\n            $COMConnector = New-Object -COMObject "V83.COMConnector"\n        }\n\n        if($null -ne $COMConnector) {\n            $serverAgent = $COMConnector.ConnectAgent($SrvAddr);\n            $clusterList = $ServerAgent.GetClusters();\n            foreach ($cluster in $clusterList) {\n                $serverAgent.Authenticate($Cluster, $clusterAdminName, $clusterAdminPassword)                   \n                \n                $workingProcesses = $serverAgent.GetWorkingProcesses($cluster)\n                foreach ($workProcess in $workingProcesses) {\n                    if($workProcess.Running -ne 1)\n                    {\n                        continue\n                    }\n\n                    $workProcessConnectionString = "tcp://"+$workProcess.HostName+":"+$workProcess.MainPort\n                    $workProcessConnection= $COMConnector.ConnectWorkingProcess($workProcessConnectionString)\n                    \n                    # Здесь должна быть аутентификация пользователя, имеющего доступ к информационной базе                    \n                    $infobaseUserName = ""                    \n                    $infobaseUserPassword = ""                    \n                    $workProcessConnection.AddAuthentication($infobaseUserName, $infobaseUserPassword)\n                    $infoBases = $workProcessConnection.GetInfoBases()\n                    $infoBases | ForEach-Object {                \n                        $itemInfobase = $_;                        \n                        # Установка запрета соединения с информационной базой\n                        $itemInfobase.ConnectDenied = $true\n                        $itemInfobase.DeniedMessage = "База недоступна. Ведутся регламентные работы. Отправьте SMS на номер 6666"\n                        $itemInfobase.PermissionCode = "123456"                      \n                        $itemInfobase.DeniedFrom = "2020-01-01 00:00:00"\n                        $itemInfobase.DeniedTo = "2020-12-31 23:59:59"\n                        # Блокировка регламентных заданий\n                        $itemInfobase.ScheduledJobsDenied = $true\n                        # Сохраняем измененные настройки\n                        $workProcessConnection.UpdateInfoBase($itemInfobase);\n                        \n                        $infobaseName = $itemInfobase.Name\n\n                        Write-Host "Установлена блокировка подключений к базе $infobaseName" -ForegroundColor Green\n                        Write-Host "Установлена блокировка регламентных заданий в базе $infobaseName" -ForegroundColor Green                        \n                    }\n                    \n                    break\n                }\n            }\n        }\n\n        $COMConnector = $null\n    } \n    catch {\n        Write-Host "Ошибка при выполнении скрипта." -ForegroundColor Red;\n        Write-Host "Подробно:" -ForegroundColor Red\n        Write-Host $Error[0] -ForegroundColor Red\n    }\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsxs)(r.xv,{p:!0,children:["Не забудьте отправить SMS на указанный номер в примере скрипта ",":)"]}),(0,t.jsx)(r.xv,{p:!0,children:"Ну а для снятия блокировки можно использовать следующий скрипт."}),(0,t.jsx)(a.Z,{code:'\n$services1C = Get-WmiObject win32_service | ?{$_.Name -like \'*\'} |\n    Select Name, DisplayName, State, PathName | \n    Where-Object { $_.PathName  -Like "*ragent.exe*" };\n\n$services1C | % {\n    $serviceInfo = $_;\n    $serviceExecPath = $services1C.PathName;\n    $serviceExecPathRagent = $services1C.PathName.split(\'"\')[1]\n    \n    $hash = [ordered]@{}\n    $serviceExecPath.Split("-").Trim() | Where-Object { $_.Contains(" ") } | ForEach-Object { \n        $name, $value = $_ -split \'\\s+\', 2\n        $hash[$name] = $value\n    }\n\n    if([System.IO.File]::Exists($serviceExecPathRagent) -ne $true)\n    {        \n        break\n    }\n    \n    $platformVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($serviceExecPathRagent).FileVersion        \n    $clusterPath = $hash.d -replace \'"\', \'\'\n    $clusterRegPort = $hash.regport\n    $clusterPort = $hash.port\n    $clusterPortRange = $hash.range\n    $clusterRegPath = "$clusterPath\reg_$clusterRegPort"\n\n    $agentPort = $clusterPort;\n    $agentAddress = "localhost";\n    $clusterAdminName = ""; # Имя администратора кластера\n    $clusterAdminPassword = ""; # Пароль администратора кластера\n    $fullAgentAddress = "tcp://" + $agentAddress + ":" + $agentPort;\n\n    $COMConnector = $null;\n    try {\n        if($platformVersion -like "8.2.*")\n        {            \n            $COMConnector = New-Object -COMObject "V82.COMConnector"\n        }\n        if($platformVersion -like "8.3.*")\n        {\n            $COMConnector = New-Object -COMObject "V83.COMConnector"\n        }\n\n        if($null -ne $COMConnector) {\n            $serverAgent = $COMConnector.ConnectAgent($SrvAddr);\n            $clusterList = $ServerAgent.GetClusters();\n            foreach ($cluster in $clusterList) {\n                $serverAgent.Authenticate($Cluster, $clusterAdminName, $clusterAdminPassword)                   \n                \n                $workingProcesses = $serverAgent.GetWorkingProcesses($cluster)\n                foreach ($workProcess in $workingProcesses) {\n                    if($workProcess.Running -ne 1)\n                    {\n                        continue\n                    }\n\n                    $workProcessConnectionString = "tcp://"+$workProcess.HostName+":"+$workProcess.MainPort\n                    $workProcessConnection= $COMConnector.ConnectWorkingProcess($workProcessConnectionString)\n                    \n                    # Здесь должна быть аутентификация пользователя, имеющего доступ к информационной базе                    \n                    $infobaseUserName = ""                    \n                    $infobaseUserPassword = ""                    \n                    $workProcessConnection.AddAuthentication($infobaseUserName, $infobaseUserPassword)\n                    $infoBases = $workProcessConnection.GetInfoBases()\n                    $infoBases | ForEach-Object {                \n                        $itemInfobase = $_;                        \n                        # Снятие запрета соединения с информационной базой\n                        $itemInfobase.ConnectDenied = $false\n                        # Снятие блокировки регламентных заданий\n                        $itemInfobase.ScheduledJobsDenied = $false\n                        # Сохраняем измененные настройки\n                        $workProcessConnection.UpdateInfoBase($itemInfobase);\n                        \n                        $infobaseName = $itemInfobase.Name\n\n                        Write-Host "Снята блокировка подключений к базе $infobaseName" -ForegroundColor Green\n                        Write-Host "Снята блокировка регламентных заданий в базе $infobaseName" -ForegroundColor Green                        \n                    }\n                    \n                    break\n                }\n            }\n        }\n\n        $COMConnector = $null\n    } \n    catch {\n        Write-Host "Ошибка при выполнении скрипта." -ForegroundColor Red;\n        Write-Host "Подробно:" -ForegroundColor Red\n        Write-Host $Error[0] -ForegroundColor Red\n    }\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Профит!"}),(0,t.jsx)(r.xv,{id:"cluster-data-size-check",subtitle:!0,className:"mt-10 md:text",children:"Контроль размера данных кластера"}),(0,t.jsx)(r.xv,{p:!0,children:"Еще один простой скрипт для получения размера сеансовых данных сервера 1С."}),(0,t.jsx)(a.Z,{code:"\n<#\nПолучение информации о размере каталога кластера 1С и каталога сеансовых данных\n#>\n\nfunction Get-Size {\n    param([string]$pth)\n    ((gci -path $pth -recurse | measure-object -property length -sum).sum / 1mb)\n}\n\n$services1C = Get-WmiObject win32_service | ? { $_.Name -like '*' } |\nSelect Name, DisplayName, State, PathName | \nWhere-Object { $_.PathName -Like \"*ragent.exe*\" };\n\n$obj = [PSCustomObject] @{\n    data = @($services1C | % {\n            $serviceInfo = $_\n            $serviceExecPath = $serviceInfo.PathName\n\n            $hash = [ordered]@{}\n            $serviceExecPath.Split(\"-\").Trim() | Where-Object { $_.Contains(\" \") } | ForEach-Object { \n                $name, $value = $_ -split '\\s+', 2\n                $hash[$name] = $value\n            }\n\n            $clusterPath = $hash.d -replace '\"', ''\n\n            $clusterDataSize = 0\n            if (Test-Path $clusterPath) {\n                $clusterDataSize = Get-Size $clusterPath\n            }\n\n            $clusterRegPort = $hash.regport\n            $clusterRegDirectory = Join-Path -Path $clusterPath -ChildPath \"reg_$clusterRegPort\"\n            \n            $storageSessionDataSizeMb = 0\n            Get-ChildItem $clusterRegDirectory | \n            Where-Object { $_.Name -like \"snccntx*\" } |\n            ForEach-Object {\n                $storageSessionDataPath = Join-Path -Path $clusterRegDirectory -ChildPath $_\n                $folderSize = Get-Size $storageSessionDataPath\n                $storageSessionDataSizeMb = $storageSessionDataSizeMb + $folderSize\n            }\n\n            [PSCustomObject] @{\n                'Name'              = $serviceInfo.Name\n                'DisplayName'       = $serviceInfo.DisplayName        \n                'ClusterPath'       = $clusterPath\n                'ClusterFolderSizeMb' = $clusterDataSize\n                'SessionStorageSizeMb' = $storageSessionDataSizeMb\n            }\n        }) \n}\n\n$obj.data | Format-Table\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Может пригодиться для отслеживания работы сервера."}),(0,t.jsx)(r.xv,{id:"cluster-sessions-to-postgresql",subtitle:!0,className:"mt-10 md:text",children:"Сохраняем информацию о сеансах в базу PostgreSQL"}),(0,t.jsx)(r.xv,{p:!0,children:"Многие системы мониторинга сохраняют информацию о сеансах. Следующие скрипты делают это, отправляя данные в базы данных PostgreSQL. Этот для сеансов."}),(0,t.jsx)(a.Z,{code:'\n<#\nПеред работой скрипта сохранения информации о сеансах 1С необходимо создать базу данных PostgreSQL\nс соответствующей таблицей и индексом.\n\nCREATE TABLE public.sessions1c (\n	servername varchar(25) NOT NULL,\n	infobase varchar(25) NOT NULL,\n	sessionid int8 NULL,\n	started_at timestamp(0) NULL,\n	last_active_at timestamp(0) NULL,\n	host varchar(25) NULL,\n	appid varchar(25) NULL,\n	username varchar(50) NULL,\n	work_process_id int8 NULL,\n	connectionid int8 NULL,\n	"period" timestamp(0) NOT NULL,\n	db_proc_info int8 NULL,\n	db_proc_took_at timestamp(0) NULL,\n	db_proc_took int8 NULL,\n	blocked_by_dbms int8 NULL,\n	blocked_by_ls int8 NULL,\n	duration_current_dbms int8 NULL,\n	duration_last_5_min_dbms int8 NULL,\n	duration_all_dbms int8 NULL,\n	dbms_bytes_last_5_min int8 NULL,\n	dbms_bytes_all int8 NULL,\n	duration_current int8 NULL,\n	duration_last_5_min int8 NULL,\n	duration_all int8 NULL,\n	calls_last_5_min int8 NULL,\n	calls_all int8 NULL,\n	bytes_last_5_min int8 NULL,\n	bytes_all int8 NULL\n);\nCREATE INDEX sessions1c_period_idx ON public.sessions1c ("period" timestamp_ops,servername text_ops,infobase text_ops);\n\nТакже нужно установить ODBC-драйвер для работы с PostgreSQL: https://odbc.postgresql.org/\n#>\n\n# Настройки сервера PostgreSQL\n$DBIP = "127.0.0.1" # Адрес сервера PostgreSQL\n$DBPort = 5432 # Порт сервера PostgreSQL\n$DBName = "MyDatabase" # База данных для сохранения информации\n$DBUser = "MyUser" # Пользователь PostgreSQL\n$DBPass = "MyPassword" # Пароль пользователь PostgreSQL\n$DBConnectionString = "Driver={PostgreSQL UNICODE};Server=$DBIP;Port=$DBPort;Database=$DBName;Uid=$DBUser;Pwd=$DBPass;"\n\n# Настройки сервера 1С\n$server1CSettings = @()\n# Добавляем настройки сервера 1С для сбора данных.\n# Аналогично можно добавить сколько угодно серверов\n$server1CSettings += New-Object PSCustomObject -Property @{\n    agentPort = 1540 # Порт сервера 1С\n    agentAddress = "my.server.1c.ru" # Адрес сервера 1С\n    clusterAdminName = "" # Имя администратора кластера (пустой, если его нет)\n    clusterAdminPassword = "" # Пароль администратора кластера (пустой, если его нет)\n} # Сервер 1С для сбора данных\n\n# Получаем информацию о сеансах для каждого сервера\n$server1CSettings | ForEach-Object {  \n\n    $COMConnector = $null\n    try {\n        $COMConnector = New-Object -COMObject "V83.COMConnector"\n        # Для 8.2\n        #$COMConnector = New-Object -COMObject "V82.COMConnector"\n        Write-Host "Компонента "COMConnector" зарегистрирована и готова к использованию." -ForegroundColor Green;\n    } \n    catch {\n        Write-Host "Компонента "V82.COMConnector" не зарегистрирована." -ForegroundColor Red;\n    }\n    $DBConn = $null\n    try {\n        $DBConn = New-Object System.Data.Odbc.OdbcConnection\n        $DBConn.ConnectionString = $DBConnectionString\n        $DBConn.Open();\n        Write-Host "Установлено соединение с базой данных мониторинга." -ForegroundColor Green;\n    }\n    catch {\n        Write-Host "Не удалось установить соединение с базой данных мониторинга." -ForegroundColor Red;\n        $DBConn = $null\n    }\n\n    $agentAddress = $_.agentAddress\n    $agentPort = $_.agentPort\n    $clusterAdminName = $_.clusterAdminName\n    $clusterAdminPassword = $_.clusterAdminPassword\n    $fullAgentAddress = "tcp://" + $agentAddress + ":" + $agentPort;\n\n    $fullAgentAddress\n\n    try {\n        if($null -ne $COMConnector -and $null -ne $DBConn) {\n            $serverAgent = $COMConnector.ConnectAgent($fullAgentAddress);\n            $clusterList = $ServerAgent.GetClusters();\n            foreach ($cluster in $clusterList) {\n                $serverAgent.Authenticate($Cluster, $clusterAdminName, $clusterAdminPassword)        \n\n                $period = Get-Date\n                $serverSessionsData = $serverAgent.GetSessions($cluster);\n\n                $serverSessionsData | ForEach-Object {                \n                    $itemSession = $_;\n\n                    $DBCmd = $DBConn.CreateCommand()\n                    $DBCmd.Connection = $DBConn\n                    $insertQuery = \n@"\n        INSERT INTO sessions1c\n        (\n            period,\n            servername,\n            infobase,\n            sessionid,\n            started_at,\n            last_active_at,\n            host,\n            appid,\n            username,\n            work_process_id,\n            connectionid,\n            db_proc_info,\n            db_proc_took_at,\n            db_proc_took,\n            blocked_by_dbms,\n            blocked_by_ls,\n            duration_current_dbms,\n            duration_last_5_min_dbms,\n            duration_all_dbms,\n            dbms_bytes_last_5_min,\n            dbms_bytes_all,\n            duration_current,\n            duration_last_5_min,\n            duration_all,\n            calls_last_5_min,\n            calls_all,\n            bytes_last_5_min,\n            bytes_all\n        )\n        VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\n"@\n                    $DBCmd.CommandText = $insertQuery\n\n                    [void]$DBCmd.Parameters.Add("@period", [System.Data.Odbc.OdbcType]::varchar, 26)\n                    [void]$DBCmd.Parameters.Add("@servername", [System.Data.Odbc.OdbcType]::varchar, 25)\n                    [void]$DBCmd.Parameters.Add("@infobase", [System.Data.Odbc.OdbcType]::varchar, 25)\n                    [void]$DBCmd.Parameters.Add("@sessionid", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@started_at", [System.Data.Odbc.OdbcType]::varchar, 26)\n                    [void]$DBCmd.Parameters.Add("@last_active_at", [System.Data.Odbc.OdbcType]::varchar, 26)\n                    [void]$DBCmd.Parameters.Add("@host", [System.Data.Odbc.OdbcType]::varchar, 25)\n                    [void]$DBCmd.Parameters.Add("@appid", [System.Data.Odbc.OdbcType]::varchar, 25)\n                    [void]$DBCmd.Parameters.Add("@username", [System.Data.Odbc.OdbcType]::varchar, 50)\n                    [void]$DBCmd.Parameters.Add("@work_process_id", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@connectionid", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@db_proc_info", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@db_proc_took_at", [System.Data.Odbc.OdbcType]::varchar, 26)\n                    [void]$DBCmd.Parameters.Add("@db_proc_took", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@blocked_by_dbms", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@blocked_by_ls", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@duration_current_dbms", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@duration_last_5_min_dbms", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@duration_all_dbms", [System.Data.Odbc.OdbcType]::Int)\n                    [void]$DBCmd.Parameters.Add("@dbms_bytes_last_5_min", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@dbms_bytes_all", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@duration_current", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@duration_last_5_min", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@duration_all", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@calls_last_5_min", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@calls_all", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@bytes_last_5_min", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@bytes_all", [System.Data.Odbc.OdbcType]::BigInt)\n                    \n                    # Дата получения информации о сеансах\n                    $DBCmd.Parameters["@period"].Value = $period.ToString("yyyy-MM-dd HH:mm:ss")\n                    # Имя сервера 1С\n                    $DBCmd.Parameters["@servername"].Value = $agentAddress\n                    # Содержит описание информационной базы, с которой установлен сеанс.\n                    if($itemSession.infoBase -ne $null)\n                    {\n                        $DBCmd.Parameters["@infobase"].Value = $itemSession.infoBase.Name                                             \n                    } else\n                    {\n                        $DBCmd.Parameters["@infobase"].Value = ""\n                    }\n                    # Содержит номер сеанса. Целое число, уникальное среди всех сеансов данной информационной базы.\n                    $DBCmd.Parameters["@sessionid"].Value = $itemSession.SessionID   \n                    # Дата/ время начала сеанса.\n                    $DBCmd.Parameters["@started_at"].Value = $itemSession.StartedAt.ToString("yyyy-MM-dd HH:mm:ss")\n                    # Дата/ время последней активности сеанса.\n                    $DBCmd.Parameters["@last_active_at"].Value = $itemSession.LastActiveAt.ToString("yyyy-MM-dd HH:mm:ss")\n                    # Содержит имя или адрес компьютера, установившего сеанс.\n                    $DBCmd.Parameters["@host"].Value = $itemSession.Host\n                    # Содержит идентификатор приложения, установившего сеанс.\n                    $DBCmd.Parameters["@appid"].Value = $itemSession.AppID\n                    # Содержит имя аутентифицированного пользователя информационной базы.\n                    $DBCmd.Parameters["@username"].Value = $itemSession.userName \n                    # Идентификатор активного рабочего процесса в терминах операционной системы.               \n                    if($null -ne $itemSession.process)\n                    {\n                        $DBCmd.Parameters["@work_process_id"].Value = $itemSession.process.PID\n                    } else\n                    {\n                        $DBCmd.Parameters["@work_process_id"].Value = 0\n                    }\n                    # Содержит идентификатор соединения. Позволяет различить разные соединения, \n                    # установленные одним и тем же приложением с одного и того же клиентского компьютера.\n                    if($null -ne $itemSession.connection)\n                    {\n                        $DBCmd.Parameters["@connectionid"].Value = $itemSession.connection.ConnID\n                    } else\n                    {\n                        $DBCmd.Parameters["@connectionid"].Value = 0\n                    }              \n                    # Содержит номер соединения с СУБД в терминах СУБД в том случае, если в момент получения списка выполняется запрос к СУБД, \n                    # открыта транзакция или определены временные таблицы (это означает, что захвачено соединение с СУБД). \n                    try {\n                        $DBCmd.Parameters["@db_proc_info"].Value = [int]$itemSession.dbProcInfo\n                    }\n                    catch {\n                        $DBCmd.Parameters["@db_proc_info"].Value = 0\n                    }                \n                    # Содержит момент времени, когда соединение с СУБД было захвачено данным сеансом последний раз.\n                    $DBCmd.Parameters["@db_proc_took_at"].Value = $itemSession.dbProcTookAt.ToString("yyyy-MM-dd HH:mm:ss")\n                    # Содержит время соединение с СУБД с момента захвата в миллисекундах.\n                    $DBCmd.Parameters["@db_proc_took"].Value = $itemSession.dbProcTook                \n                    # Содержит номер сеанса, который является причиной ожидания транзакционной блокировки\n                    $DBCmd.Parameters["@blocked_by_dbms"].Value = $itemSession.blockedByDBMS\n                    # Содержит номер сеанса, который является причиной ожидания управляемой транзакционной блокировки\n                    $DBCmd.Parameters["@blocked_by_ls"].Value = $itemSession.blockedByLS\n                    # Содержит интервал времени в миллисекундах, прошедший с момента начала выполнения запроса, в случае, если сеанс выполняет запрос к СУБД.\n                    $DBCmd.Parameters["@duration_current_dbms"].Value = $itemSession.durationCurrentDBMS\n                    # Содержит суммарное время исполнения запросов к СУБД от имени данного сеанса за последние 5 минут, в миллисекундах.\n                    $DBCmd.Parameters["@duration_last_5_min_dbms"].Value = $itemSession.durationLast5MinDBMS\n                    # Содержит суммарное время исполнения запросов к СУБД от имени данного сеанса с момента начала сеанса, в миллисекундах.\n                    $DBCmd.Parameters["@duration_all_dbms"].Value = $itemSession.durationAllDBMS\n                    # Содержит количество данных, переданных и полученных от СУБД от имени данного сеанса за последние 5 минут, в байтах.\n                    $DBCmd.Parameters["@dbms_bytes_last_5_min"].Value = $itemSession.dbmsBytesLast5Min\n                    # Содержит количество данных, переданных и полученных от СУБД от имени данного сеанса с момента начала сеанса, в байтах.\n                    $DBCmd.Parameters["@dbms_bytes_all"].Value = $itemSession.dbmsBytesAll\n                    # Содержит интервал времени в миллисекундах, прошедший с момента начала обращения, в случае, если сеанс выполняет обращение к серверу 1С:Предприятия.\n                    $DBCmd.Parameters["@duration_current"].Value = $itemSession.durationCurrent\n                    # Содержит время исполнения вызовов сервера 1С:Предприятия от имени данного сеанса за последние 5 минут, в миллисекундах.\n                    $DBCmd.Parameters["@duration_last_5_min"].Value = $itemSession.durationLast5Min\n                    # Содержит время исполнения вызовов сервера 1С:Предприятия от имени данного сеанса с момента начала сеанса, в секундах.\n                    $DBCmd.Parameters["@duration_all"].Value = $itemSession.durationAll\n                    # Содержит количество вызовов сервера 1С:Предприятия от имени данного сеанса за последние 5 минут.\n                    $DBCmd.Parameters["@calls_last_5_min"].Value = $itemSession.callsLast5Min\n                    # Содержит количество вызовов сервера 1С:Предприятия от имени данного сеанса с момента начала сеанса.\n                    $DBCmd.Parameters["@calls_all"].Value = $itemSession.callsAll\n                    # Содержит объем данных, переданных между сервером 1С:Предприятия и клиентским приложением данного сеанса за последние 5 минут, в байтах.\n                    $DBCmd.Parameters["@bytes_last_5_min"].Value = $itemSession.bytesLast5Min\n                    # Содержит объем данных, переданных между сервером 1С:Предприятия и клиентским приложением данного сеанса с момента начала сеанса, в байтах.\n                    $DBCmd.Parameters["@bytes_all"].Value = $itemSession.bytesAll               \n                \n                    [void]$DBCmd.ExecuteNonQuery()\n                }                            \n            }\n        }\n\n        $COMConnector = $null\n        $DBConn = $null\n    } \n    catch {\n        Write-Host "Ошибка при выполнении скрипта." -ForegroundColor Red;\n        Write-Host "Подробно:" -ForegroundColor Red\n        Write-Host $Error[0] -ForegroundColor Red\n    }\n\n    $COMConnector = $null\n    $DBConn = $null\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Внутри скрипта также команды для создания базы данных."}),(0,t.jsx)(r.xv,{id:"cluster-working-processes-to-postgresql",subtitle:!0,className:"mt-10 md:text",children:"Сохраняем информацию о рабочих процессах в базу PostgreSQL"}),(0,t.jsx)(r.xv,{p:!0,children:"А это скрипт для рабочих процессов."}),(0,t.jsx)(a.Z,{code:'\n<#\nПеред работой скрипта сохранения информации о рабочих процессах 1С необходимо создать базу данных PostgreSQL\nс соответствующей таблицей и индексом.\n\nCREATE TABLE public.work_processes1c (\n	hostname varchar(25) NOT NULL,\n	main_port int8 NOT NULL,\n	sync_port int8 NOT NULL,\n	"enable" bool NOT NULL,\n	running int8 NOT NULL,\n	connections int8 NOT NULL,\n	started_at timestamp(0) NOT NULL,\n	avg_call_time float8 NOT NULL,\n	avg_server_call_time float8 NOT NULL,\n	avg_db_call_time float8 NOT NULL,\n	avg_back_call_time float8 NOT NULL,\n	avg_lock_call_time float8 NOT NULL,\n	selection_size int8 NOT NULL,\n	avg_threads float8 NOT NULL,\n	capacity int8 NOT NULL,\n	memory_size int8 NOT NULL,\n	memory_excess_time int8 NOT NULL,\n	available_perfomance int8 NOT NULL,\n	pid int8 NOT NULL,\n	use int8 NOT NULL,\n	is_enable bool NOT NULL,\n	"period" timestamp(0) NOT NULL,\n	servername varchar(25) NOT NULL\n);\nCREATE INDEX work_processes1c_period_idx ON public.work_processes1c USING btree (period, servername, hostname);\n\nТакже нужно установить ODBC-драйвер для работы с PostgreSQL: https://odbc.postgresql.org/\n#>\n\n# Настройки сервера PostgreSQL\n$DBIP = "127.0.0.1" # Адрес сервера PostgreSQL\n$DBPort = 5432 # Порт сервера PostgreSQL\n$DBName = "MyDatabase" # База данных для сохранения информации\n$DBUser = "MyUser" # Пользователь PostgreSQL\n$DBPass = "MyPassword" # Пароль пользователь PostgreSQL\n$DBConnectionString = "Driver={PostgreSQL UNICODE};Server=$DBIP;Port=$DBPort;Database=$DBName;Uid=$DBUser;Pwd=$DBPass;"\n\n# Настройки сервера 1С\n$server1CSettings = @()\n# Добавляем настройки сервера 1С для сбора данных.\n# Аналогично можно добавить сколько угодно серверов\n$server1CSettings += New-Object PSCustomObject -Property @{\n    agentPort = 1540 # Порт сервера 1С\n    agentAddress = "my.server.1c.ru" # Адрес сервера 1С\n    clusterAdminName = "" # Имя администратора кластера (пустой, если его нет)\n    clusterAdminPassword = "" # Пароль администратора кластера (пустой, если его нет)\n} # Сервер 1С для сбора данных\n\n# Получаем информацию о рабочих процессах для каждого сервера\n$server1CSettings | ForEach-Object {  \n\n    $COMConnector = $null\n    try {\n        $COMConnector = New-Object -COMObject "V83.COMConnector"\n        # Для 8.2\n        #$COMConnector = New-Object -COMObject "V82.COMConnector"\n        Write-Host "Компонента "COMConnector" зарегистрирована и готова к использованию." -ForegroundColor Green;\n    } \n    catch {\n        Write-Host "Компонента "V82.COMConnector" не зарегистрирована." -ForegroundColor Red;\n    }\n    $DBConn = $null\n    try {\n        $DBConn = New-Object System.Data.Odbc.OdbcConnection\n        $DBConn.ConnectionString = $DBConnectionString\n        $DBConn.Open();\n        Write-Host "Установлено соединение с базой данных мониторинга." -ForegroundColor Green;\n    }\n    catch {\n        Write-Host "Не удалось установить соединение с базой данных мониторинга." -ForegroundColor Red;\n        $DBConn = $null\n    }\n\n    $agentAddress = $_.agentAddress\n    $agentPort = $_.agentPort\n    $clusterAdminName = $_.clusterAdminName\n    $clusterAdminPassword = $_.clusterAdminPassword\n    $fullAgentAddress = "tcp://" + $agentAddress + ":" + $agentPort;\n\n    $fullAgentAddress\n\n    try {\n        if($null -ne $COMConnector -and $null -ne $DBConn) {\n            $serverAgent = $COMConnector.ConnectAgent($fullAgentAddress);\n            $clusterList = $ServerAgent.GetClusters();\n            foreach ($cluster in $clusterList) {\n                $serverAgent.Authenticate($Cluster, $clusterAdminName, $clusterAdminPassword)        \n\n                $period = Get-Date\n                $workingProcesses = $serverAgent.GetWorkingProcesses($cluster)\n                foreach ($workProcess in $workingProcesses) {\n                    \n                    $DBCmd = $DBConn.CreateCommand()\n                    $DBCmd.Connection = $DBConn\n                    $insertQuery = \n@"\n        INSERT INTO work_processes1c\n        (\n            period,\n	        servername,\n	        hostname,    \n	        main_port,\n	        sync_port,\n	        enable,\n	        running,\n	        connections,\n	        started_at,\n	        avg_call_time,\n	        avg_server_call_time,\n	        avg_db_call_time,\n	        avg_back_call_time,\n	        avg_lock_call_time,\n	        selection_size,\n	        avg_threads,\n	        capacity,\n	        memory_size,\n	        memory_excess_time,\n	        available_perfomance,\n	        pid,\n	        use,\n	        is_enable\n        )\n        VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\n"@\n                    $DBCmd.CommandText = $insertQuery\n\n                    [void]$DBCmd.Parameters.Add("@period", [System.Data.Odbc.OdbcType]::varchar, 26)\n                    [void]$DBCmd.Parameters.Add("@servername", [System.Data.Odbc.OdbcType]::varchar, 25)\n                    [void]$DBCmd.Parameters.Add("@hostname", [System.Data.Odbc.OdbcType]::varchar, 25)\n                    [void]$DBCmd.Parameters.Add("@main_port", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@sync_port", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@enable", [System.Data.Odbc.OdbcType]::Bit)\n                    [void]$DBCmd.Parameters.Add("@running", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@connections", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@started_at", [System.Data.Odbc.OdbcType]::varchar, 26)\n                    [void]$DBCmd.Parameters.Add("@avg_call_time", [System.Data.Odbc.OdbcType]::Double)\n                    [void]$DBCmd.Parameters.Add("@avg_server_call_time", [System.Data.Odbc.OdbcType]::Double)\n                    [void]$DBCmd.Parameters.Add("@avg_db_call_time", [System.Data.Odbc.OdbcType]::Double)\n                    [void]$DBCmd.Parameters.Add("@avg_back_call_time", [System.Data.Odbc.OdbcType]::Double)\n                    [void]$DBCmd.Parameters.Add("@avg_lock_call_time", [System.Data.Odbc.OdbcType]::Double)\n                    [void]$DBCmd.Parameters.Add("@selection_size", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@avg_threads", [System.Data.Odbc.OdbcType]::Double)\n                    [void]$DBCmd.Parameters.Add("@capacity", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@memory_size", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@memory_excess_time", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@available_perfomance", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@pid", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@use", [System.Data.Odbc.OdbcType]::BigInt)\n                    [void]$DBCmd.Parameters.Add("@is_enable", [System.Data.Odbc.OdbcType]::Bit)\n\n					# Дата получения информации о рабочих процессах\n                    $DBCmd.Parameters["@period"].Value = $period.ToString("yyyy-MM-dd HH:mm:ss")\n					# Имя сервера 1С\n                    $DBCmd.Parameters["@servername"].Value = $agentAddress\n					# Содержит имя или IP-адрес компьютера, на котором должен быть запущен рабочий процесс.\n                    $DBCmd.Parameters["@hostname"].Value = $workProcess.HostName\n					# Содержит номер основного IP-порта рабочего процесса. Этот порт выделяется динамически \n					# при старте рабочего процесса из диапазонов портов, определенных для соответствующего рабочего сервера.\n                    $DBCmd.Parameters["@main_port"].Value = $workProcess.MainPort\n                    $DBCmd.Parameters["@sync_port"].Value = $workProcess.SyncPort\n					# Признак включения рабочего процесса\n                    $DBCmd.Parameters["@enable"].Value = $workProcess.Enable\n					# 0 – процесс неактивен (либо не загружен в память, либо не может выполнять клиентские запросы); 1 – процесс активен (работает).\n                    $DBCmd.Parameters["@running"].Value = $workProcess.Running\n					# Connections\n                    $DBCmd.Parameters["@connections"].Value = $workProcess.connections\n					# Содержит момент запуска рабочего процесса. Если процесс не запущен, то содержит нулевую дату.\n                    $DBCmd.Parameters["@started_at"].Value = $workProcess.StartedAt.ToString("yyyy-MM-dd HH:mm:ss")\n					# Показывает среднее время обслуживания рабочим процессом одного клиентского обращения. \n					# Оно складывается из: значений свойств AvgServerCallTime, AvgDBCallTime, AvgLockCallTime.\n                    $DBCmd.Parameters["@avg_call_time"].Value = $workProcess.AvgCallTime\n					# Показывает среднее время, затрачиваемое самим рабочим процессом на выполнение одного клиентского обращения.\n                    $DBCmd.Parameters["@avg_server_call_time"].Value = $workProcess.AvgServerCallTime\n					# Показывает среднее время, затрачиваемое рабочим процессом на обращения к серверу баз данных при выполнении одного клиентского обращения.\n                    $DBCmd.Parameters["@avg_db_call_time"].Value = $workProcess.AvgDBCallTime					\n                    $DBCmd.Parameters["@avg_back_call_time"].Value = $workProcess.AvgBackCallTime\n					# Показывает среднее время обращения к менеджеру блокировок.\n                    $DBCmd.Parameters["@avg_lock_call_time"].Value = $workProcess.AvgLockCallTime\n					# Количество вызовов, по которым посчитана статистика.\n                    $DBCmd.Parameters["@selection_size"].Value = $workProcess.SelectionSize\n					# Показывает среднее количество клиентских потоков, исполняемых рабочим процессом кластера.\n                    $DBCmd.Parameters["@avg_threads"].Value = $workProcess.AvgThreads\n					# Относительная производительность процесса. \n					# Может находиться в диапазоне от 1 до 1000. Используется в процессе выбора рабочего процесса, к которому будет подсоединен очередной клиент. \n                    $DBCmd.Parameters["@capacity"].Value = $workProcess.Capacity\n					# Содержит объем виртуальной памяти, занимаемой рабочим процессом, в килобайтах.\n                    $DBCmd.Parameters["@memory_size"].Value = $workProcess.MemorySize\n					# Содержит время, в течение которого объем виртуальной памяти рабочего процесса превышает критическое значение, установленное для кластера, в секундах.\n                    $DBCmd.Parameters["@memory_excess_time"].Value = $workProcess.MemoryExcessTime\n					# Средняя за последние 5 минут доступная производительность. \n					# Определяется по времени реакции рабочего процесса на эталонный запрос.\n					# В соответствии с доступной производительностью кластер серверов принимает решение о распределении клиентов между рабочими процессами.\n                    $DBCmd.Parameters["@available_perfomance"].Value = $workProcess.AvailablePerfomance\n					# Идентификатор активного рабочего процесса в терминах операционной системы.\n                    $DBCmd.Parameters["@pid"].Value = $workProcess.PID\n					<#\n					Определяет использование рабочего процесса кластером. Устанавливается администратором. \n						Возможные значения:\n						0 – не использовать, процесс не должен быть запущен;\n						1 – использовать, процесс должен быть запущен;\n						2 – использовать как резервный, процесс должен быть запущен только при невозможности запуска процесса со значением 1 этого свойства.\n					#>\n                    $DBCmd.Parameters["@use"].Value = $workProcess.Use\n					\n                    if($null -ne $workProcess.IsEnables)\n                    {\n                        $DBCmd.Parameters["@is_enable"].Value = $workProcess.IsEnables\n                    } else\n                    {\n                        $DBCmd.Parameters["@is_enable"].Value = -1\n                    }\n\n                    [void]$DBCmd.ExecuteNonQuery()\n                }\n            }\n        }                \n    } \n    catch {\n        Write-Host "Ошибка при выполнении скрипта." -ForegroundColor Red;\n        Write-Host "Подробно:" -ForegroundColor Red\n        Write-Host $Error[0] -ForegroundColor Red\n    }\n\n    $COMConnector = $null\n    $DBConn = $null\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Принцип тот же, что и для сеансов."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"rac",title:!0,className:"mt-10 md:text",children:"Прочь COM, да здравствует RAC"}),(0,t.jsxs)(r.xv,{p:!0,children:["Работа через COM в какой-то мере устарела и все скрипты относятся теперь к легаси. Эффективнее теперь все подобные действия ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://v8.1c.ru/platforma/administrirovanie-klastera-serverov/",children:"выполнять через RAC"})})}),"."]}),(0,t.jsx)(r.xv,{id:"rac-common",title:!0,className:"mt-10 md:text",children:"Общий пример работы с RAC"}),(0,t.jsx)(r.xv,{p:!0,children:"Вот пример скрипта для блокировки выполнения фоновых заданий для информационных баз."}),(0,t.jsx)(a.Z,{code:'\n# Функция для выполнения произвольной команды с аргументами\nFunction Execute-Command ($commandTitle, $commandPath, $commandArguments)\n{\n    $pinfo = New-Object System.Diagnostics.ProcessStartInfo\n    $pinfo.FileName = $commandPath\n    $pinfo.RedirectStandardError = $true\n    $pinfo.RedirectStandardOutput = $true\n    $pinfo.UseShellExecute = $false\n    $pinfo.CreateNoWindow = $true\n    $pinfo.WindowStyle = [System.Diagnostics.ProcessWindowStyle]::Hidden\n    $pinfo.Arguments = $commandArguments\n\n    $p = New-Object System.Diagnostics.Process\n    $p.StartInfo = $pinfo\n    $p.Start() | Out-Null\n    $p.WaitForExit(100) | Out-Null\n    \n    $resultObject = [pscustomobject]@{\n        commandTitle = $commandTitle\n        stdout = $p.StandardOutput.ReadToEnd()\n        stderr = $p.StandardError.ReadToEnd()\n        ExitCode = $p.ExitCode\n    }\n\n    return $resultObject\n}\n# Функция для преобразования консольного вывода в список объектов\nFunction Convert-StdOut-ToObjectList($sourceResult)\n{\n    $collectionResult = New-Object System.Collections.ArrayList\n    $paramsResult = $sourceResult -split [System.Environment]::NewLine\n\n    $resultObject = $null\n    \n    $paramsResult | ForEach-Object {\n        $paramResult = $_;\n        $indexDelimeter = $paramResult.IndexOf(":");\n        if($indexDelimeter -gt 0)\n        {\n            if($null -eq $resultObject)\n            {\n                $resultObject = New-Object -TypeName PSObject\n            }\n\n            $paramName = $paramResult.Substring(0, $indexDelimeter).Trim();        \n            $paramValue = $paramResult.Substring($indexDelimeter + 1, $paramResult.Length - $indexDelimeter - 1).Trim();       \n            if($null -ne $paramName -and $null -ne $paramValue)\n            {\n                $resultObject | Add-Member -MemberType NoteProperty -Name $paramName -Value $paramValue\n            }\n        } else\n        {\n            $collectionResult.Add($resultObject) | Out-Null;\n            $resultObject = $null\n        }\n    }        \n\n    return $collectionResult;\n}\n\n# Параметры\n$platformVersion = "8.3.18.1208"\n$racExecPath = "C:\\Program Files\\1cv8\\" + $platformVersion + "\\bin\\rac.exe"\n\n# Получаем список кластеров\n$commandClusterInfoResult = Execute-Command -commandTitle "Clusters List" -commandPath $racExecPath -commandArguments " cluster list"\n$commandClusterInfoResultAsObjectList = Convert-StdOut-ToObjectList($commandClusterInfoResult[0].stdout.ToString());\n$commandClusterInfoResultAsObjectList | ForEach-Object {\n    $clusterObject = $_\n    if($clusterObject -eq $null)\n    {\n        continue\n    }  \n\n    # Получаем список информационных баз\n    $clusterId = $clusterObject.cluster\n    $commandInfobasesInfoArguments = " infobase summary list --cluster=" + $clusterId\n    $commandInfobasesInfo = Execute-Command -commandTitle "Infobases List" -commandPath $racExecPath -commandArguments $commandInfobasesInfoArguments\n    $commandInfobasesInfoAsObjectList = Convert-StdOut-ToObjectList($commandInfobasesInfo[0].stdout.ToString());\n\n    $commandInfobasesInfoAsObjectList | ForEach-Object {\n        $itemInfoBase = $_\n        if($itemInfoBase -eq $null)\n        {\n            continue\n        } \n\n        # Изменяем параметры информационной базы\n        $infobaseId = $itemInfoBase.infobase\n        $userName = """"""; # Имя пользователя информационной базы\n        $userPassword = """"""; # Пароль пользователя информационной базы\n        $commandInfobasesDisableJobs = " infobase update --cluster=" + $clusterId + " --infobase=" + $infobaseId + "  --infobase-user=" + $userName + "  --infobase-pwd=" + $userPassword + " --scheduled-jobs-deny=on"        \n        $commandInfobasesInfo = Execute-Command -commandTitle "Infobases Scheduled Jobs Deny" -commandPath $racExecPath -commandArguments $commandInfobasesDisableJobs\n\n        $infobaseName = $itemInfoBase.name\n        Write-Host "Изменены настройки для базы $infobaseName" -ForegroundColor Green\n    }\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Для других действий необходимо изучить документацию по RAC."}),(0,t.jsx)(r.xv,{p:!0,children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://www.powershellgallery.com/packages/1C.Utils/0.1.9/Content/1C.Utils.psm1",children:"Вооооооооооооот тут скрипт."})})})}),(0,t.jsxs)(r.xv,{p:!0,children:["Только не заставляйте переписать все скрипты с COM на RAC ",":)"]})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"start-1c",title:!0,className:"mt-10 md:text",children:"Запуск 1С"}),(0,t.jsxs)(r.xv,{p:!0,children:["Пару лет назад был выпущен модуль ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://www.powershellgallery.com/packages/1C.Utils/0.3.0",children:"“1C.Utils”"})})}),". Там есть хороший скрипт для запуска приложений 1С."]}),(0,t.jsx)(r.xv,{p:!0,children:"Жаль, что модуль больше не обновляется, но даже эти наработки можно использовать."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"greate-sql-server",title:!0,className:"mt-10 md:text",children:"Великий SQL Server"}),(0,t.jsx)(r.xv,{p:!0,children:"Для работы со SQL Server также есть огромный функционал. Работу можно выполнять через ODBC, SMO и многими другими путями. Ниже два небольших примера."}),(0,t.jsx)(r.xv,{id:"greate-sql-server-dbatools",subtitle:!0,className:"mt-10 md:text",children:"Пример работы с модулем DBATools"}),(0,t.jsxs)(r.xv,{p:!0,children:["Здесь мы будем использовать готовый модуль ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://dbatools.io/",children:"DBATools"})})}),", о возможностях которого нам не хватит и целой статьи рассказать."]}),(0,t.jsx)(a.Z,{code:'\n<#\nПример запуска простого запроса с помощью DBATools\nGitHub: https://github.com/sqlcollaborative/dbatools\n#>\n\n$instance = "localhost"\n\n# Получаем список файлов баз данных\nGet-DbaFile -SqlInstance $instance\n\n# Читаем данные событий Extended Events\nGet-DbaXESession -SqlInstance $instance -Session system_health | Read-DbaXEFile | Out-GridView\n\n# Сбос доступа администратора\nReset-DbaAdmin -SqlInstance $instance -Login sqladmin -Verbose\nGet-DbaDatabase -SqlInstance $instance -SqlCredential sqladmin\n                    ',className:"my-5",language:"powershell"}),(0,t.jsxs)(r.xv,{p:!0,children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://dbatools.io/",children:"На официальной странице"})})})," проекта Вы можете найти все что нужно."]}),(0,t.jsx)(r.xv,{id:"greate-sql-server-shrink",subtitle:!0,className:"mt-10 md:text",children:"Пример создания сжатой тестовой базы со скрытым shrink’ом"}),(0,t.jsx)(r.xv,{p:!0,children:"Еще один пример работы, но уже с помощью SMO. Здесь мы создаем копию базы данных с включенным сжатием PAGE. Может пригодиться для создания тестовых баз."}),(0,t.jsx)(a.Z,{code:"\n<#\n    Экспериментальный скрипт для копирования базы данных по объектам.\n    Для копирования используется SQL Servet Managment Object\n    https://docs.microsoft.com/ru-ru/sql/relational-databases/server-management-objects-smo/overview-smo?view=sql-server-2017\n\n    Этапы работы скрипта:\n        1. Создаем соединения со SQL Server\n        2. Создаем пустую базу данных назначения\n        3. Передаем все объекты базы данных в в базу назначения (данные не передаются)\n        4. Включаем сжатие для всех объектов базы данных\n        5. Передаем все данные для ранее скопированных объектов\n        6. Закрываем соединения со SQL Server\n\n    TODO: Скрипт эксперементальный и не для рабочего окружения. \n    Требует серьезного рефакторинга и доработок.\n#>\n\n[string] $SourceSQLInstance = \"localhost\";\n[string] $SourceDatabase = \"source_db_name\";\n[string] $TargetSQLInstance = \"localhost\";\n[string] $TargetDatabase = \"target_db_name\";\n\n#$sourceConnStr = \"Data Source=$SourceSQLInstance;Initial Catalog=$SourceDatabase;Integrated Security=True;\"\n#$TargetConnStr = \"Data Source=$TargetSQLInstance;Initial Catalog=$TargetDatabase;Integrated Security=True;\"\n$sourceConnStr = \"Data Source=$SourceSQLInstance;Initial Catalog=$SourceDatabase;User Id=<userName>;Password=<userPassword>;\"\n$TargetConnStr = \"Data Source=$TargetSQLInstance;User Id=<userName>;Password=<userPassword>;\"\n\nImport-Module -Name SQLPS\nwrite-host 'SQLPS module loaded'\n\n\n\nwrite-host 'Connecting...'\n\n$sourceSQLServer = New-Object Microsoft.SqlServer.Management.Smo.Server $SourceSQLInstance\n$sourceDB = $sourceSQLServer.Databases[$SourceDatabase]\n$sourceConn = New-Object System.Data.SqlClient.SQLConnection($sourceConnStr)\n$sourceConn.Open()\n\n$targetSQLServer = New-Object Microsoft.SqlServer.Management.Smo.Server $TargetSQLInstance\n$targetDB = $sourceSQLServer.Databases[$TargetDatabase]\n$targetConn = New-Object System.Data.SqlClient.SQLConnection($TargetConnStr)\n$targetConn.Open()\n\nwrite-host 'Connection established!'\n\n\nwrite-host 'Creating target database...'\n\nif ($targetDB) {\n    $targetSQLServer.KillAllprocesses($TargetDatabase)\n    $targetDB.Drop()\n}\n$targetDBNew = New-Object Microsoft.SqlServer.Management.Smo.Database($targetSQLServer, $TargetDatabase)\n$targetDBNew.Create()\n\nwrite-host 'Database created!'\n\n\nwrite-host 'Transferring database objects...'\n\n$ObjTransfer = New-Object -TypeName Microsoft.SqlServer.Management.SMO.Transfer -ArgumentList $SourceDB\n\n$ObjTransfer.Options.AllowSystemObjects = $false\n$ObjTransfer.Options.ContinueScriptingOnError = $false\n$ObjTransfer.Options.Indexes = $true\n$ObjTransfer.Options.IncludeIfNotExists = $true\n$ObjTransfer.Options.DriAll = $true\n$ObjTransfer.Options.SchemaQualify = $true\n$ObjTransfer.Options.ScriptSchema = $true\n$ObjTransfer.Options.ScriptData = $true\n$ObjTransfer.Options.WithDependencies = $true\n\n$ObjTransfer.CopyAllTables = $true\n$ObjTransfer.Options.WithDependencies = $true\n$ObjTransfer.Options.ContinueScriptingOnError = $true\n$ObjTransfer.DestinationDatabase = $TargetDatabase\n$ObjTransfer.DestinationServer = $TargetSQLInstance\n$ObjTransfer.DestinationLoginSecure = $true;\n$ObjTransfer.CopyAllDatabaseTriggers = $true;\n$ObjTransfer.CopyAllDefaults = $true;\n$ObjTransfer.CopyAllFullTextCatalogs = $true;\n$ObjTransfer.CopyAllFullTextStopLists = $true;\n$ObjTransfer.CopyAllPartitionFunctions = $true;\n$ObjTransfer.CopyAllPartitionSchemes = $true;\n$ObjTransfer.CopyAllPlanGuides = $true;\n$ObjTransfer.CopyAllRoles = $true;\n$ObjTransfer.CopyAllRules = $true;\n$ObjTransfer.CopyAllSchemas = $true;\n$ObjTransfer.CopyAllSearchPropertyLists = $true;\n$ObjTransfer.CopyAllSequences = $true;\n$ObjTransfer.CopyAllSqlAssemblies = $true;\n$ObjTransfer.CopyAllStoredProcedures = $true;\n$ObjTransfer.CopyAllSynonyms = $true;\n$ObjTransfer.CopyAllTables = $true;\n$ObjTransfer.CopyAllUsers = $true;\n$ObjTransfer.CopyAllViews = $true;\n$ObjTransfer.CopyAllXmlSchemaCollections = $true;\n$ObjTransfer.CopySchema = $true;\n$ObjTransfer.CopyData = $false;\n\n$ObjTransfer.TransferData()\n\nwrite-host 'Database objects transferred!'\n\n\n\n\n\nwrite-host 'Enabling compression for database objects...'\n\n$targetConn.ChangeDatabase($TargetDatabase);\n\n$cmdObjectCompression = \n\"declare @table_name sys.sysname, @IS_CLUSTERED bit, @SQL nvarchar(1000)\n    declare @c cursor\n    set @c = cursor local fast_forward for   \n    select distinct s.name + '.' + o.name, coalesce( (select 1 from sys.indexes i where o.object_id = i.object_id and i.type_desc = 'CLUSTERED' ), 0 ) IS_CLUSTERED\n    from sys.partitions p\n      inner join sys.objects o on p.object_id = o.object_id and o.type_desc = 'USER_TABLE' and p.partition_number = 1\n      inner join sys.schemas s on s.schema_id = o.schema_id\n    where p.data_compression_desc = 'NONE'\n    open @c\n    fetch next from @c into @table_name, @IS_CLUSTERED\n    while (@@fetch_status = 0) begin\n      set @sql = 'ALTER INDEX ALL ON ' + @table_name + ' REBUILD WITH (DATA_COMPRESSION = PAGE);' -- DATA_COMPRESSION = PAGE / DATA_COMPRESSION = NONE\n      execute (@sql)\n      print @sql\n      if ( @IS_CLUSTERED = 0 ) begin\n        set @sql = 'ALTER TABLE ' + @table_name + ' REBUILD WITH (DATA_COMPRESSION = PAGE);' -- DATA_COMPRESSION = PAGE / DATA_COMPRESSION = NONE\n        execute (@sql)\n        print @sql\n      end\n      fetch next from @c into @table_name, @IS_CLUSTERED\n    end\";\n\n$commandObjectCompression = new-object system.data.sqlclient.sqlcommand($cmdObjectCompression, $targetConn);\n$commandObjectCompressionResult = $commandObjectCompression.ExecuteNonQuery();\n\nwrite-host 'Compression for database objects enabled!'\n\n\n\n\n\nwrite-host 'Transferring data...'\n\n$sqlCmd = New-Object System.Data.SqlClient.SqlCommand\n$sqlCmd.Connection = $sourceConn\n$sqlCmd.CommandText = \"\nSELECT\n	a3.name AS [schemaname],\n	a2.name AS [tablename],\n	a1.rows as row_count\nFROM\n	(SELECT \n		ps.object_id,\n		SUM (\n			CASE\n				WHEN (ps.index_id < 2) THEN row_count\n				ELSE 0\n			END\n			) AS [rows]\n	FROM sys.dm_db_partition_stats ps\n	GROUP BY ps.object_id) AS a1\nINNER JOIN sys.all_objects a2  ON ( a1.object_id = a2.object_id ) \nINNER JOIN sys.schemas a3 ON (a2.schema_id = a3.schema_id)\nWHERE\n	a2.type <> N'S' and a2.type <> N'IT'\n	AND a1.rows > 0\nORDER BY row_count DESC\";\n\n$Tables = @();\n$reader = $sqlCmd.ExecuteReader()\nwhile ($reader.Read()) {\n    $Tables += $reader[\"tablename\"]\n}\n$reader.Close()\n\n$countTables = $Tables.Count;\n$numberTable = 1;\n\nforeach ($table in $Tables) {\n\n    $numberTable = $numberTable + 1;\n    Write-Host \"$numberTable / $countTables\"\n\n    if($Tables.Contains($table) -eq $false)\n    {\n        continue;\n    }\n\n    $dataTransfer = New-Object -TypeName Microsoft.SqlServer.Management.SMO.Transfer -ArgumentList $SourceDB\n    $dataTransfer.DestinationDatabase = $TargetDatabase\n    $dataTransfer.DestinationServer = $TargetSQLInstance\n    $dataTransfer.CopyData = $true\n    $dataTransfer.CopySchema = $false\n    $dataTransfer.CopyAllObjects = $false\n    $dataTransfer.BatchSize = 10000\n    $itemTableFilter = $dataTransfer.ObjectList.Add($sourceDB.Tables[$table]);\n    $dataTransferResult = $dataTransfer.TransferData()\n}\n\nwrite-host 'Data transferred!'\n\n\n\nwrite-host 'Closing connections...'\n\n$sourceConn.Close()\n$targetConn.Close()\n\nwrite-host 'Connections closed!'\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"У такого подхода есть и еще один плюс - не нужно делать шринк, т.к. данные с нуля создаются в копии базы. Поэтому пустого зарезервированного места в файле данных просто не будет."}),(0,t.jsxs)(r.xv,{p:!0,children:["Капля в море, но нужно же с чего-то начинать ",":)"]})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"postgresql",title:!0,className:"mt-10 md:text",children:"Совсем немного PostgreSQL"}),(0,t.jsx)(r.xv,{p:!0,children:"Для работы с PostgreSQL также можно использовать PowerShell, даже если установка выполнена на Linux. Следующий скрипт показывает простейший вызов команд с помощью psql."}),(0,t.jsx)(a.Z,{code:'\n<#\nПример вызова PSQL из скрипта с установкой логина и пароля пользователя\n#>\n\n# Путь PostgreSQL\n$pgDirectory = "C:\\Program Files\\PostgreSQL\\13\\bin"\n# Устанавливаем текущий каталог PostgreSQL для простого вызова утилиты psql\n# Альтернативный подход - добавить этот каталог в параметры окружения\nSet-Location $pgDirectory;\n# База данных для подключения\n$pgDatabase = "postgres"\n# Имя пользователя\n$pgUser = "postgres"\n# Пароль пользователя\n$pgPassword = \'Pas$w0rd\'\n# psql не имеет параметра установки пароля явно в параметрах вызова,\n# но вместо этого можно установить пароль через параметр окружения\n$env:PGPASSWORD = $pgPassword;\n\n# Выполнение произвольной команды\n.\\psql.exe -p 5432 -U $pgUser -d $pgDatabase -c \'select now()\'\n\n# Завершение всех соединений с указанной базой данных\n#.\\psql.exe -p 5432 -U $pgUser -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE pid <> pg_backend_pid() AND datname = \'$pgDatabase\';"\n\n# Выполнение скрипта из файла. Таким же образом можно выполнить восстановление из дампа (*.sql)\n#.\\psql.exe -p 5432 -U $pgUser -d $pgDatabase -1 -f $scriptFilePath\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Фишкой здесь является установка пароля пользователя, от которого выполняется обращение к СУБД, т.к. psql не имеет такого параметра явно. В остальном ничего сложного."}),(0,t.jsx)(r.xv,{p:!0,children:"Можно выполнять множество других действий, но для примера оставим только этот скрипт."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"api",title:!0,className:"mt-10 md:text",children:"Вызов стороннего API"}),(0,t.jsx)(r.xv,{p:!0,children:"Часто приходится иметь дело с различными REST-сервисами:"}),(0,t.jsxs)(r.aV,{children:[(0,t.jsx)("li",{children:"Проверять их доступность"}),(0,t.jsx)("li",{children:"Управлять учетными записями"}),(0,t.jsx)("li",{children:"Автоматизировать настройку"}),(0,t.jsx)("li",{children:"И др."})]}),(0,t.jsx)(r.xv,{p:!0,children:"В этом случае с помощью PowerShell также можно решать поставленные задачи."}),(0,t.jsx)(r.xv,{id:"api-zabbix",title:!0,className:"mt-10 md:text",children:"Пример вызова API сервера Zabbix"}),(0,t.jsx)(r.xv,{p:!0,children:"Например, с помощью следующего скрипта можно проверить доступность API сервера Zabbix."}),(0,t.jsx)(a.Z,{code:'\n<#\nПример вызова JSON-API Zabbix\n#>\nfunction CheckZabbixApi($zbxUserName, $zbxUserPassword, $zbxBaseUrl)\n{\n    $params = @{\n        body =  @{\n            "jsonrpc"= "2.0"\n            "method"= "user.login"\n            "params"= @{\n                "user"= $zbxUserName\n                "password"= $zbxUserPassword\n            }\n            "id"= 1\n            "auth"= $null\n        } | ConvertTo-Json\n        uri = "$zbxBaseUrl/api_jsonrpc.php"\n        headers = @{"Content-Type" = "application/json"}\n        method = "Post"\n    }\n\n    $result = Invoke-WebRequest @params\n    $statusCode = $result.StatusCode\n    if($statusCode -ne 200)\n    {\n        throw "Wrong answer from API: $statusCode"\n    }\n}\n\n# Пример использования\ntry\n{\n    CheckZabbixApi();\n    Write-Host "API доступен!" -BackgroundColor Green\n} catch\n{\n    Write-Host "API недоступен!" -BackgroundColor Red\n}\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Аналогично можно обращаться к любым REST-сервисам. Главное формировать запрос с учетом их требований."}),(0,t.jsx)(r.xv,{p:!0,children:"Подобная тема актуальная и при работе с облаками (Azure, AWS и др.) или любыми другими сервисами."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"bot",title:!0,className:"mt-10 md:text",children:"Собственный бот"}),(0,t.jsx)(r.xv,{p:!0,children:"Использование мессенджеров для уведомления о важных событиях мониторинга трудно переоценить. Ниже скрипт для отправки сообщений в Telegram."}),(0,t.jsx)(r.xv,{id:"bot-telegram",title:!0,className:"mt-10 md:text",children:"Пример вызова API сервера Zabbix"}),(0,t.jsx)(r.xv,{p:!0,children:"Для отправки сообщений достаточно знать ID бота и идентификатор чата."}),(0,t.jsx)(a.Z,{code:'\n# Настройки Телеграм\n$telegramBotId = "<BotId>" # Идентификатор бота\n$telegramChacId = "<ChatId>" # Идентификатор чата\n\nSend-TelegramTextMessage `\n    -BotToken $telegramBotId `\n    -ChatID $telegramChacId `\n    -Message "Hello from Telegram!" `\n    -ParseMode Markdown `\n    -Preview $false `\n    -Notification $false `\n    -Verbose\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"В результате сообщение будет отправлено и важное событие не будет пропущено. Вот служебные функции из скрипта выше."}),(0,t.jsx)(a.Z,{code:'\n<#\nФункция для отправки сообщений в Telegram\n\nАвтор оригинального скрипта:\nhttps://gist.github.com/techthoughts2\n\nСам скрипт взят отсюда:\nhttps://gist.github.com/techthoughts2/8b1c20b1bf145103c71bc64704e272bc\n\nТакже есть более функциональный модуль для PowerShell:\nhttps://github.com/techthoughts2/PoshGram\n#>\n\n<#\n.Synopsis\n    Sends Telegram text message via Bot API\n.DESCRIPTION\n    Uses Telegram Bot API to send text message to specified Telegram chat. Several options can be specified to adjust message parameters.\n.EXAMPLE\n    $bot = "#########:xxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxx"\n    $chat = "-#########"\n    Send-TelegramTextMessage -BotToken $bot -ChatID $chat -Message "Hello"\n.EXAMPLE\n    $bot = "#########:xxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxx"\n    $chat = "-#########"\n\n    Send-TelegramTextMessage `\n        -BotToken $bot `\n        -ChatID $chat `\n        -Message "Hello *chat* _channel_, check out this link: [TechThoughts](http://techthoughts.info/)" `\n        -ParseMode Markdown `\n        -Preview $false `\n        -Notification $false `\n        -Verbose\n.PARAMETER BotToken\n    Use this token to access the HTTP API\n.PARAMETER ChatID\n    Unique identifier for the target chat\n.PARAMETER Message\n    Text of the message to be sent\n.PARAMETER ParseMode\n    Send Markdown or HTML, if you want Telegram apps to show bold, italic, fixed-width text or inline URLs in your bot\'s message. Default is Markdown.\n.PARAMETER Preview\n    Disables link previews for links in this message. Default is $false\n.PARAMETER Notification\n    Sends the message silently. Users will receive a notification with no sound. Default is $false\n.OUTPUTS\n    System.Boolean\n.NOTES\n    Author: Jake Morrison - @jakemorrison - http://techthoughts.info/\n    This works with PowerShell Versions 5.1, 6.0, 6.1\n    For a description of the Bot API, see this page: https://core.telegram.org/bots/api\n    How do I get my channel ID? Use the getidsbot https://telegram.me/getidsbot\n    How do I set up a bot and get a token? Use the BotFather https://t.me/BotFather\n.COMPONENT\n   PoshGram - https://github.com/techthoughts2/PoshGram\n.FUNCTIONALITY\n    https://core.telegram.org/bots/api#sendmessage\n    Parameters 					Type 				Required 	Description\n    chat_id 				    Integer or String 	Yes 		Unique identifier for the target chat or username of the target channel (in the format @channelusername)\n    text 						String 				Yes 		Text of the message to be sent\n    parse_mode 					String 				Optional 	Send Markdown or HTML, if you want Telegram apps to show bold, italic, fixed-width text or inline URLs in your bot\'s message.\n    disable_web_page_preview 	Boolean 			Optional 	Disables link previews for links in this message\n    disable_notification 		Boolean 			Optional 	Sends the message silently. Users will receive a notification with no sound.\n    reply_to_message_id 	    Integer 			Optional 	If the message is a reply, ID of the original message\n#>\nfunction Send-TelegramTextMessage {\n    [CmdletBinding()]\n    Param\n    (\n        [Parameter(Mandatory = $true,\n            HelpMessage = \'#########:xxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxx\')]\n        [ValidateNotNull()]\n        [ValidateNotNullOrEmpty()]\n        [string]$BotToken, #you could set a token right here if you wanted\n        [Parameter(Mandatory = $true,\n            HelpMessage = \'-#########\')]\n        [ValidateNotNull()]\n        [ValidateNotNullOrEmpty()]\n        [string]$ChatID, #you could set a Chat ID right here if you wanted\n        [Parameter(Mandatory = $true,\n            HelpMessage = \'Text of the message to be sent\')]\n        [ValidateNotNull()]\n        [ValidateNotNullOrEmpty()]\n        [string]$Message,\n        [Parameter(Mandatory = $false,\n            HelpMessage = \'HTML vs Markdown for message formatting\')]\n        [ValidateSet("Markdown", "HTML")]\n        [string]$ParseMode = "Markdown", #set to Markdown by default\n        [Parameter(Mandatory = $false,\n            HelpMessage = \'Disables link previews\')]\n        [bool]$Preview = $false, #set to false by default\n        [Parameter(Mandatory = $false,\n            HelpMessage = \'Sends the message silently\')]\n        [bool]$Notification = $false #set to false by default\n    )\n    #------------------------------------------------------------------------\n    $results = $true #assume the best\n    #------------------------------------------------------------------------\n    $payload = @{\n        "chat_id"                   = $ChatID;\n        "text"                      = $Message\n        "parse_mode"                = $ParseMode;\n        "disable_web_page_preview"  = $Preview;\n        "disable_notification"      = $Notification\n    }#payload\n    #------------------------------------------------------------------------\n    try {\n        Write-Verbose -Message "Sending message..."\n\n        # Раскоментируйте эту строку, если при отправке получаете ошибку вида \n        # "Не удалось создать безопасный канал SSL / TLS"\n        #[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12   \n\n        $eval = Invoke-RestMethod `\n            -Uri ("https://api.telegram.org/bot{0}/sendMessage" -f $BotToken) `\n            -Method Post `\n            -ContentType "application/json" `\n            -Body (ConvertTo-Json -Compress -InputObject $payload) `\n            -ErrorAction Stop\n        if (!($eval.ok -eq "True")) {\n            Write-Warning -Message "Message did not send successfully"\n            $results = $false\n        }#if_StatusDescription\n    }#try_messageSend\n    catch {\n        Write-Warning "An error was encountered sending the Telegram message:"\n        Write-Error $_\n        $results = $false\n    }#catch_messageSend\n    return $results\n    #------------------------------------------------------------------------\n}#function_Send-TelegramTextMessage\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Очень удобно с этим работать, если оформить в модуль. Но это уже другая история."}),(0,t.jsx)(r.xv,{p:!0,children:"Есть решения и для других мессенджеров (WhatsApp, Viber и т.д.), но рассматривать их сейчас не будем."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"email",title:!0,className:"mt-10 md:text",children:"Отправка писем"}),(0,t.jsx)(r.xv,{p:!0,children:"Электронная почта также до сих пор остается важным инструментом коммуникаций. Отправка туда сообщений иногда является самым универсальным способом уведомлений, ведь не все предпочитают одинаковые мессенджеры. А вот почта, по крайней мере корпоративная, есть почти всегда."}),(0,t.jsx)(r.xv,{id:"email-yandex",title:!0,className:"mt-10 md:text",children:"Отправка писем через Yandex.Mail"}),(0,t.jsx)(r.xv,{p:!0,children:"Этот скрипт отправляет почту через сервис Yandex.Mail."}),(0,t.jsx)(a.Z,{code:'\n<#\nПример скрипта отправки почтовых сообщений сервисом Yandex Mail.\nДля других сервисов скрипт будет примерно таким же, но могут отличатсья параметры. См. инструкции сервиса.\n#>\n\n# Параметры почтового сервера\n$serverSmtp = "smtp.yandex.ru" # Адрес сервера\n$port = 587 # Порт\n$From = "login@yandex.ru" # Отправитель\n$To = "login@mail.ru" # Получатель\n$subject = "Всем привет!" # Тема\n\n$user = "login@yandex.ru" # Пользователь\n$pass = \'<Pas$w0rd>\' # Пароль\n\n# Формируем письмо\n$mes = New-Object System.Net.Mail.MailMessage\n$mes.From = $from # Отправитель\n$mes.To.Add($to) # Добавляем получателя\n$mes.Subject = $subject # Указываем тему\n$mes.IsBodyHTML = $true # Устанавливаем флаг, что письмо в формате HTML\n$mes.Body = "<h1>Доброго дня!</h1>" # Задаем тело письма\n\n#Добавляем файл по указанному пути в качестве вложения\n# $file = "C:\\Docs\\SomeDoc.xlsx"\n# $att = New-object Net.Mail.Attachment($file)\n# $mes.Attachments.Add($att) \n\n# Настраиваем подключение к почтовому серверу\n$smtp = New-Object Net.Mail.SmtpClient($serverSmtp, $port)\n$smtp.EnableSSL = $true # Включаем использование SSL\n# Настраиваем данные аутентификации\n$smtp.Credentials = New-Object System.Net.NetworkCredential($user, $pass); \n\n# Отправляем письмо\n$smtp.Send($mes) \n# Очищаем данные присоединенных файлов\n# $att.Dispose()\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"У Яндекс есть различные ограничения, о которых стоит прочитать в документации. Например, двухфакторная аутентификация уже не позволит таким способом отправлять почту. Есть и другие нюансы."}),(0,t.jsx)(r.xv,{p:!0,children:"А Вы используете электронную почту для уведомлений?"})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"proc",title:!0,className:"mt-10 md:text",children:"Контролируй процессы"}),(0,t.jsxs)(r.xv,{p:!0,children:["Часто приходится управлять различными процессами в системе. Например, завершить зависшие процессы или узнать потребляемые ими ресурсы. Тут то на сцену выходит PowerShell ",":)"]}),(0,t.jsx)(r.xv,{id:"proc-list",title:!0,className:"mt-10 md:text",children:"Список процессов"}),(0,t.jsx)(r.xv,{p:!0,children:"Примеры команд для получения информации о процессах различными способами."}),(0,t.jsx)(a.Z,{code:"\n<#\nПримеры команд для управления процессами\n#>\n\n# 1. Получение списка всех активных процессов\nGet-Process\n<# Пример вывода\nNPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName\n------    -----      -----     ------      --  -- -----------\n    16    13,52      19,33       0,00    4808   0 AdjustService\n    33    56,60      27,76     109,02   18204   1 Agent\n    15     3,80      12,36       0,00    5232   0 AGMService\n    14     3,52      12,30       0,00    5216   0 AGSService\n    51    91,05      96,21      14,02   15216   1 ApCent\n    28    28,86      34,76       0,23   16380   1 ApplicationFrameHost\n    11     8,20      14,98       0,06   23244   0 audiodg\n#>\n\n# 2. Получение информации о конкретном процессе\nGet-Process -Id 18204\n<# Пример вывода\n NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName\n ------    -----      -----     ------      --  -- -----------\n     33    56,67      27,79     109,20   18204   1 Agent\n#>\n\n# 3. Получение процессов по имени (полному или по шаблону)\nGet-Process -Name rph*\n<# Пример вывода\n NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName\n ------    -----      -----     ------      --  -- -----------\n     97    73,46      88,60       0,00    6804   0 rphost\n\nТакже можно применить несколько условий по отбором по имени.\n#>\nGet-Process -Name rph*,ragent,rmngr\n<# Пример вывода\n NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName\n ------    -----      -----     ------      --  -- -----------\n     73    46,81      34,77       0,00    1172   0 ragent\n    108   108,90      64,94       0,00   17296   0 rmngr\n     97    73,64      88,70       0,00    6804   0 rphost\n#>\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Проще простого!"}),(0,t.jsx)(r.xv,{id:"proc-kill",title:!0,className:"mt-10 md:text",children:"Убить нельзя помиловать"}),(0,t.jsx)(r.xv,{p:!0,children:"Кроме получения информации о процессах нужно еще и уметь их останавливать."}),(0,t.jsx)(a.Z,{code:"\n# 1. Остановка процессов по имени\nStop-Process -Name rphost\n\n# 2. Остановка процессов, которые не отвечают\nGet-Process -Name rphost | Where-Object -FilterScript {$_.Responding -eq $false} | Stop-Process\n\n# 3. Остановка процесса по тексту в заголовке. Может быть полезно для завершения процессов, у которых \"всплыла\" ошибка с Visual C++ Runtime.\n$processData = Get-Process | Where-Object { $_.mainwindowhandle -ne 0 -and $_.ProcessName -eq '<Отбор по имени процесса>' } | Select-Object MainWindowTitle, ProcessName, Id\n\n$processData | ForEach-Object {\n    # Проверяем наличие нужного текста в заголовке приложения\n    if ($_.MainWindowTitle -like '*Visual C++*') {\n        Stop-Process -Id $_.Id\n    }\n}\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"В первом примере выполняется остановка процессов по имени. Во втором остановка процессов, которые не отвечают. А третий пример наиболее интересен - завершаются процессы, во время выполнения которых появилась ошибка вида “Visual C++ Runtime Library”."}),(0,t.jsx)(r.xv,{p:!0,children:"Вот такие процессы и будут завершены."}),(0,t.jsxs)(r.xv,{p:!0,children:["Имей власть над процессами и будешь властвовать над ОС ",":)"]})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"port",title:!0,className:"mt-10 md:text",children:"Проверка свободного порта"}),(0,t.jsx)(r.xv,{p:!0,children:"Почти каждый сталкивался с проблемой, когда служба 1С могла не запускаться из-за занятого порта другим приложением. Для диагностики нужно проверить кто нужный порт занял. Тут на сцену выходит…"}),(0,t.jsx)(r.xv,{id:"port-free",title:!0,className:"mt-10 md:text",children:"Свободный ли порт?"}),(0,t.jsx)(r.xv,{p:!0,children:"С помощью скрипта можно узнать кто и как занял порт."}),(0,t.jsx)(a.Z,{code:'\n<#\nПример скрипта для получения информации о том кто и какой порт использует.\n\nМожно искать информацию для конкретного порта или процесса.\n#>\n\nnetstat -ano | \nWhere-Object{$_ -match \'LISTENING|UDP\'} | \nForEach-Object {\n    $split = $_.Trim() -split "\\s+"\n    [pscustomobject][ordered]@{\n        "Protocol" = $split[0]\n        "LocalAddress" = $split[1]\n        "ForeignAddress" = $split[2]\n        # Some might not have a state. Check to see if the last element is a number. If it is ignore it\n        "State" = if($split[3] -notmatch "\\d+"){$split[3]}else{""}\n        # The last element in every case will be a PID\n        "ProcessName" = $(Get-Process -Id $split[-1]).ProcessName\n        "ProcessId" = $split[-1]\n    }\n} |\n# Where-Object{$_.ProcessId -eq 15151} | # Фильтр по идентификатору процесса\n# Where-Object{$_.ProcessName -like \'rmng*\'} | # Фильтр по имени приложения\n# Where-Object{$_.LocalAddress -like \'*:1560\'} | # Фильтр по порту\nSelect Protocol, LocalAddress, ForeignAddress, State, ProcessName, ProcessId\n                    ',className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Главное раскомментировать нужное условие для фильтрации результата."}),(0,t.jsxs)(r.xv,{p:!0,children:["Теперь можно не гадать, почему служба 1С не запустилась ",":)"]})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"remote",title:!0,className:"mt-10 md:text",children:"Удаленное управление"}),(0,t.jsx)(r.xv,{p:!0,children:"PowerShell позволяет выполнять скрипты / команды на удаленных машинах, что значительно упрощает решение задач администрирования. Решается это с помощью PSRemoting. Ранее все удаленные взаимодействия выполнялись через WinRM, теперь же появилась возможность работать и через SSH."}),(0,t.jsx)(r.xv,{p:!0,children:"Ниже пример настройки для Windows и выполнение удаленной команды."}),(0,t.jsx)(r.xv,{id:"remote-setup",title:!0,className:"mt-10 md:text",children:"Простейший пример настройки"}),(0,t.jsx)(r.xv,{p:!0,children:"На обоих машинах нужно обязательно установить PowerShell и включить удаленное управление. Ниже пример скрипта для настройки."}),(0,t.jsx)(a.Z,{code:"\n<#\nПростейшая настройка удаленного доступа через PSRemoting\nВнимание! Скрипт не для рабочего окружения.\n\nПодробнее можно прочитать:\nhttps://www.howtogeek.com/117192/how-to-run-powershell-commands-on-remote-computers/\nhttps://docs.microsoft.com/ru-ru/powershell/module/microsoft.powershell.core/about/about_remote_faq?view=powershell-7.1#can-i-create-a-persistent-connection\nhttps://docs.microsoft.com/ru-ru/powershell/scripting/learn/remoting/running-remote-commands?view=powershell-7.1\n#>\n\n# Включаем использование PSRemoting\nEnable-PSRemoting -Force\n\n# Включаем доступ для других машин (в этом случае для всех)\nSet-Item wsman:\\localhost\\client\\trustedhosts *\n\n# Перезапускаем службу WinRM\nRestart-Service WinRM\n\n# Проверяем доступ\nTest-WsMan HostNameForTest\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Нужно учитывать, что это лишь пример скрипта, который не годится для рабочего окружения."}),(0,t.jsx)(r.xv,{id:"remote-use",title:!0,className:"mt-10 md:text",children:"Как использовать"}),(0,t.jsx)(r.xv,{p:!0,children:"После настройки можно выполнять любой скрипт на удаленной машине. Ниже пример перезапуска удаленного хоста."}),(0,t.jsx)(a.Z,{code:"\n<#\nПример выполнения простейшей команды\n#>\n\n# Перезапускаем удаленный компьютер\nInvoke-Command -ComputerName HostName -ScriptBlock { \n    Restart-Computer -Force\n} -credential UserName\n                    ",className:"my-5",language:"powershell"}),(0,t.jsx)(r.xv,{p:!0,children:"Никто не мешает удаленно выполнить любой скрипт из тех, что были показаны выше."}),(0,t.jsx)(r.xv,{p:!0,children:"Один PowerShell, чтоб править всеми … хостами."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"more",title:!0,className:"mt-10 md:text",children:"Еще, еще, еще"}),(0,t.jsx)(r.xv,{p:!0,children:"На этом примеры скриптов закончим. Многие другие скрипты и примеры можно найти в таких источниках:"}),(0,t.jsxs)(r.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://github.com/fleschutz/PowerShell",children:"PowerShell"})})})," - набор публичных скриптов под разные задачи."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/PowerShellTools",children:"PowerShellTools"})})})," - еще один репозиторий со скриптами."]})]}),(0,t.jsx)(r.xv,{p:!0,children:"А теперь пойдем дальше."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"nope",title:!0,className:"mt-10 md:text",children:"Меньше костылей"}),(0,t.jsx)(r.xv,{p:!0,children:"Создавать свои скрипты - это нормально, но некоторые задачи уже были решены до нас и мы можем этот опыт использовать. В контексте PowerShell это либо использовать скрипты других разработчиков, либо брать на вооружение целые готовые модули PowerShell от сообщества или компаний (обычно выпускают вместе с каким-либо продуктом, как это делает та же Microsoft)."}),(0,t.jsxs)(r.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://www.planetpowershell.com/",children:"Planet PowerShell"})})})," и ",(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://powershell.org/",children:"PowerShell.org"})})})," - сообщество разработчиков PowerShell."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://www.powershellgallery.com/",children:"PoweShell Galery"})})})," - галерея готовых скриптов и решений на PowerShell. В разделе просмотра списка пакетов Вы можете найти такие популярные модули как:",(0,t.jsxs)(r.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://dbatools.io/",children:"dbatools"})})})," - модуль автоматизации работы со SQL Server."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://github.com/TheTaylorLee/AdminToolbox",children:"AdminToolbox.ActiveDirectory"})})})," - инструменты для управления Active Directory."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:(0,t.jsx)(r.e9,{newTab:!0,href:"https://github.com/mithrandyr/SimplySql",children:"SimplySql"})})})," - удобный инструмент для формирования запросов к разным СУБД (SQL Server, PostgreSQL, Oracle и др.)."]})]})]}),(0,t.jsx)(r.xv,{p:!0,children:"И очень много всего еще."}),(0,t.jsx)(r.xv,{p:!0,children:"Есть даже 1C.Utils (о нем говорили выше) - небольшой набор инструментов для 1С, правда автор забросил его пару лет назад, а жаль."}),(0,t.jsx)(r.xv,{p:!0,children:"В общем, готовых решений много, а участников сообщества еще больше!"})]}),(0,t.jsx)(r.xv,{p:!0,children:"А теперь пойдем дальше."})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)(r.xv,{id:"theend",title:!0,className:"mt-10 md:text",children:"В самом конце"}),(0,t.jsx)(r.xv,{p:!0,children:"Все что я хотел сказать в этой статье, так это недооцененный инструмент для решения повседневных задач - PowerShell. Недооцененный именно в среде разработчиков 1С, тогда как в мире .NET, CI/CD и для управления некоторых облачных решений - PowerShell занял хорошие позиции."}),(0,t.jsx)(r.xv,{p:!0,children:"Вместо использования готовых решений, сообщество и сама фирма “1С” пошли своим путем, создавая собственные инструменты автоматизации. Причем фирма “1С” проигнорировала труды сообщества в виде OneScript и создает собственный инструмент - 1С:Исполнитель."}),(0,t.jsx)(r.xv,{p:!0,children:"Конечно, чем больше инструментов, тем лучше. Но средства автоматизации создаются не только для разработчиков 1С, но и для администраторов, DevOps\\’ов и других специалистов, которые могут и не иметь прямого отношения к 1С. А если администратору нужно будет автоматизировать процесс разворачивания клиентов 1С, сбор информации с сервера 1С или другую задачу автоматизации, то зачем ему изучать OneScript или 1С:Исполнитель? А ставить для их работы дополнительные компоненты, о которых в не1Сном сообществе не слышали и не могут доверять им."}),(0,t.jsx)(r.xv,{p:!0,children:"Автор не противник OneScript или 1С:Исполнитель. Я фанат PowerShell и немного Bash. Понимаю, что коллеги проделали большую работу и продукт взлетел в определенном смысле. Но может сообществу 1С пора быть более открытым и не замыкаться свою экосистему саму на себя?"})]})]})},850:function(e,n,s){"use strict";s.d(n,{Z:function(){return d}});var t=s(5893),r=s(7294),a=s(4965),o=s(4275),i=s(7340);function l(){let e=(0,i._)(["\n  text-align: left;\n  overflow: hidden;\n  font-size: 14px;\n  border-radius: 6px;\n  overflow: auto;\n  max-height: 350px;\n\n  & .token-line {\n    line-height: 1.3em;\n    height: 1.3em;\n  }\n"]);return l=function(){return e},e}let c=s(964).ZP.pre(l());var d=e=>{let{code:n,className:i,language:l}=e;return(void 0!==s.g?s.g:window).Prism=a.p1,s(1354),s(9016),s(5266),s(2927),s(1315),s(7874),s(6862),(0,t.jsx)("div",{className:(0,o.GF)("bg-blue-500 md:p-5 p-2",i),children:(0,t.jsx)("div",{className:"shadow-lg",children:(0,t.jsx)(a.y$,{theme:a.np.vsDark,code:n,language:null!=l?l:l="tsx",children:e=>{let{className:n,style:s,tokens:a,getLineProps:o,getTokenProps:i}=e;return(0,t.jsx)(c,{className:n,style:s,children:a.map((e,n)=>(0,r.createElement)("div",{...o({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,r.createElement)("span",{...i({token:e,key:n}),key:Math.random()}))))})}})})})}},9305:function(e,n,s){"use strict";s.d(n,{Ee:function(){return i},Xg:function(){return a},Y7:function(){return m},aV:function(){return c},e9:function(){return d},o_:function(){return $},ty:function(){return l},xv:function(){return o}});var t=s(5152),r=s.n(t);let a=r()(()=>Promise.all([s.e(4838),s.e(4738),s.e(1664),s.e(7167)]).then(s.bind(s,7167)),{loadableGenerated:{webpack:()=>[7167]}}),o=r()(()=>s.e(9179).then(s.bind(s,9179)),{loadableGenerated:{webpack:()=>[9179]}}),i=r()(()=>s.e(1974).then(s.bind(s,1974)),{loadableGenerated:{webpack:()=>[1974]}}),l=r()(()=>s.e(8547).then(s.bind(s,8547)),{loadableGenerated:{webpack:()=>[8547]}}),c=r()(()=>s.e(6806).then(s.bind(s,6806)),{loadableGenerated:{webpack:()=>[6806]}}),d=r()(()=>Promise.all([s.e(1664),s.e(1465)]).then(s.bind(s,1465)),{loadableGenerated:{webpack:()=>[1465]}});r()(()=>s.e(567).then(s.bind(s,567)),{loadableGenerated:{webpack:()=>[567]}});let m=r()(()=>Promise.all([s.e(2004),s.e(4139)]).then(s.bind(s,4139)),{loadableGenerated:{webpack:()=>[4139]}}),$=r()(()=>Promise.all([s.e(3811),s.e(7472),s.e(584),s.e(7870)]).then(s.bind(s,7870)),{loadableGenerated:{webpack:()=>[7870]}})}},function(e){e.O(0,[1102,2888,9774,179],function(){return e(e.s=6030)}),_N_E=e.O()}]);