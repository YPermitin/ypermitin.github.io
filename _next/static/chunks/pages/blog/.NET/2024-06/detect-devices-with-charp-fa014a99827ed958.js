(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9013],{7710:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/.NET/2024-06/detect-devices-with-charp",function(){return s(6550)}])},6550:function(e,n,s){"use strict";s.r(n);var i=s(5893),r=s(4853);s(7294);var t=s(4313),d=s(9209),l=s(7855);n.default=()=>(0,i.jsxs)(r.Xg,{blogcentered:!0,children:[(0,i.jsxs)(r.xv,{textAlign:d.PH.RIGHT,quote:!0,children:["Чтобы найти иголку в стоге сена, достаточно сжечь сено",(0,i.jsx)("br",{}),"и провести магнитом над пеплом.",(0,i.jsx)("br",{}),"(с) Бернар Вербер"]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Поиск устройств в сети с помощью C# (.NET). Пинг, сканирование сети, ARP, широковещательные сообщения UDP. А также делаем пример приложений для RasberryPi и Android с возможностью поиска устройства со смартфона."}),(0,i.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Содержание"}),(0,i.jsxs)(r.aV,{children:[(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#network-araound-as",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Сеть вокруг нас"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#ping-pong",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Пинг-понг"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#check-and-arp",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Шах и ARP"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#scream-by-udp",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Крик через UDP"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#rasberry-pi-and-android",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Rasberry Pi + Android"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#malinka",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Прокаченная малинка"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#lets-maui",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"MAUI в деле"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#fly",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Летим дальше!"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#links",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Это интересно"})})})})]}),(0,i.jsx)(r.xv,{id:"network-araound-as",title:!0,className:"mt-10 md:text",children:"Сеть вокруг нас"}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Информация витает вокруг нас. Компьютерные сети стали повседневной нормальностью. Не важно дома ли Вы, на работе или прогуливаетесь на улице - сеть будет рядом, вы постоянно подключены. Глобальная сеть, он же ",(0,i.jsx)("b",{children:"интернет"}),", доступна отовсюду: со смартфонов и компьютеров, из дома или за городом, на земле или в самолете. А количество подключенных к сети устройств имеет просто невероятное количество. Вот он, современный мир. Не зря же существует такое понятие как ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BD%D0%B5%D1%82_%D0%B2%D0%B5%D1%89%D0%B5%D0%B9",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"интернет вещей"})})}),"."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Давайте вернемся от высоких рассуждений к более практичным вопросам. Такое распостранение компьютерных сетей и устройств создают потребность в решении задач разработки ПО для таких устройств, их удобной интеграции, поиска и так далее. В большинстве языков программирования и платформ разработки имеются встроенные средства для работы с сетью. Платформа .NET и C# не являются исключениями."}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Сегодня мы коснемся этой темы, но лишь в малой части. Мы будем искать устройства в сети от самых простых методов в виде ",(0,i.jsx)("b",{children:"ping"}),"'а, широковещательных UDP-сообщений, запроса информации с маршрутизатора и другое. Это ни в коем случае не всеобъемлющая информация. Это старт для написания собственных программ в части поиска устройств."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Завершим свою работу мы на приложениях для Rasberry Pi и Android. Со смартфона наше приложение сможет находить Rasberry Pi в сети и делать к нему запросы. Время пришло, начинаем!"}),(0,i.jsx)(r.xv,{id:"ping-pong",title:!0,className:"mt-10 md:text",children:"Пинг-понг"}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Самый простой способ для поиска устройств в сети, который первым приодит на ум, это конечно же использование операции ",(0,i.jsx)("b",{children:"ping"}),". По своей сути, ",(0,i.jsx)("b",{children:"ping"})," - это средство для проверки доступности узла в сети через отправку к нему эхо-запроса ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/ICMP",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ICMP"})})}),". В .NET доступен класс ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.net.networkinformation.ping?view=net-8.0",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Ping"})})}),", который и позволяет делать отправку подобных запросов к узлам. Работа класса в целом аналогична одноименной утилите ",(0,i.jsx)("b",{children:"ping"})," в Windows и *.nix."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:['Ниже представлен пример простейшей программы, которая "пингует" диапазон адресов с ',(0,i.jsx)("b",{children:"192.168.88.1"})," по ",(0,i.jsx)("b",{children:"192.168.88.255"})," и выводит список адресов, для которых успешно прошла проверка доступности."]}),(0,i.jsx)(t.Z,{code:'\nusing System.Net;\nusing System.Net.NetworkInformation;\n\nstring addressBase = "192.168.88."; // Базовая часть адреса\nint startAddress = 1; // Начало диапазона сканирования адресов\nint endAddress = 255; // Окончание диапазона сканирования адресов\n\nList<IPAddress> detectedAddresses = new List<IPAddress>();\nPing ping = new Ping();\n\n// Сканируем последовательно адресов на доступность\nfor (int addressPart = startAddress; addressPart <= endAddress; addressPart++)\n{\n    string currentAddressAsString = $"{addressBase}{addressPart}";\n    IPAddress currentAddress = IPAddress.Parse(currentAddressAsString);\n    \n    // Отправляем ICMP-запрос с таймаутом в 1 секунду\n    var pingResult = ping.Send(currentAddress, 1000);\n    Console.WriteLine($"[{DateTime.Now}] {currentAddress}: {pingResult.Status}");\n\n    if (pingResult.Status == IPStatus.Success)\n    {\n        detectedAddresses.Add(currentAddress);\n    }\n}\n\n// Выводим результат сканирования в виде списка доступных узлов\nConsole.WriteLine();\nif (detectedAddresses.Count == 0)\n{\n    Console.WriteLine("Не найдено активных устройств.");\n}\nelse\n{\n    Console.WriteLine("Найдены устройства на следующих адресах:");\n    foreach (var detectedAddress in detectedAddresses)\n    {\n        // Пытаемся определить имя хоста по его адресу\n        string hostName;\n        try\n        {\n            hostName = Dns.GetHostEntry(detectedAddress)?.HostName ?? "<Неизвестно>";\n        }\n        catch\n        {\n            hostName = "<Неизвестно>";\n        }\n         \n        Console.WriteLine("- {0}: {1}", detectedAddress, hostName);\n    }\n}\nConsole.WriteLine();\n\nConsole.WriteLine("Для выхода нажмите любую клавишу...");\nConsole.ReadKey();\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"В программе сначала мы отправляем ICMP-пакеты на каждый из указанных адресов с таймаутом ожидания ответа в 1000 мс. Все узлы, для которых мы успешно получили ответ, сохраняем в список обнаруженных адресов. На последнем шаге выводим результат в виде обнаруженных узлов. Также для каждого адреса пытаемся получить DNS-имя."}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Пример вывода программы может быть следующим. Сначала в процессе сканирования выводим ход процесса пинга узлов:",(0,i.jsx)(t.Z,{code:"\n[28.06.2024 11:16:07] 192.168.88.1: Success\n[28.06.2024 11:16:08] 192.168.88.2: TimedOut\n[28.06.2024 11:16:09] 192.168.88.3: TimedOut\n[28.06.2024 11:16:10] 192.168.88.4: TimedOut\n[28.06.2024 11:16:11] 192.168.88.5: TimedOut\n[28.06.2024 11:16:12] 192.168.88.6: TimedOut\n[28.06.2024 11:16:13] 192.168.88.7: TimedOut\n[28.06.2024 11:16:14] 192.168.88.8: TimedOut\n[28.06.2024 11:16:15] 192.168.88.9: TimedOut\n[28.06.2024 11:16:16] 192.168.88.10: TimedOut\n[28.06.2024 11:16:16] 192.168.88.11: Success\n[28.06.2024 11:16:17] 192.168.88.12: TimedOut\n[28.06.2024 11:16:18] 192.168.88.13: TimedOut\n[28.06.2024 11:16:19] 192.168.88.14: TimedOut\n[28.06.2024 11:16:19] 192.168.88.15: Success\n...\n                    ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),"А на финальном шаге уже получим отчет по результатам:",(0,i.jsx)(t.Z,{code:"\nНайдены устройства на следующих адресах:\n- 192.168.88.1: router.lan\n- 192.168.88.11: yy-nix\n- 192.168.88.15: <Неизвестно>\n- 192.168.88.16: <Неизвестно>\n- 192.168.88.24: <Неизвестно>\n- 192.168.88.26: <Неизвестно>\n- 192.168.88.27: <Неизвестно>\n- 192.168.88.28: <Неизвестно>\n\nДля выхода нажмите любую клавишу...\n                    ",className:"my-5",language:"text",maxHeight:l.b.Unlimited})]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Особенностью работы класса ",(0,i.jsx)("b",{children:"Ping"})," являются ограничения, при которых утилита успешно отправит и получит ICMP-пакеты. В некоторых случаях наличие прокси-серверов, включенного NAT или брэндмауэров и некоторых других особенностей конфигурации сети могут препятствовать работе проверки доступности узлов. Поэтому полностью доверять результатом не приходится."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Также данный подход проверяет лишь доступность узла в сети и не позволяет проверить наличие или доступность служб более высокого уровня, таких как веб-сервера или другое ПО, использующее передачу данных по сети."}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Рассмотрим еще один способ поиска устройств в сети с помощью протокола определения адресов ARP."}),(0,i.jsx)(r.xv,{id:"check-and-arp",title:!0,className:"mt-10 md:text",children:"Шах и ARP"}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:[(0,i.jsx)(r.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/ARP",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ARP (Address Resolution Protocol)"})})})," - это протокол определения адреса, позволяющий определить ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/MAC-%D0%B0%D0%B4%D1%80%D0%B5%D1%81",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"MAC-адреса"})})})," других узлов по известным IP-адресам."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Ранее мы делали ",(0,i.jsx)("b",{children:"ping"})," диапазона адресов сети, а с помощью протокола ARP мы можем получить больше информации об узлах сети. Для .NET нет штатной возможности работы с протоколом ARP, но в сообществе создана библоитека ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/georg-jung/ArpLookup",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ArpLookup "})})})," за авторством ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/georg-jung",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Georg Jung"})})}),". Библиотека кроссплатформенная, что не может не радовать!"]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Хорошим примером использования данной библиотеки является приложение ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/giuliocomi/arp-scanner",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"arp-scanner"})})})," за авторством ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/giuliocomi",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"giuliocomi"})})}),". Приложение позволяет идентифицировать доступные узлы в локальной сети."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Пример работы ",(0,i.jsx)("b",{children:"arp-scanner"})," Вы можете видеть ниже:"]}),(0,i.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-06/detect-devices-with-charp/1. Arp-scanner.png",alt:"ARP-SCANNER",size:d.h2.FUll}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Перед этим приложение сканирует все IP-адреса в указанном при запуске диапазоне."}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Отличие данного подхода от простого ",(0,i.jsx)("b",{children:"ping"}),"'а в контексте обнаружения устройств заключается в том, что ICMP-пакеты часто блокируются брэндмауэром на узлах, в то время как ARP-запросы остаются доступными для использования. Поэтому шанс обнаружения активных устройств этим методом куда выше. Но не исключено, что администратор может и эти запросы заблокировать, тогда данный способ не сработает."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Напишем свою небольшую утилиту с использованием библиотеки ",(0,i.jsx)("b",{children:"ArpLookup"}),", чтобы показать пример использования более наглядно."]}),(0,i.jsx)(t.Z,{code:'\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing ArpLookup;\n\nstring addressBase = "192.168.88."; // Базовая часть адреса\nint startAddress = 1; // Начало диапазона сканирования адресов\nint endAddress = 255; // Окончание диапазона сканирования адресов\nbyte[] emptyPhysicalAddress = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nList<(IPAddress,PhysicalAddress)> detectedAddresses = new List<(IPAddress,PhysicalAddress)>();\n\n// Сканируем последовательно адреса на доступность\nfor (int addressPart = startAddress; addressPart <= endAddress; addressPart++)\n{\n    string currentAddressAsString = $"{addressBase}{addressPart}";\n    IPAddress currentAddress = IPAddress.Parse(currentAddressAsString);\n\n    // Отправляем ARP-запрос для получения MAC-адреса.\n    // Если MAC-адрес успешно получен, значит, узел в сети "живой"\n    PhysicalAddress? physicalAddress;\n    try\n    {\n        physicalAddress = Arp.Lookup(currentAddress);\n        \n        // Если получен пустой MAC-адрес,\n        // то присваиваем явно неопределенное значение\n        if (physicalAddress == null\n            || physicalAddress.GetAddressBytes().SequenceEqual(emptyPhysicalAddress)\n            || physicalAddress == PhysicalAddress.None)\n        {\n            physicalAddress = null;\n        }\n    }\n    catch\n    {\n        physicalAddress = null;\n    }\n    \n    // Отправляем ICMP-запрос с таймаутом в 1 секунду\n    if (physicalAddress != null)\n    {\n        detectedAddresses.Add(new ValueTuple<IPAddress, PhysicalAddress>(currentAddress,physicalAddress));\n        Console.WriteLine($"[{DateTime.Now}] {currentAddress}: {physicalAddress}");\n    }\n    else\n    {\n        Console.WriteLine($"[{DateTime.Now}] {currentAddress}: <Не доступен>");\n    }\n}\n\n// Выводим результат сканирования в виде списка доступных узлов\nConsole.WriteLine();\nif (detectedAddresses.Count == 0)\n{\n    Console.WriteLine("Не найдено активных устройств.");\n}\nelse\n{\n    Console.WriteLine("Найдены устройства на следующих адресах:");\n    foreach (var detectedAddress in detectedAddresses)\n    {\n        // Пытаемся определить имя хоста по его адресу\n        string hostName;\n        try\n        {\n            hostName = Dns.GetHostEntry(detectedAddress.Item1)?.HostName ?? "<Неизвестно>";\n        }\n        catch\n        {\n            hostName = "<Неизвестно>";\n        }\n         \n        Console.WriteLine("- {0}: {1}: {2}", detectedAddress.Item1, detectedAddress.Item2, hostName);\n    }\n}\nConsole.WriteLine();\n\nConsole.WriteLine("Для выхода нажмите любую клавишу...");\nConsole.ReadKey();\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["В целом программа очень похожа на версию из раздела про ",(0,i.jsx)("b",{children:"ping"}),", которую мы создали в предыдущем разделе. Главное отличие здесь - это использование ",(0,i.jsx)("b",{children:"ArpLoockup"})," вместо класса ",(0,i.jsx)("b",{children:"Ping"}),", где мы отправляем запрос."]}),(0,i.jsx)(t.Z,{code:"\n// Отправляем ARP-запрос для получения MAC-адреса.\nphysicalAddress = Arp.Lookup(currentAddress);\n                ",className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["В процессе сканирования сети будет выводиться прогресс операции вида:",(0,i.jsx)(t.Z,{code:"\n[28.06.2024 13:31:11] 192.168.88.1: 2CC81B4A9F8A\n[28.06.2024 13:31:18] 192.168.88.2: <Не доступен>\n[28.06.2024 13:31:19] 192.168.88.3: <Не доступен>\n[28.06.2024 13:31:20] 192.168.88.4: <Не доступен>\n[28.06.2024 13:31:21] 192.168.88.5: <Не доступен>\n[28.06.2024 13:31:21] 192.168.88.6: <Не доступен>\n[28.06.2024 13:31:22] 192.168.88.7: <Не доступен>\n[28.06.2024 13:31:23] 192.168.88.8: <Не доступен>\n[28.06.2024 13:31:24] 192.168.88.9: <Не доступен>\n[28.06.2024 13:31:24] 192.168.88.10: <Не доступен>\n[28.06.2024 13:31:24] 192.168.88.11: <Не доступен>\n[28.06.2024 13:31:25] 192.168.88.12: <Не доступен>\n[28.06.2024 13:31:26] 192.168.88.13: <Не доступен>\n[28.06.2024 13:31:27] 192.168.88.14: <Не доступен>\n[28.06.2024 13:31:27] 192.168.88.15: 2CC81B4A9F89\n                    ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),"По окончанию работы утилиты будет выведен финальный отчет:",(0,i.jsx)(t.Z,{code:"\nНайдены устройства на следующих адресах:\n- 192.168.88.1: 2CC8********: router.lan\n- 192.168.88.15: 2CC8********: <Неизвестно>\n- 192.168.88.16: CAC9********: <Неизвестно>\n- 192.168.88.24: B060********: <Неизвестно>\n- 192.168.88.26: 7089********: <Неизвестно>\n- 192.168.88.27: 82D1********: <Неизвестно>\n- 192.168.88.28: B887********: <Неизвестно>\n- 192.168.88.35: 000C********: fiastoolset.yy.corp\n- 192.168.88.82: 18C0********: <Неизвестно>\n                    ",className:"my-5",language:"text",maxHeight:l.b.Unlimited})]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Фактически мы получили тот же результат, что и при использовании класса ",(0,i.jsx)("b",{children:"Ping"}),", но альтернативным путем."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Будем честными, искать устройства подобными методами можно, но только тогда, когда найти их нужно только одной стороне. Но что, если устройству нужно, чтобы его нашли?"}),(0,i.jsx)(r.xv,{id:"scream-by-udp",title:!0,className:"mt-10 md:text",children:"Крик через UDP"}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Устройство может самостоятельно сигнализировать в локальной сети, что оно включено и готово к работе. Самый распостраненный вариант реализации такого поведения это ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/framework/network-programming/using-udp-services",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"широковещательные сообщения UDP"})})}),"."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Платформа .NET имеет собственный класс ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.net.sockets.udpclient?view=net-8.0",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"UdpClient"})})})," для удобной работы с протоколом UDP, в том числе и для отправки и приема широковещательных сообщений."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Сделаем простое приложение для отправки и приема широковещательных сообщений UDP, причем в контексте одного узла и приложения. Это просто демонстрационный пример."}),(0,i.jsx)(t.Z,{code:'\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\n\n// Адрес группы для многоадресной рассылки\nIPAddress broadcastAddress = IPAddress.Parse("239.255.255.255");\n// Порт для отправки и прослушивания сообщений\nint localPort = 25432;\n\n// Запускаем в фоне задание для получения сообщений\nTask.Run(ReceiveMessageAsync);\n// Запускаем в фоне задание для отправки сообщений\nTask.Run(SendMessageAsync);\n\n// Отправка сообщений в группу\nasync Task SendMessageAsync()\n{\n    // Создаем клиента для отпрвки\n    using var sender = new UdpClient();\n    // И точку подключения для отправки\n    var endpoint = new IPEndPoint(broadcastAddress, localPort);\n    \n    while (true)\n    {\n        // Формируем сообщение\n        string messageContent = $"[{DateTime.Now}] Hello from UDP";\n        byte[] data = Encoding.UTF8.GetBytes(messageContent);\n        \n        // Отправляем в группу\n        await sender.SendAsync(data, endpoint);\n        Console.WriteLine($"(Отправлено): {messageContent}");\n        \n        // Ждем до следующей отправки\n        await Task.Delay(1000);\n    }\n}\n\n// Получение сообщений из группы\nasync Task ReceiveMessageAsync()\n{\n    // Создаем клиента для получения сообщений\n    using var receiver = new UdpClient(localPort);\n    // Присоединяемся к группе многоадресной рассылки\n    receiver.JoinMulticastGroup(broadcastAddress);\n    // Отключаем получение собственных сообщений\n    receiver.MulticastLoopback = false;\n    while (true)\n    {\n        // Получаем сообщение при появлении\n        var result = await receiver.ReceiveAsync();\n        \n        // Отображаем содержимое\n        string messageContent = Encoding.UTF8.GetString(result.Buffer);\n        Console.WriteLine($"(Получено): {messageContent}");\n    }\n}\n\nConsole.WriteLine("Для выхода нажмите любую клавишу...");\nConsole.ReadKey();\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Здесь мы имеем два асинхронных метода ",(0,i.jsx)("b",{children:"SendMessageAsync"})," для отправки широковещательных сообщений в группу и ",(0,i.jsx)("b",{children:"ReceiveMessageAsync"})," для их приема. Перед их запуском инициализируются два важных параметра для рассылки и приема сообщений:",(0,i.jsxs)(r.aV,{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"localPort"})," - порт, на который будут отправляться сообщения и, соответственно, прослушиваться сообщения для приема."]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"broadcastAddress"})," - адрес группы многоадресной рассылки. Это служебный адрес, который должен указываться в диапазоне от ",(0,i.jsx)("b",{children:"224.0.0.0"})," до ",(0,i.jsx)("b",{children:"239.255.255.255"}),". Если передать другой адрес, либо если маршрутизатор не поддерживает групповые рассылки, то будет получено исключение ",(0,i.jsx)("b",{children:"SocketException"}),"."]})]})]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["При отправке сообщений инициализируется UDP-клиент в виде объекта класса ",(0,i.jsx)("b",{children:"UdpClient"})," с точкой подключения ",(0,i.jsx)("b",{children:"IPEndPoint"})," с указанным портом и адресом группы многоадресной рассылки."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["При получении сообщений инициализируется UDP-клиент также в виде объекта класса ",(0,i.jsx)("b",{children:"UdpClient"}),", но в этот раз выполняется присоединение к группе многоадресной рассылки с помощью метода ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.net.sockets.udpclient.joinmulticastgroup?view=net-8.0",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"JoinMulticastGroup"})})}),". Стоит отметить, что для отправки сообщений в группу нет необходимости выполнять присоединение к ней методом ",(0,i.jsx)("b",{children:"JoinMulticastGroup"}),", достаточно того, чтобы в точке подключения адрес совпадал с адресом в точке подключения клиента, который эти сообщения отправляет."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Для удаления из группы нужно вызывать метод ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/dotnet/api/system.net.sockets.udpclient.dropmulticastgroup?view=net-8.0",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"DropMulticastGroup"})})}),", но в нашем примере в этом нет необходимости."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["При запуске приложения мы получим примерно такой вывод:",(0,i.jsx)(t.Z,{code:"\n(Отправлено): [28.06.2024 15:20:57] Hello from UDP\n(Получено): [28.06.2024 15:20:57] Hello from UDP\n(Отправлено): [28.06.2024 15:20:58] Hello from UDP\n(Получено): [28.06.2024 15:20:58] Hello from UDP\n(Отправлено): [28.06.2024 15:20:59] Hello from UDP\n(Получено): [28.06.2024 15:20:59] Hello from UDP\n(Отправлено): [28.06.2024 15:21:00] Hello from UDP\n(Получено): [28.06.2024 15:21:00] Hello from UDP\n                ",className:"my-5",language:"text",maxHeight:l.b.Unlimited})]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Таким образом, для задач обнаружения устройств в сети, если одно устройство должно найти другое, широковещательные сообщения UDP являются практически идеальным средством."}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Тем более в теле сообщения можно отправлять любую необходимую информацию, чтобы получатель мог корректно идентифицировать устройство и сделать нужные действия. Ниже мы рассмотрим использование данного подхода на примере создания сервиса для RasberryPi и приложения для Android, которое будет этот сервис находить в сети. Итак, поехали дальше!"}),(0,i.jsx)(r.xv,{id:"rasberry-pi-and-android",title:!0,className:"mt-10 md:text",children:"Rasberry Pi + Android"}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Итак, у нас будет расширенный пример двух приложений. Первое - сервис на ASP.NET Core под *.nix (хотя и на Windows тоже будет работать), который мы запустим на устройстве Rasberry Pi. А также будет клиентское приложение для Android на базе",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/maui/what-is-maui?view=net-maui-8.0",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"MAUI"})})}),", которое будет выполнять поиск устройства в той же сети, что и смартфон, и отправлять на него некоторые запросы."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Мы остановимся лишь на основных моментах, пока будем создавать эти приложения. Полный пример и вся кодовая база будет доступна в ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"репозитории YPermitin.ExternalDevices"})})}),' на GitHub. Чтобы пример остался "как есть", без изменений с течением времени, пример был сохранен в отдельной ветке',(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/tree/post-detect-devices-with-csharp",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"post-detect-devices-with-csharp"})})}),"."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:'Переходим к делу, сначала создадим сервис для "малинки".'}),(0,i.jsx)(r.xv,{id:"malinka",title:!0,className:"mt-10 md:text",children:"Прокаченная малинка"}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["На Rasberry Pi мы заблоговременно установили Ubuntu. Этот процесс здесь расписывать смысла нет, т.к. вопрос выходит за рамки темы статьи. Вы можете узнать всю нужную информацию ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://ubuntu.com/download/raspberry-pi",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"на официальном сайте"})})}),". Фактически, вместо Rasberry Pi может быть любая машина с Ubuntu, в том числе обычный ПК."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Созданный сервис на ASP.NET Core мы публикуем как любой другой сервис на *.nix. Процесс публикации мы также рассматривать не будем. При необходимости весь процесс установки и настройки с подробным разбором всех шагов Вы можете можете узнать в статье ",(0,i.jsx)(r.e9,{newTab:!0,href:"/pages/blog/.NET/2024-03/deploy-asp-net-core-on-linux.tsx",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:'"Развертывание ASP.NET Core приложений на Ubuntu Linux"'})})}),"."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["В решении сам сервис представлен в виде проекта ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/tree/post-detect-devices-with-csharp/Web/YPermitin.ExternalDevices.ManagementService",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"YPermitin.ExternalDevices.ManagementService"})})}),", который является REST-сервисом на базе ASP.NET Core и использует платформу .NET 8 версии. В контексте нашего примера нас интересуют следующие части этого приложения:",(0,i.jsxs)(r.aV,{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/blob/post-detect-devices-with-csharp/Web/YPermitin.ExternalDevices.ManagementService/Services/NetworkDiscoveryHostedService.cs",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"NetworkDiscoveryHostedService"})})})," - это фоновая задача, которая раз в 10 секунд отправляет широковещательное сообщение UDP, чтобы клиентские приложения могли его обнаружить.",(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Для этого используется метод ",(0,i.jsx)("b",{children:"SendBroadcastMessage"})," из библиотеки ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/blob/post-detect-devices-with-csharp/Libs/YPermitin.ExternalDevices.NetworkUtils/DeviceDetector.cs",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"DeviceDetector"})})}),", реализующей рассылку и прием многоадресных сообщений UDP, о которых шла речь в раздеах выше. Если Вы посмотрите исходный код библиотеки ",(0,i.jsx)("b",{children:"DeviceDetector"}),", то увидите ту же самую логику создания и инициализации класса ",(0,i.jsx)("b",{children:"UdpClient"}),", в том числе присоединение его к группе методом ",(0,i.jsx)("b",{children:"JoinMulticastGroup"}),"."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Единственным большим отличием будет метод приема сообщений, который реализован через ",(0,i.jsx)("b",{children:"StartSearch"}),". В нем мы запускаем операцию приема через метод ",(0,i.jsx)("b",{children:"ReceiveAsync"}),", а затем ожидаем получения сообщений с указанным текстовым содержимым. При получении каждого сообщения срабатывает событие ",(0,i.jsx)("b",{children:"onDeviceDetected"}),", оповещающее вызывающий код о найденном устройстве."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Весь описанный процесс выполняется до тех пор, пока не будет отменен явно через токен отмены операции (передается в качестве аргумента метода), или по достижении таймаута из аргумента ",(0,i.jsx)("b",{children:"timeoutMs"}),"."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["В текущем сервисе мы используем только метод отправки сообщений ",(0,i.jsx)("b",{children:"SendBroadcastMessage"}),", а метод обнаружения сообщений",(0,i.jsx)("b",{children:"StartSearch"})," будет использоваться в клиентском приложении для Android. О нем речь будет ниже."]})]}),(0,i.jsxs)("li",{children:[(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/blob/post-detect-devices-with-csharp/Web/YPermitin.ExternalDevices.ManagementService/Controllers/ServiceInfoController.cs",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ServiceInfoController"})})})," - контроллер для реализации метода REST API с целью возвращения базовой информации о сервисе, а именно:",(0,i.jsxs)(r.aV,{children:[(0,i.jsx)("li",{children:"Hostname - имя хоста сервиса."}),(0,i.jsx)("li",{children:"HostDateUTC - текущая дата по UTC."})]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Здесь нет чего-то особенного. Фактически метод используется лишь для проверки связи с сервисом со стороны клиентского приложения."})]})]})]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Остальные части сервиса явно не относятся к теме статьи. Например, там есть часть, отвечающая за проверку списка WiFi-сетей, доступных для устройства. Или интеграция с DBus для *.nix систем. Плюс некоторые другие вещи."}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"При успешном запуске сервиса на Rassbery Pi Вы увидите примерно такой вывод:"}),(0,i.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-06/detect-devices-with-charp/2. Запуск сервиса на Rasberry Pi.png",alt:"Запуск сервиса на Rasberry Pi",size:d.h2.FUll}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"У Вашего устройства может не быть модуля WIFi, тогда сканер сетей работать не будет и в большинстве случаев будут видны только логи о рассылке широковещательных сообщений UDP. Ничего страшного в этом нет, все-таки мы пришли сюда не по этой теме."}),(0,i.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-06/detect-devices-with-charp/3. Rasberry Pi с WiFi модулем.jpg",alt:"Rasberry Pi с WiFi модулем",size:d.h2.MEDIUM}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Итак, Rasberry Pi с опубликованным сервисом у нас готовы и подключены к сети. Теперь перейдем к мобильной разработке."}),(0,i.jsx)(r.xv,{id:"lets-maui",title:!0,className:"mt-10 md:text",children:"MAUI в деле"}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:[(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/maui/what-is-maui?view=net-maui-8.0",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"MAUI"})})})," - это кросплатформенная среда для создания собственных мобильных и классических приложений на платформе .NET (C#). Для использования той же кодовой базы и библиотек, что и для серверного приложения, а также для простоты примера мы будем использовать именно MAUI, чтобы создать мобильное приложение."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["В решении само приложение представлено в проекте ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/tree/post-detect-devices-with-csharp/Apps/YPermitin.ExternalDevices.YPED",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"YPermitin.ExternalDevices.YPED"})})}),"."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["К проекту подключена библиотека ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/blob/post-detect-devices-with-csharp/Libs/YPermitin.ExternalDevices.NetworkUtils/DeviceDetector.cs",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"DeviceDetector"})})}),", которую мы уже использовали в сервисе на Rasberry Pi. На этот раз из этой библиотеки мы будем использовать метод ",(0,i.jsx)("b",{children:"StartSearch"})," для поиска устройств в сети."]}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:[(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/blob/post-detect-devices-with-csharp/Apps/YPermitin.ExternalDevices.YPED/MainPage.xaml.cs",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"В исходном коде главной страницы"})})})," приложения мы можем увидеть инициализацию объекта ",(0,i.jsx)("b",{children:"DeviceDetector"})," при создании страницы. Вызов метода ",(0,i.jsx)("b",{children:"StartSearch"})," выполняется при нажатии кнопки ",(0,i.jsx)("b",{children:'"Обнаружить устройства"'}),", после чего в течении 60 секунд приложение слушает сеть на наличие широковещательных сообщений UDP. При этом присылаемые данные должны подходить по формату."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Как только сообщение нужного формата получено, из него получается информация о найденном устройстве и выводится на экран. Вот как это выглядит."}),(0,i.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-06/detect-devices-with-charp/4. Android. Поиск устройств.gif",alt:"Android. Поиск устройств",size:d.h2.XS}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["При нажатии на элемент списка найденных устройств, приложение отправки HTTP-запрос к API найденного сервиса для получения базовой информации (вызов метода контроллера ",(0,i.jsx)("b",{children:"ServiceInfoController"}),", о котором речь шла выше). Смотри событие ",(0,i.jsx)("b",{children:"DeviceItemTapped"})," на ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.ExternalDevices/blob/post-detect-devices-with-csharp/Apps/YPermitin.ExternalDevices.YPED/MainPage.xaml.cs",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"главной странице"})})}),"."]}),(0,i.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-06/detect-devices-with-charp/5. Android. Запрос к устройству.gif",alt:"Android. Запрос к устройству",size:d.h2.XS}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Таким образом, мы создали мобильное Android-приложение, используя ту же самую кодовую базу на языке C#, что используется и в сервисе для Rasberry Pi. Наше клиентское приложение находит устройства в сети и может отправлять к нему запросы. Еще бонусом в приложении добавлена функция определиня внешнего IP-адреса в сети интернет через обращение к API ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://api.tinydevtools.ru",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"api.tinydevtools.ru"})})}),", но к теме статьи это мало относится."]}),(0,i.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-06/detect-devices-with-charp/6. Android. Мой IP.gif",alt:"Android. Мой IP",size:d.h2.XS}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Теперь обнаружить устройста в сети не составит труда!"}),(0,i.jsx)(r.xv,{id:"fly",title:!0,className:"mt-10 md:text",children:"Летим дальше!"}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Поиск устройств в сети не такая уж и редкая задача. Думаю, многие выполняли сопряжение со смартфоном гарнитуры или часов. Все это из той же области."}),(0,i.jsxs)(r.xv,{textAlign:d.PH.JUSTIFY,children:["Сегодня мы рассмотрели поиск устройств через ",(0,i.jsx)("b",{children:"ping"})," (т.е. через ICMP-пакеты), через протокол ARP, широковещательные сообщения UDP, а также рассмотрели пример приложений для Rasberry Pi и Android."]}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Но найти устройство это лишь начало, дальше нужно им управлять. А это уже другая история..."}),(0,i.jsx)(r.xv,{textAlign:d.PH.JUSTIFY,children:"Спасибо, что дочитали! Хорошего вам дня и успехов в делах!"}),(0,i.jsx)(r.xv,{id:"links",title:!0,className:"mt-10 md:text",children:"Это интересно"}),(0,i.jsxs)(r.aV,{children:[(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{newTab:!0,href:"https://www.cheatengine.org/",children:(0,i.jsx)("u",{children:(0,i.jsx)("b",{children:"YPermitin.ExternalDevices - репозиторий с примером приложения."})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{newTab:!0,href:"/pages/blog/.NET/2024-03/deploy-asp-net-core-on-linux.tsx",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Развертывание ASP.NET Core приложений на Ubuntu Linux"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/dotnet/api/system.net.sockets.udpclient?view=net-8.0",children:(0,i.jsx)("u",{children:(0,i.jsx)("b",{children:"UdpClient Class"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{newTab:!0,href:"https://metanit.com/sharp/net/5.2.php",children:(0,i.jsx)("u",{children:(0,i.jsx)("b",{children:"Широковещательная рассылка"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/georg-jung/ArpLookup",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ArpLookup - библиотека для .NET по отправке запросов ARP"})})})})]})]})},7855:function(e,n,s){"use strict";var i,r;s.d(n,{b:function(){return i}}),(r=i||(i={})).Min="350px",r.Standard="700px",r.Large="1000x",r.Unlimited=""},4313:function(e,n,s){"use strict";var i=s(7340),r=s(5893),t=s(7294),d=s(4965),l=s(1240),c=s(1686),a=s(7855);function x(){let e=(0,i._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return x=function(){return e},e}function h(){let e=(0,i._)(["\n        max-height: ","\n    "]);return h=function(){return e},e}n.Z=e=>{let{code:n,className:i,language:o,maxHeight:j=a.b.Standard}=e;(void 0!==s.g?s.g:window).Prism=d.p1,s(1354),s(9016),s(5266),s(2927),s(1315),s(7874),s(6862);let u=null!=j?j:a.b.Standard,m=c.ZP.pre(x()),b=(0,c.ZP)(m)(h(),u);return(0,r.jsx)("div",{className:(0,l.GF)("bg-blue-500 md:p-1 p-2",i),children:(0,r.jsx)("div",{className:"shadow-lg",children:(0,r.jsx)(d.y$,{theme:d.np.vsDark,code:n.trim(),language:null!=o?o:o="tsx",children:e=>{let{className:n,style:s,tokens:i,getLineProps:d,getTokenProps:l}=e;return(0,r.jsx)(b,{className:n,style:s,children:i.map((e,n)=>(0,t.createElement)("div",{...d({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,t.createElement)("span",{...l({token:e,key:n}),key:Math.random()}))))})}})})})}},4853:function(e,n,s){"use strict";s.d(n,{Ee:function(){return l},Xg:function(){return t},Y7:function(){return h},aV:function(){return a},e9:function(){return x},o_:function(){return o},tf:function(){return j},ty:function(){return c},xv:function(){return d}});var i=s(5152),r=s.n(i);let t=r()(()=>Promise.all([s.e(9686),s.e(4738),s.e(4838),s.e(1664),s.e(8765)]).then(s.bind(s,8765)),{loadableGenerated:{webpack:()=>[8765]}}),d=r()(()=>Promise.all([s.e(9511),s.e(935)]).then(s.bind(s,935)),{loadableGenerated:{webpack:()=>[935]}}),l=r()(()=>Promise.all([s.e(328),s.e(7651)]).then(s.bind(s,7651)),{loadableGenerated:{webpack:()=>[7651]}}),c=r()(()=>Promise.all([s.e(9686),s.e(6979)]).then(s.bind(s,6979)),{loadableGenerated:{webpack:()=>[6979]}}),a=r()(()=>Promise.all([s.e(4159),s.e(7355)]).then(s.bind(s,7355)),{loadableGenerated:{webpack:()=>[7355]}}),x=r()(()=>Promise.all([s.e(1664),s.e(3220)]).then(s.bind(s,3220)),{loadableGenerated:{webpack:()=>[3220]}});r()(()=>s.e(3140).then(s.bind(s,3140)),{loadableGenerated:{webpack:()=>[3140]}});let h=r()(()=>Promise.all([s.e(2004),s.e(736)]).then(s.bind(s,736)),{loadableGenerated:{webpack:()=>[736]}}),o=r()(()=>Promise.all([s.e(8331),s.e(2877),s.e(2660),s.e(9718),s.e(5090),s.e(9606)]).then(s.bind(s,9606)),{loadableGenerated:{webpack:()=>[9606]}}),j=r()(()=>Promise.all([s.e(8331),s.e(1664),s.e(2660),s.e(9718),s.e(8496)]).then(s.bind(s,8496)),{loadableGenerated:{webpack:()=>[8496]}})}},function(e){e.O(0,[6443,2888,9774,179],function(){return e(e.s=7710)}),_N_E=e.O()}]);