(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7766],{2439:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/.NET/2024-07/processes-under-control",function(){return s(4625)}])},4625:function(e,n,s){"use strict";s.r(n);var t=s(5893),i=s(4853);s(7294);var r=s(4313),o=s(9209),l=s(7855);n.default=()=>(0,t.jsxs)(i.Xg,{blogcentered:!0,children:[(0,t.jsxs)(i.xv,{textAlign:o.PH.RIGHT,quote:!0,children:["Контроль - это очень опасная страсть, если вы зайдёте слишком далеко,",(0,t.jsx)("br",{}),"то рискуете полностью его потерять.",(0,t.jsx)("br",{}),"(с) Эрика Стрэйндж"]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"При разработке собственных решений не редко возникает потребность в запуске дополнительных исполняемых процессов. Не всегда эти процессы представлены собственными приложениями. Часто это внешние программы, доступа к исходному коду которых у нас нет. Поэтому нам приходится адаптироваться."}),(0,t.jsx)(i.xv,{title:!0,className:"mt-10 md:text",children:"Содержание"}),(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#start",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Суть вопроса"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#source",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Исходный материал"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#good-and-bad",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Просто и плохо"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#are-you-ok",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Завис или не завис?"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#terminal-output",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Читаем вывод консоли"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#env-res-and-so-on",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Окружение, ресурсы и так далее"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#ideal-control",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Идеальный контроль"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#the-end",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Мысли напоследок"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{href:"#links",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Это интересно"})})})})]}),(0,t.jsxs)("section",{id:"section-start",children:[(0,t.jsx)(i.xv,{id:"start",title:!0,className:"mt-10 md:text",children:"Суть вопроса"}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Сегодня и здесь мы будем запускать процессы. Свои и не только. Но самое главное - мы будем контролировать их работу и разбирать их состояние. Запустить процесс дело не трудное, но контролировать его и убедиться, что он не завис - дело совсем непростое."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Мы пройдемся от самых простых и плохих примеров, до самых сложных. Здесь нет готовых и универсальных решений, только указание направления для поисков нужных ответов."}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["В качестве подопытного стороннего приложения мы будем использовать утилиту ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/tools/bcp-utility",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:'"Bulk Copy Insert" (BCP.exe)'})})}),", используемую для массовой выгрузки / загрузки данных из баз данных SQL Server. Сама утилита устанавливается вместе с другими компонентами SQL Server, подробнее читайте по ссылке. Но и этим примеры не ограничатся."]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"И хоть примеры будут сделаны в среде Windows, фактически информация актуальная как при разработке приложений для *.nix / MaxOS. Итак, поехали!"})]}),(0,t.jsxs)("section",{id:"section-source",children:[(0,t.jsx)(i.xv,{id:"source",title:!0,className:"mt-10 md:text",children:"Исходный материал"}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Для всех последующих примеров с утилитой ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/tools/bcp-utility",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:'"Bulk Copy Insert" (BCP.exe)'})})}),' мы создадим базу "TestDB" со следующими объектами:']}),(0,t.jsx)(r.Z,{code:"\nCREATE TABLE [dbo].[Programms](\n	[Id] [int] IDENTITY(1,1) NOT NULL,\n	[Name] [nvarchar](50) NULL,\n	[AuhthorName] [nvarchar](50) NULL,\n	[Price] [int] NULL,\nPRIMARY KEY CLUSTERED \n(\n	[Id] ASC\n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]\n) ON [PRIMARY]\n                ",className:"my-5",language:"sql",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Таблица ",(0,t.jsx)("b",{children:"Programms"})," содержит некоторую сгенерированную информацию о программах. Чтобы создать достаточный объем данных для тестов, заполним ее следующим скриптом, добавив порядка 10 миллионов записей."]}),(0,t.jsx)(r.Z,{code:"\nDeclare @count int\nSet @count = 1\n\nDECLARE \n	@Name nvarchar(50),\n	@AuhthorName nvarchar(50),\n	@Price int;\n\nWhile @count <= 9000000\nBegin \n\n   Select @Name = 'Prog - ' + CAST(Rand()  AS nvarchar(max)) + ' - ' + CAST(GETDATE() AS nvarchar(max));\n   Select @AuhthorName = 'Dev - ' + CAST(Rand()  AS nvarchar(max));\n   Select @Price = Rand() * 100;\n\n\n   Insert Into [dbo].[Programms] values (@Name, @AuhthorName, @Price)\n   Print @count\n   Set @count = @count + 1\nEnd\n                ",className:"my-5",language:"sql",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Допустим, нам нужно выгрузить эти данные в файл, чтобы потом загрузить на другом сервере в таблицу аналогичной структуры. Утилита BCP для этого дела подходящий вариант."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"В случае, если бы мы запускали утилиту полностью вручную, то команда выгрузки данных в файл выглядела бы следующим образом:"}),(0,t.jsx)(r.Z,{code:'\n# Команда имеет следующие параметры:\n#   > bcp - имя утилиты для запуска.\n#   > dbo.Programms - имя таблицы для выгрузки данных.\n#   > out - это направление выгрузки. В данном случае выгрузка ИЗ базы В файл. \n#       Путь к файлу указан после этого параметра.\n#   > -d - имя базы.\n#   > -l - таймаут установки соединения. В примере 15 секунд.\n#   > -P - пароль пользователя для входа.\n#   > -S - имя инстанса SQL Server для подключения.\n#   > -U - имя пользователя. В нашем примере это пользователь SA.\n#   > -N - признак использования нативных типов данных базы данных для выгрузки.\n#       О некоторых случаях значительно ускоряет операции выгрузки / загрузки данных.\n#   > -o - путь к файлу вывода полного лога работы утилиты BCP.\n#\nbcp dbo.Programms out "C:\\Temp\\BCP\\Programms.bak" \n    -d TestDB \n    -l 15 \n    -P "<ПарольПользователя>" \n    -S "SRV-SQL-1" \n    -U "sa" \n    -N  \n    -o "C:\\Temp\\BCP\\Programms_Export.out"\n                ',className:"my-5",language:"bash",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["В результате мы получим файл ",(0,t.jsx)("b",{children:'"C:\\Temp\\BCP\\Programms.bak"'})," c данными исходной таблицы. А по пути ",(0,t.jsx)("b",{children:'"C:\\Temp\\BCP\\Programms_Export.out"'})," можно посмотреть подробный лог работы утилиты. Пример части вывода в файл лога:"]}),(0,t.jsx)(r.Z,{code:"\nStarting copy...\n1000 rows successfully bulk-copied to host-file. Total received: 1000\n1000 rows successfully bulk-copied to host-file. Total received: 2000\n1000 rows successfully bulk-copied to host-file. Total received: 3000\n1000 rows successfully bulk-copied to host-file. Total received: 4000\n1000 rows successfully bulk-copied to host-file. Total received: 5000\n1000 rows successfully bulk-copied to host-file. Total received: 6000\n1000 rows successfully bulk-copied to host-file. Total received: 7000\n1000 rows successfully bulk-copied to host-file. Total received: 8000\n1000 rows successfully bulk-copied to host-file. Total received: 9000\n1000 rows successfully bulk-copied to host-file. Total received: 10000\n1000 rows successfully bulk-copied to host-file. Total received: 11000\n1000 rows successfully bulk-copied to host-file. Total received: 12000\n...\n                ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Если бы мы выполняли команду, наоборот, для импорта данных из файла в, например, таблицу ",(0,t.jsx)("b",{children:"dbo.Programms_New"})," той же структуры, то выглядела бы она следующим образом:"]}),(0,t.jsx)(r.Z,{code:'\n# Команда имеет следующие параметры:\n#   > bcp - имя утилиты для запуска.\n#   > dbo.Programms_New - имя таблицы для загрузки данных.\n#   > in - это направление загрузки. В данном случае загрузка ИЗ файла В базу. \n#       Путь к файлу указан после этого параметра.\n#   > -b - размер пакета для загрузки данных. В примере 10000 записей.\n#   > -d - имя базы.\n#   > -l - таймаут установки соединения. В примере 15 секунд.\n#   > -P - пароль пользователя для входа.\n#   > -S - имя инстанса SQL Server для подключения.\n#   > -U - имя пользователя. В нашем примере это пользователь SA.\n#   > -N - признак использования нативных типов данных базы данных для загрузки.\n#       О некоторых случаях значительно ускоряет операции выгрузки / загрузки данных.\n#   > -o - путь к файлу вывода полного лога работы утилиты BCP.\n#\nbcp dbo.Programms_New in "C:\\Temp\\BCP\\Programms.bak" \n    -b 10000 \n    -d TestDB \n    -l 15 \n    -P "<ПарольПользователя>" \n    -S "SRV-SQL-1" \n    -U "sa" \n    -N  \n    -o "C:\\Temp\\BCP\\Programms_Import.out"\n                ',className:"my-5",language:"bash",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"В целом, логика работы команды такая же, как и при выгрузке, за исключением направления выгрузки и параметра размера пакета."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Как итог, у нас есть тестовая база данных и команды для утилиты BCP, которые нам нужно выполнять программно. Хоть мы привели две команды - для выгрузки и для загрузки, в примерах мы будем использовать только первую, т.к. цель у нас это работа с процессами, а не манипуляции с данными."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Вперед и за дело!"})]}),(0,t.jsxs)("section",{id:"section-good-and-bad",children:[(0,t.jsx)(i.xv,{id:"good-and-bad",title:!0,className:"mt-10 md:text",children:"Просто и плохо"}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Сначала рассмотрим самое топорное решение для запуска приложения. Ну, если честно, он не совсем топорное, но что просто так точно. В .NET есть встроенный системный класс ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Process"})})}),", который предоставляет доступ к локальным и удаленным процессам, в том числе и для управления ими. Ничто не мешает нам запустить нужный процесс через него."]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Ниже представлен пример запуска команды экспорта через утилиту BCP:"}),(0,t.jsx)(r.Z,{code:'\n// Параметры запуска утилиты\nstring userName = "sa";\nstring userPassword = "<ПарольПользователя>";\nstring objectName = "dbo.Programms";\nstring uploadFilePath = "C:\\Temp\\BCP\\Programms.bak";\nstring databaseName = "TestDB";\nstring instanceName = "SRV-SQL-1";\nstring logFilePath = "C:\\Temp\\BCP\\Programms_Export.out";\n\n// Инициализация объекта с параметрами запуска приложения\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.WindowStyle = ProcessWindowStyle.Hidden;\nstartInfo.FileName = "bcp";\nstartInfo.Arguments =\n    $"{objectName} out "{uploadFilePath}" " +\n    $"-d {databaseName} " +\n    "-l 15 " +\n    $"-P "{userPassword}" " +\n    $"-S "{instanceName}" " +\n    $"-U "{userName}" " +\n    "-N " +\n    $"-o "{logFilePath}"";\n\n// Запуск процесса\nusing (Process process = Process.Start(startInfo))\n{\n    // ... и ожидание завершения приложения\n    // Примечание: можно ожидать завершения таким способом, \n    // но тогда мы не сможем интерактивно выводить\n    // сообщение об ожидании process.WaitForExit()\n    while (!process.HasExited)\n    {\n        Console.WriteLine($"[{DateTime.Now}]: Ожидаем завершения...");\n        Thread.Sleep(1000);\n    }\n}\nConsole.WriteLine($"[{DateTime.Now}]: Работа процесса завершена.");\n\n// Выводим на экран последние 10 строк лога работы утилиты\nConsole.WriteLine($"[{DateTime.Now}]: Вывод работы программы (последние 10 строк):");\nConsole.WriteLine("<<<<<");\n\nif (File.Exists(logFilePath))\n{\n    var lastOutputLines = File.ReadAllLines(logFilePath)\n        .TakeLast(10)\n        .ToList();\n    foreach (var line in lastOutputLines)\n    {\n        Console.WriteLine(line);\n    }\n}\nConsole.WriteLine(">>>>>");\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Тестовая программа сначала задает параметры запуска утилиты BCP, а после формирует параметры запуска процесса через класс ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.processstartinfo",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"ProcessStartInfo"})})}),", который задает набор параметров для запуска."]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Затем выполняется запуск непосредственно процесса через класс ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Process"})})})," вызовом метода ",(0,t.jsx)("b",{children:"Start"})," и передачей объекта типа ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.processstartinfo",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"ProcessStartInfo"})})}),", который мы инициировали ранее."]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Класс ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Process"})})})," реализует интерфейс ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.idisposable",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"IDisposable"})})}),", поэтому используется конструкция ",(0,t.jsx)("b",{children:"using"})," для освобождения ресурсов после завершения работы с процессом. Затем в цикле проверяем не завершился ли процесс и так ожидаем, пока он не сделает свое дело. Ну а после завершения выводим последние 10 строк файла с логом работы утилиты."]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Пример можно было сделать еще проще, не обращаясь к классу ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.processstartinfo",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"ProcessStartInfo"})})}),", но здесь мы задействовали его для наглядности."]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Пример вывода утилиты может быть таким:"}),(0,t.jsx)(r.Z,{code:"\n[31.07.2024 12:27:18]: Ожидаем завершения...\n[31.07.2024 12:27:19]: Ожидаем завершения...\n[31.07.2024 12:27:20]: Ожидаем завершения...\n[31.07.2024 12:27:21]: Ожидаем завершения...\n[31.07.2024 12:27:22]: Ожидаем завершения...\n[31.07.2024 12:27:23]: Ожидаем завершения...\n[31.07.2024 12:27:24]: Ожидаем завершения...\n[31.07.2024 12:27:25]: Ожидаем завершения...\n[31.07.2024 12:27:26]: Ожидаем завершения...\n[31.07.2024 12:27:27]: Ожидаем завершения...\n[31.07.2024 12:27:28]: Ожидаем завершения...\n[31.07.2024 12:27:29]: Ожидаем завершения...\n[31.07.2024 12:27:30]: Ожидаем завершения...\n[31.07.2024 12:27:31]: Работа процесса завершена.\n[31.07.2024 12:27:31]: Вывод работы программы (последние 10 строк):\n<<<<<\n1000 rows successfully bulk-copied to host-file. Total received: 10395000\n1000 rows successfully bulk-copied to host-file. Total received: 10396000\n1000 rows successfully bulk-copied to host-file. Total received: 10397000\n1000 rows successfully bulk-copied to host-file. Total received: 10398000\n1000 rows successfully bulk-copied to host-file. Total received: 10399000\n1000 rows successfully bulk-copied to host-file. Total received: 10400000\n\n10400008 rows copied.\nNetwork packet size (bytes): 4096\nClock Time (ms.) Total     : 12594  Average : (825790.69 rows per sec.)\n>>>>>\n                    ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Таким образом, запускать простые приложения уже можно, и даже ожидать их завершения. Но что, если запущенный процесс зависнет или начнет ожидать какого-то интерактивного действия от пользователя? Тогда мы будем ждать вечно!"}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"А чтобы этого не произошло, усложним пример!"})]}),(0,t.jsxs)("section",{id:"section-are-you-ok",children:[(0,t.jsx)(i.xv,{id:"are-you-ok",title:!0,className:"mt-10 md:text",children:"Завис или не завис?"}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Теперь нам нужно модифицировать свою программу для решения следующих проблем:",(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:"Ограничение времени выполнения?"}),(0,t.jsx)("li",{children:"Зависло ли приложение?"}),(0,t.jsx)("li",{children:"Есть ли активность приложения?"})]})]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Начнем по-порядку. Предположим, что для работы процесса отведено максимум 1 минута. Этот шаг реализовать не сложно, ведь мы уже в цикле проверяем завершено ли приложение. Ничто нам не мешает ограничить работу цикла указанным временем, а по окончанию времени принудительно завершить процесс. Например, мы можем сделать это так:"}),(0,t.jsx)(r.Z,{code:'\n// Параметры запуска утилиты\nstring userName = "sa";\nstring userPassword = "<ПарольПользователя>";\nstring objectName = "dbo.Programms";\nstring uploadFilePath = "C:TempBCPProgramms.bak";\nstring databaseName = "TestDB";\nstring instanceName = "SRV-SQL-1";\nstring logFilePath = "C:TempBCPProgramms_Export.out";\n// !!! Таймаут выполнения процесса\nint timeoutSeconds = 60;\n\n// Инициализация объекта с параметрами запуска приложения\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.WindowStyle = ProcessWindowStyle.Hidden;\nstartInfo.FileName = "bcp";\nstartInfo.Arguments =\n    $"{objectName} out "{uploadFilePath}" " +\n    $"-d {databaseName} " +\n    "-l 15 " +\n    $"-P "{userPassword}" " +\n    $"-S "{instanceName}" " +\n    $"-U "{userName}" " +\n    "-N " +\n    $"-o "{logFilePath}"";\n\n// Запуск процесса\nDateTime startProcess = DateTime.Now;\nusing (Process process = Process.Start(startInfo))\n{\n    // ... и ожидание завершения приложения\n    // Примечание: можно ожидать завершения таким способом, \n    // но тогда мы не сможем интерактивно выводить\n    // сообщение об ожидании.\n    // В качестве параметра передаем таймаут ожидания\n    // process.WaitForExit(timeoutSeconds * 1000);\n    // !!! Обновляем время работы программы\n    int workingTimeSec = (int)((DateTime.Now - startProcess).TotalSeconds);\n    while (!process.HasExited\n           // !!! Проверка времени со старта процесса на превышение таймаута\n           && workingTimeSec <= timeoutSeconds)\n    {\n        Console.WriteLine($"[{DateTime.Now}]: Ожидаем завершения. Время работы {workingTimeSec}/{timeoutSeconds} (с)...");\n        Thread.Sleep(1000);\n\n        // !!! Обновляем время работы программы\n        workingTimeSec = (int)((DateTime.Now - startProcess).TotalSeconds);\n    }\n\n    // !!! Если процесс еще активен, то завершаем его принудительно\n    if (!process.HasExited)\n    {\n        process.Kill(true);\n    }\n\n    Console.WriteLine($"[{DateTime.Now}]: Работа процесса завершена. Код завершения: {process.ExitCode}");\n}\n\n// Выводим на экран последние 10 строк лога работы утилиты\nConsole.WriteLine($"[{DateTime.Now}]: Вывод работы программы (последние 10 строк):");\nConsole.WriteLine("<<<<<");\n\nif (File.Exists(logFilePath))\n{\n    var lastOutputLines = File.ReadAllLines(logFilePath)\n        .TakeLast(10)\n        .ToList();\n    foreach (var line in lastOutputLines)\n    {\n        Console.WriteLine(line);\n    }\n}\nConsole.WriteLine(">>>>>");\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Теперь мы установили программе время на работу, при превышении которого процесс будет принудительно завершен. На каждой итерации цикла ожидания завершения процесса выводим время работы и проверяем превышения таймаута. При выходе за пределы времени ожидания, процесс завершаем принудительно, если он еще активен. Пример вывода программы, если программа уложилась в отведенное время и превышения таймаута не случилось:"}),(0,t.jsx)(r.Z,{code:"\n[31.07.2024 12:54:01]: Ожидаем завершения. Время работы 0/60 (с)...\n[31.07.2024 12:54:02]: Ожидаем завершения. Время работы 1/60 (с)...\n[31.07.2024 12:54:03]: Ожидаем завершения. Время работы 2/60 (с)...\n[31.07.2024 12:54:04]: Ожидаем завершения. Время работы 3/60 (с)...\n[31.07.2024 12:54:05]: Ожидаем завершения. Время работы 4/60 (с)...\n[31.07.2024 12:54:06]: Ожидаем завершения. Время работы 5/60 (с)...\n[31.07.2024 12:54:07]: Ожидаем завершения. Время работы 6/60 (с)...\n[31.07.2024 12:54:08]: Ожидаем завершения. Время работы 7/60 (с)...\n[31.07.2024 12:54:09]: Ожидаем завершения. Время работы 8/60 (с)...\n[31.07.2024 12:54:10]: Ожидаем завершения. Время работы 9/60 (с)...\n[31.07.2024 12:54:11]: Ожидаем завершения. Время работы 10/60 (с)...\n[31.07.2024 12:54:12]: Ожидаем завершения. Время работы 11/60 (с)...\n[31.07.2024 12:54:13]: Ожидаем завершения. Время работы 12/60 (с)...\n[31.07.2024 12:54:14]: Работа процесса завершена. Код завершения: 0\n[31.07.2024 12:54:14]: Вывод работы программы (последние 10 строк):\n<<<<<\n1000 rows successfully bulk-copied to host-file. Total received: 10395000\n1000 rows successfully bulk-copied to host-file. Total received: 10396000\n1000 rows successfully bulk-copied to host-file. Total received: 10397000\n1000 rows successfully bulk-copied to host-file. Total received: 10398000\n1000 rows successfully bulk-copied to host-file. Total received: 10399000\n1000 rows successfully bulk-copied to host-file. Total received: 10400000\n\n10400008 rows copied.\nNetwork packet size (bytes): 4096\nClock Time (ms.) Total     : 12141  Average : (856602.25 rows per sec.)\n>>>>>\n                ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"При превышении таймаута вывод программы будет таким (для проверки поставили таймаут в 2 секунды):"}),(0,t.jsx)(r.Z,{code:"\n[31.07.2024 12:55:25]: Ожидаем завершения. Время работы 0/2 (с)...\n[31.07.2024 12:55:26]: Ожидаем завершения. Время работы 1/2 (с)...\n[31.07.2024 12:55:27]: Ожидаем завершения. Время работы 2/2 (с)...\n[31.07.2024 12:55:28]: Работа процесса завершена. Код завершения: -1\n[31.07.2024 12:55:28]: Вывод работы программы (последние 10 строк):\n<<<<<\n1000 rows successfully bulk-copied to host-file. Total received: 2195000\n1000 rows successfully bulk-copied to host-file. Total received: 2196000\n1000 rows successfully bulk-copied to host-file. Total received: 2197000\n1000 rows successfully bulk-copied to host-file. Total received: 2198000\n1000 rows successfully bulk-copied to host-file. Total received: 2199000\n1000 rows successfully bulk-copied to host-file. Total received: 2200000\n1000 rows successfully bulk-copied to host-file. Total received: 2201000\n1000 rows successfully bulk-copied to host-file. Total received: 2202000\n1000 rows successfully bulk-copied to host-file. Total received: 2203000\n1000 rows succ\n>>>>>\n                ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:['Таким образом, бесконечного ожидания завершения процесса уже не будет и окончательного "подвисания" не случится. Однако для полной надежности необходимо проверять активно ли приложение. Это можно сделать несколькими способами:',(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:"Есть ли вывод на консоль новых сообщений, если это, конечно, консольное приложение."}),(0,t.jsx)("li",{children:"Есть ли какая-либо активность процесса в части потребления ЦП."})]}),"Реализуем эти проверки, дополнив пример выше."]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Для создания ситуации подвисания приложения закомментируем параметры запуска утилиты BCP:"}),(0,t.jsx)(r.Z,{code:'\n// Инициализация объекта с параметрами запуска приложения\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.WindowStyle = ProcessWindowStyle.Hidden;\nstartInfo.FileName = "bcp";\nstartInfo.Arguments =\n    $"{objectName} out "{uploadFilePath}" " +\n    $"-d {databaseName} " +\n    "-l 15 " +\n    $"-P "{userPassword}" " +\n    $"-S "{instanceName}" " +\n    $"-U "{userName}" ";\n    // Отключаем использование нативных типов базы данных\n    // и вывод лога работы утилиты в файл.\n    //"-N " +\n    //$"-o "{logFilePath}"";\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Если бы мы запустили утилиту с такими параметрами интерактивно в терминале, то получили бы интерактивный запрос на уточнение параметров:"}),(0,t.jsx)(r.Z,{code:"\nEnter the file storage type of field Id [int]:\n                ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Конечно, таймаут выполнения процесса через 60 секунд сработал бы и процесс был бы завершен. Но в некоторых сценариях этот вариант бы не сработал. Например, запускаемое приложение может делать какую-то тяжелую работу и выполняться 10 минут. Мы установим таймаут, например. 15 минут. Но если программа будет запущена и получит запрос на интерактивный ввод сразу же, то мы фактически теряем эти 15 минут на ожидание, хотя сразу можно было бы узнать, что ничего не произойдет."}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["В таких случаях на поможет динамический анализ потребления ресурсов ЦП запущенным процессом. Можно сказать, что если процесс не использовал ресурсы ЦП какое-то обозначенное время, то процесс можно считать зависшим и завершить. Ниже дополненный пример с новым ограничительным параметром - ",(0,t.jsx)("b",{children:"таймаутом простоя приложения"}),"."]}),(0,t.jsx)(r.Z,{code:'\n// Параметры запуска утилиты\nstring userName = "sa";\nstring userPassword = "<ПарольПользователя>";\nstring objectName = "dbo.Programms";\nstring uploadFilePath = "C:\\Temp\\BCP\\Programms.bak";\nstring databaseName = "TestDB";\nstring instanceName = "SRV-SQL-1";\nstring logFilePath = "C:\\Temp\\BCP\\Programms_Export.out";\n// Таймаут выполнения процесса\nint timeoutSeconds = 60;\n// Таймаут простоя процесса\nint timeoutProcessCpuIdleSec = 5;\n// !!! Последнее значение использования ресурсов ЦП процессом\nTimeSpan lastCpuProcessUsage = TimeSpan.MinValue;\n// !!! Дата последней активности процеса\nDateTime lastCpuActivity = DateTime.MinValue;\n// !!! Время простоя в секундах с последней активности\nint processCpuIdleSec = 0;\n\n\n// Инициализация объекта с параметрами запуска приложения\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n// Переопредлеяем вывод сообщений из стандартной консоли\nstartInfo.RedirectStandardOutput = true;\nstartInfo.RedirectStandardError = true;\nstartInfo.RedirectStandardInput = true;\nstartInfo.FileName = "bcp";\nstartInfo.Arguments =\n    $"{objectName} out "{uploadFilePath}" " +\n    $"-d {databaseName} " +\n    "-l 15 " +\n    $"-P "{userPassword}" " +\n    $"-S "{instanceName}" " +\n    $"-U "{userName}" " +\n    "-N " +\n    $"-o "{logFilePath}"";\n\n// Запуск процесса\nDateTime startProcess = DateTime.Now;\nusing (Process process = Process.Start(startInfo))\n{\n    // ... и ожидание завершения приложения\n    // Примечание: можно ожидать завершения таким способом, \n    // но тогда мы не сможем интерактивно выводить\n    // сообщение об ожидании.\n    // В качестве параметра передаем таймаут ожидания\n    // process.WaitForExit(timeoutSeconds * 1000);\n    // Обновляем время работы программы\n    int workingTimeSec = (int)((DateTime.Now - startProcess).TotalSeconds);\n    while (!process.HasExited\n           // !!! Проверка времени со старта процесса на превышение таймаута\n           && workingTimeSec <= timeoutSeconds\n           && processCpuIdleSec <= timeoutProcessCpuIdleSec)\n    {\n        Console.WriteLine($"[{DateTime.Now}]: Ожидаем завершения. Время работы {workingTimeSec}/{timeoutSeconds} (с). " +\n                          $"Использование ЦП: {process.TotalProcessorTime}...");\n        Thread.Sleep(1000);\n\n        // Обновляем время работы программы\n        workingTimeSec = (int)((DateTime.Now - startProcess).TotalSeconds);\n        // !!! Обновлям информацию о последней активности процесса\n        if (lastCpuProcessUsage != process.TotalProcessorTime)\n        {\n            lastCpuProcessUsage = process.TotalProcessorTime;\n            lastCpuActivity = DateTime.Now;\n            processCpuIdleSec = 0;\n        }\n        if (lastCpuActivity != DateTime.MinValue)\n        {\n            processCpuIdleSec = (int)(DateTime.Now - lastCpuActivity).TotalSeconds;\n        }\n    }\n\n    // Если процесс еще активен, то завершаем его принудительно\n    if (!process.HasExited)\n    {\n        process.Kill(true);\n    }\n\n    Console.WriteLine($"[{DateTime.Now}]: Работа процесса завершена. Код завершения: {process.ExitCode}");\n}\n\n// Выводим на экран последние 10 строк лога работы утилиты\nConsole.WriteLine($"[{DateTime.Now}]: Вывод работы программы (последние 10 строк):");\nConsole.WriteLine("<<<<<");\n\nif (File.Exists(logFilePath))\n{\n    var lastOutputLines = File.ReadAllLines(logFilePath)\n        .TakeLast(10)\n        .ToList();\n    foreach (var line in lastOutputLines)\n    {\n        Console.WriteLine(line);\n    }\n}\nConsole.WriteLine(">>>>>");\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Здесь мы в самом начале обозначили переменную для хранения таймаута простоя приложения ",(0,t.jsx)("b",{children:"timeoutProcessCpuIdleSec"})," в значении 5 секунд. То есть, если запущенный процесс не использует ЦП 5 секунд, то приложение считаем зависшим. Вспомогательные переменные ",(0,t.jsx)("b",{children:"lastCpuProcessUsage"})," и ",(0,t.jsx)("b",{children:"lastCpuActivity"})," используются для отслеживания состояния процесса в динамике. По ним определяется изменилось ли потребление ресурсов ЦП с последней проверки, а результат в виде длительности простоя сохраняется в переменную ",(0,t.jsx)("b",{children:"processCpuIdleSec"}),"."]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Затем в цикле проверяется, чтобы длительность простоя не привысила заданный в переменной ",(0,t.jsx)("b",{children:"timeoutProcessCpuIdleSec"})," таймаут. Таким образом, у нас реализована двойная защита от зависания процесса:",(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:"Таймаут работы приложения (в нашем примере это 60 секунд), защищающий от общего подвисания или неприемлемо долгого выполнения процесса."}),(0,t.jsx)("li",{children:"Таймаут простоя приложения (в нашем примере это 5 секунд), защищающий от зависания процесса."})]}),"Стоит отметить, что параметры таймаута нужно подбирать в зависимости от типа процесса, а также специфики работы, которую он проделывает. Ниже пример вывода при срабатывании таймаута простоя процесса:"]}),(0,t.jsx)(r.Z,{code:"\n[31.07.2024 14:21:56]: Ожидаем завершения. Время работы 0/60 (с). Использование ЦП: 00:00:00.0312500...\n[31.07.2024 14:21:57]: Ожидаем завершения. Время работы 1/60 (с). Использование ЦП: 00:00:00.0468750...\n[31.07.2024 14:21:58]: Ожидаем завершения. Время работы 2/60 (с). Использование ЦП: 00:00:00.0468750...\n[31.07.2024 14:21:59]: Ожидаем завершения. Время работы 3/60 (с). Использование ЦП: 00:00:00.0468750...\n[31.07.2024 14:22:00]: Ожидаем завершения. Время работы 4/60 (с). Использование ЦП: 00:00:00.0468750...\n[31.07.2024 14:22:01]: Ожидаем завершения. Время работы 5/60 (с). Использование ЦП: 00:00:00.0468750...\n[31.07.2024 14:22:02]: Ожидаем завершения. Время работы 6/60 (с). Использование ЦП: 00:00:00.0468750...\n[31.07.2024 14:22:08]: Работа процесса завершена. Код завершения: -1\n[31.07.2024 14:22:08]: Вывод работы программы (последние 10 строк):\n<<<<<\n1000 rows successfully bulk-copied to host-file. Total received: 10395000\n1000 rows successfully bulk-copied to host-file. Total received: 10396000\n1000 rows successfully bulk-copied to host-file. Total received: 10397000\n1000 rows successfully bulk-copied to host-file. Total received: 10398000\n1000 rows successfully bulk-copied to host-file. Total received: 10399000\n1000 rows successfully bulk-copied to host-file. Total received: 10400000\n\n10400008 rows copied.\nNetwork packet size (bytes): 4096\nClock Time (ms.) Total     : 13016  Average : (799017.19 rows per sec.)\n>>>>>\n                ",className:"my-5",language:"text",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"В самом начале процесс использовал ЦП, а потом следующие 5 секунд никакой активности не было обнаружено. Процесс в итоге был принудительно завершен."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Однако, даже эти контроли не всегда могут удовлетворить решению задачи."})]}),(0,t.jsxs)("section",{id:"section-terminal-output",children:[(0,t.jsx)(i.xv,{id:"terminal-output",title:!0,className:"mt-10 md:text",children:"Читаем вывод консоли"}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["В некоторых сценариях у приложения может не быть возможности вывода результата работы в файл лога, как мы это делали с помощью параметра ",(0,t.jsx)("b",{children:"-o"})," с указанием результатирующего файла. В этих случаях остается единственный вариант получить вывод работы программы - это прочитать консольный вывод."]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["На основе консольного вывода мы также можем сделать два вида проверок:",(0,t.jsxs)(i.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Таймаут вывода сообщений в консоль."})," То есть, если приложение долго не подает никаких сообщений, то можем посчитать его зависшим."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Анализ вывода на наличие ошибок."})," Если в консоль выведено сообщение об ошибке, и при этом ожидается какое-то интерактивное действия, то мы можем среагировать и завершить приложение."]})]})]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Объект класса ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Process"})})})," позволяет это сделать. Для этого достаточно перенаправить стандартный вывод консоли, включил следующие опции у процесса:",(0,t.jsxs)(i.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.processstartinfo.redirectstandardoutput",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"RedirectStandardOutput"})})})," - перенаправление стандартного вывода."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.processstartinfo.redirectstandarderror",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"RedirectStandardError"})})})," - перенаправление стандартного вывода об ошибках."]})]}),"Также установим свойству ",(0,t.jsx)("b",{children:"CreateNoWindow"})," процесса флаг в ",(0,t.jsx)("b",{children:"True"}),", чтобы для процесса не создавалось окна, ведь интерактивного взаимодействия с ним не предполагается."]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Теперь мы можем подписаться на события объекта для обработки поступающих сообщений:",(0,t.jsxs)(i.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process.outputdatareceived",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"OutputDataReceived"})})})," - событие записи строки в перенаплавненный поток вывода."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process.errordatareceived",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"ErrorDataReceived"})})})," - событие записи строки в перенаплавненный поток вывода об ошибках."]})]}),"Но дьявол, как обычно, в деталях. Мы не можем просто так взять и подписаться на события получения событий вывода. Во-первых нам нужно учесть возможность ожидания вывода при ожидании завершения работы процесса. Во-вторых, нам необходимо учесть таймаут вывода сообщений на консоль и собирать их, в том числе для последующего вывода или передачи вызывающему коду приложения."]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Также есть еще один важный нюанс, который нужно учесть. Это возможное переполнение внутреннего буфера консольного вывода при ожидании завершения процесса методом ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process.waitforexit",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"ErrorDataReceived"})})}),". Такое происходит по двум основным причинам:",(0,t.jsxs)(i.aV,{children:[(0,t.jsxs)("li",{children:["Если начать ожидание завершения процесса перед считыванием потоков вывода ",(0,t.jsx)("b",{children:"StandardOutput"})," и ",(0,t.jsx)("b",{children:"StandardError"}),". Процесс может заблокировать запись в них, из-за чего происходит взаимоблокировка и бесконечное ожидание потоков друг друга."]}),(0,t.jsxs)("li",{children:["Если начать чтение потоков вывода ",(0,t.jsx)("b",{children:"StandardOutput"})," и ",(0,t.jsx)("b",{children:"StandardError"})," через вызов метода ",(0,t.jsx)("b",{children:"ReadToEnd"}),", процесс также блокирует буфер, что также приводит к взаимоблокировке."]})]})]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Для решения этих проблем нужно воспользоваться асинхронным чтением данных вывода из потоков, что позволит избежать ситуации переполнения внутреннего буфера. Ниже пример реализации такого чтения, а также таймаута активности консольного вывода приложения:"}),(0,t.jsx)(r.Z,{code:'\n// Параметры запуска утилиты\nstring userName = "sa";\nstring userPassword = "<ПарольПользователя>";\nstring objectName = "dbo.Programms";\nstring uploadFilePath = "C:\\Temp\\BCP\\Programms.bak";\nstring databaseName = "TestDB";\nstring instanceName = "SRV-SQL-1";\nstring logFilePath = "C:\\Temp\\BCP\\Programms_Export.out";\n// Таймаут выполнения процесса\nint timeoutSeconds = 60;\n// Таймаут простоя процесса\nint timeoutProcessCpuIdleSec = 60;\n// Последнее значение использования ресурсов ЦП процессом\nTimeSpan lastCpuProcessUsage = TimeSpan.MinValue;\n// Дата последней активности процеса\nDateTime lastCpuActivity = DateTime.MinValue;\n// Время простоя в секундах с последней активности\nint processCpuIdleSec = 0;\n// !!! Таймаут активности конольного вывода\nint timeoutConsoleOutputActivity = 10;\n// !!! Время простоя консольного вывода\nint consoleOutputIdleSec = 0;\n// !!! Информация о выводе консольного приложения\nStringBuilder outputMessage = new StringBuilder();\nStringBuilder outputErrorMessage = new StringBuilder();\n// !!! Даты последнего вывода\nDateTime lastOutputDate = DateTime.MinValue;\n// !!! Объекты для синхронизации обновления дат последнего вывода на консоль\nobject lockLastOutputDateUpdate = new object();\n\n// Инициализация объекта с параметрами запуска приложения\nProcessStartInfo startInfo = new ProcessStartInfo();\nstartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n// !!! Переопредлеяем вывод сообщений из стандартной консоли\nstartInfo.RedirectStandardOutput = true;\nstartInfo.RedirectStandardError = true;\n// !!! Создание окна приложения отключаем\nstartInfo.CreateNoWindow = true;\nstartInfo.FileName = "bcp";\nstartInfo.Arguments =\n    $"{objectName} out "{uploadFilePath}" " +\n    $"-d {databaseName} " +\n    "-l 15 " +\n    $"-P "{userPassword}" " +\n    $"-S "{instanceName}" " +\n    $"-U "{userName}" " +\n    "-N " +\n    $"-o "{logFilePath}"";\n\n// !!! Создаем события синхронизации потоков.\n// outputWaitHandle - для вывода сообщений основного потока вывода.\n// errorWaitHandle - для вывода сообщений потока вывода об ошибках.\nusing (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))\n{\n    using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))\n    {\n        DateTime startProcess = DateTime.UtcNow;\n        lastOutputDate = DateTime.UtcNow;\n        // Запуск процесса\n        using (Process process = new Process())\n        {\n            process.StartInfo = startInfo;\n            // !!! Подписываемся на события получения сообщений в потоки вывода\n            process.OutputDataReceived += (_, e) =>\n            {\n                if (e.Data == null)\n                {\n                    // !!! Передаем сигнал на продолжение ожидающего потока\n                    outputWaitHandle.Set();\n                }\n                else\n                {\n                    // !!! Добаляем сообщение вывода и обновляем дату последней активности в консоли\n                    outputMessage.AppendLine(e.Data);\n                    lock (lockLastOutputDateUpdate)\n                    {\n                        lastOutputDate = DateTime.UtcNow;\n                    }\n                }\n            };\n            process.ErrorDataReceived += (_, e) =>\n            {\n                if (e.Data == null)\n                {\n                    // !!! Передаем сигнал на продолжение ожидающего потока\n                    errorWaitHandle.Set();\n                }\n                else\n                {\n                    // !!! Добаляем сообщение вывода и обновляем дату последней активности в консоли\n                    outputErrorMessage.AppendLine(e.Data);\n                    lock (lockLastOutputDateUpdate)\n                    {\n                        lastOutputDate = DateTime.UtcNow;\n                    }\n                }\n            };\n\n            process.Start();\n\n            // Инициируем чтение вывода сообщений на консоль\n            process.BeginOutputReadLine();\n            process.BeginErrorReadLine();\n\n            // ... и ожидание завершения приложения\n            // Примечание: можно ожидать завершения таким способом, \n            // но тогда мы не сможем интерактивно выводить\n            // сообщение об ожидании.\n            // !!! В качестве параметра передаем таймаут ожидания в мс.\n            // int timeoutMs = timeoutSeconds * 1000;\n            // process.WaitForExit(timeoutMs)\n            //    && outputWaitHandle.WaitOne(timeoutMs)\n            //    && errorWaitHandle.WaitOne(timeoutMs)\n\n            // Обновляем время работы программы\n            int workingTimeSec = (int)((DateTime.UtcNow - startProcess).TotalSeconds);\n            while (!process.HasExited\n                   // Проверка времени со старта процесса на превышение таймаута\n                   && (timeoutSeconds == 0 || workingTimeSec <= timeoutSeconds)\n                   // Проверка времени простоя при использовании ЦП\n                   && (timeoutProcessCpuIdleSec == 0 || processCpuIdleSec <= timeoutProcessCpuIdleSec)\n                   // Проверка времени простоя консоли вывода\n                   && (timeoutConsoleOutputActivity == 0 || consoleOutputIdleSec <= timeoutConsoleOutputActivity))\n            {\n                Console.WriteLine(\n                    $"[{DateTime.UtcNow}]: Ожидаем завершения. Время работы {workingTimeSec}/{timeoutSeconds} (с). " +\n                    $"Использование ЦП: {process.TotalProcessorTime}. Простой консоли: {consoleOutputIdleSec}...");\n                Thread.Sleep(1000);\n\n                // Обновляем время работы программы\n                workingTimeSec = (int)((DateTime.UtcNow - startProcess).TotalSeconds);\n                // Обновлям информацию о последней активности процесса\n                if (lastCpuProcessUsage != process.TotalProcessorTime)\n                {\n                    lastCpuProcessUsage = process.TotalProcessorTime;\n                    lastCpuActivity = DateTime.UtcNow;\n                    processCpuIdleSec = 0;\n                }\n                if (lastCpuActivity != DateTime.MinValue)\n                {\n                    processCpuIdleSec = (int)(DateTime.UtcNow - lastCpuActivity).TotalSeconds;\n                }\n                // !!! Обновление состояния активности консоли\n                consoleOutputIdleSec = (int)(DateTime.UtcNow - lastOutputDate).TotalSeconds;\n            }\n\n            // Если процесс еще активен, то завершаем его принудительно\n            if (!process.HasExited)\n            {\n                process.Kill(true);\n            }\n\n            Console.WriteLine(\n                $"[{DateTime.Now}]: Работа процесса завершена. Код завершения: {process.ExitCode}");\n        }\n    }\n}\n\n// Выводим на экран последние 10 строк лога работы утилиты\nConsole.WriteLine($"[{DateTime.Now}]: Вывод работы программы (последние 10 строк):");\nConsole.WriteLine("<<<<<");\n\nif (File.Exists(logFilePath))\n{\n    var lastOutputLines = File.ReadAllLines(logFilePath)\n        .TakeLast(10)\n        .ToList();\n    foreach (var line in lastOutputLines)\n    {\n        Console.WriteLine(line);\n    }\n}\nConsole.WriteLine(">>>>>");\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Листинг уже значительно расширился, по сравнению с первыми примерами. Рассмотрим что здесь поменялось."}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["В самом начале мы объявили ряд новых переменных:",(0,t.jsxs)(i.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"timeoutConsoleOutputActivity"})," - таймаут появления новых сообщений в консоли вывода. То есть, если в течении заданного периода времени в консоли не появлялось новых сообщений, то считаем процесс зависшим."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"consoleOutputIdleSec"})," - здесь будет храниться текущий простой консольного вывода для сравнения его с таймаутом. Значение будет обновляться в цикле ниже."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"outputMessage"})," и ",(0,t.jsx)("b",{children:"outputErrorMessage"})," - это набор строк, которые пришли из потоков вывода консоли. В будущем эти даные можно использовать для анализа работы программы."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"lastOutputDate"})," - дата последнего сообщения в консоли."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"lockLastOutputDateUpdate"})," - объект синхронизации потоков, чтобы безопасно обновлять дату последнего сообщения в консоли ",(0,t.jsx)("b",{children:"lastOutputDate"}),"."]})]})]}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Кроме этого мы создаем два объекта типа ",(0,t.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.autoresetevent",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"AutoResetEvent"})})})," для реализации надежного ожидания завершения процесса, если такое понадобиться использовать. Ведь мы делаем асинхронное чтение сообщений консоли из буфера и логичнее было бы дождаться, когда все они попадут в коллекции ",(0,t.jsx)("b",{children:"outputMessage"})," и ",(0,t.jsx)("b",{children:"outputErrorMessage"})," перед выходом. Это достигается путем вызова метода ",(0,t.jsx)("b",{children:"Set"})," при обнаружении пустого буфера в событиях ",(0,t.jsx)("b",{children:"OutputDataReceived"})," и ",(0,t.jsx)("b",{children:"ErrorDataReceived"}),". Теперь при необходимости ожидать завершения процесса мы можем так:"]}),(0,t.jsx)(r.Z,{code:"\nint timeoutMs = timeoutSeconds * 1000;\nprocess.WaitForExit(timeoutMs)\n    && outputWaitHandle.WaitOne(timeoutMs)\n    && errorWaitHandle.WaitOne(timeoutMs);\n                ",className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Также, при превышении времени простоя сообщений в консоль процесс будет завершен принудительно. Вот пример вывода программы в такой ситуации:"}),(0,t.jsx)(r.Z,{code:"\n[31.07.2024 13:31:13]: Ожидаем завершения. Время работы 0/0 (с). Использование ЦП: 00:00:00.0468750. Простой консоли: 0...\n[31.07.2024 13:31:14]: Ожидаем завершения. Время работы 5/0 (с). Использование ЦП: 00:00:00.0468750. Простой консоли: 5...\n[31.07.2024 13:31:15]: Ожидаем завершения. Время работы 6/0 (с). Использование ЦП: 00:00:00.0468750. Простой консоли: 6...\n[31.07.2024 13:31:16]: Ожидаем завершения. Время работы 7/0 (с). Использование ЦП: 00:00:00.0468750. Простой консоли: 7...\n[31.07.2024 13:31:17]: Ожидаем завершения. Время работы 8/0 (с). Использование ЦП: 00:00:00.0468750. Простой консоли: 8...\n[31.07.2024 13:31:18]: Ожидаем завершения. Время работы 9/0 (с). Использование ЦП: 00:00:00.0468750. Простой консоли: 9...\n[31.07.2024 13:31:19]: Ожидаем завершения. Время работы 10/0 (с). Использование ЦП: 00:00:00.0468750. Простой консоли: 10...\n[31.07.2024 16:31:20]: Работа процесса завершена. Код завершения: -1\n[31.07.2024 16:31:20]: Вывод работы программы (последние 10 строк):\n<<<<<\n>>>>>\n                ",className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Таким образом, мы решили дополнительно несколько вопросов:",(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:"Реализован таймаут работы процесса при простое вывода сообщений на консоль."}),(0,t.jsx)("li",{children:"Решена проблема ожидания завершения процесса при чтении консольного вывода, когда могло произойти зависание из-за взаимоблокировки потоков."}),(0,t.jsx)("li",{children:"Возможность анализа вывода на консоль для поиска ошибок и их обработки."})]})]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Что еще для счастья нужно при запуске приложений?"})]}),(0,t.jsxs)("section",{id:"section-env-res-and-so-on",children:[(0,t.jsx)(i.xv,{id:"env-res-and-so-on",title:!0,className:"mt-10 md:text",children:"Окружение, ресурсы и так далее"}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"К идеалу можно идти бесконечно и запуск процессов не является исключением. Рассмотрим еще несколько сторон контроля запускаемых процессов, которые, возможно, стоит реализовать."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Самое первое, что приходит в голову - это потребление ресурсов. Кто Вам теперь может помешать контролировать, например, потребляемую память процессом. В цикле ожидания завершения процесса можно добавить проверку объема занимаемой памяти процессов и если значение превышено, то процесс также будет завершен принудительно. На листинге эта часть может выглядеть примерно так:"}),(0,t.jsx)(r.Z,{code:"\nwhile (!process.HasExited\n       // Проверка времени со старта процесса на превышение таймаута\n       && (timeoutSeconds == 0 || workingTimeSec <= timeoutSeconds)\n       // Проверка времени простоя при использовании ЦП\n       && (timeoutProcessCpuIdleSec == 0 || processCpuIdleSec <= timeoutProcessCpuIdleSec)\n       // Проверка времени простоя консоли вывода\n       && (timeoutConsoleOutputActivity == 0 || consoleOutputIdleSec <= timeoutConsoleOutputActivity))\n{\n    // !!! Контроль потребления процессов\n    if (process.WorkingSet64 >= 1073741824)\n    {\n        // Если память рабочего набора запущенного процесса больше 1 ГБ,\n        // то прерываем ожидание и завершаем процесс принудительно\n        break;\n    }\n    // ...\n}\n                ",className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Но это лишь небольшой пример, ведь проверять можно любые свойства процессов, состояние операционной системы и так далее. Все ограничивается лишь Вашим воображением и потребностями."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Еще одна интересная ситуация - это завершение работы дочернего процесса приложения, в котором мы все эти контроли и непосредственно запуск реализовали. Может сложиться ситуация, что наше приложение запустило внешний процесс и даже контролировало его работу пару минут, но потом по какой-то причине было завершено (ошибка приложения, кто-то закрыл его через диспетчер задач и так далее). В этом случае, запущенный процесс BCP.exe останется активным, не смотря на то, что родительское приложение уже не работает. Все это может привести к непредсказуемым результатам и поломкам."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Решить такую неприятную ситуацию можно разными способами. Например, при запуске приложения можно проверять наличие уже запущенных процессов BCP.exe. Если они есть, то завершать."}),(0,t.jsx)(r.Z,{code:'\n// Завершаем все процессы BCP.exe при запуске основного приложения\nProcess.GetProcesses()\n    .Where(e => e.ProcessName.Equals("bcp", StringComparison.CurrentCultureIgnoreCase))\n    .ToList()\n    .ForEach(p => p.Kill(true));\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Но это тоже нужно делать осторожно. Иногда лучше дождаться завершения такого процесса. А что еще страшнее, еще может понадобиться исправлять подобный некорректный запуск какими-то более сложными действиям. В общем, тут есть разные сложные схемы, но в отрыве от контекста описывать их смысла будет немного."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"И еще стоит упомянуть, что в ходе работы приложения может иметь смысл анализировать вывод на консоль сразу при получении сообщений. Или общий лог работы приложения. Здесь варианты анализа полностью зависят от приложения и какие логи оно записывает, поэтому примера как такового не будет."})]}),(0,t.jsxs)("section",{id:"section-ideal-control",children:[(0,t.jsx)(i.xv,{id:"ideal-control",title:!0,className:"mt-10 md:text",children:"Идеальный контроль"}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Мы рассмотрели последовательный пример усиления контроля над запускаемыми процессами на примере утилиты BCP. По итогу у нас реализованы следующие контроли:",(0,t.jsxs)(i.aV,{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Таймаут работы приложения"})," - это общее время ожидания, сколько может работать запущенный процесс."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Таймаут простоя процесса"})," - это время, которое процесс может ничего не делать, то есть не потреблять ресурсы ЦП."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Таймаут простоя консоли вывода"})," - это время, которое приложение может не подавать никаких сообщений в консоль вывода. То есть, если приложение не будет писать в консоль никаких сообщений некоторое время, то контроль может посчитать процесс зависшим."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Безопасное ожидание завершения"})," - учитывается ошибка взаимоблокировки потоков из-за блокировки внутреннего буфера процесса."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)("b",{children:"Контроль ресурсов, окружения и логов"})," - мы упомянули, что контроль процесса можно расширять до бесконечно. От потребляемой им памяти, то окружения ОС и прочего."]})]})]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Все вышеперечисленное можно использовать по отдельному или вместе, все зависит от задачи. Но достаточно ли этого?"}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Для тех случаев, когда мы запускаем какой-то сторонний процесс, к исходному коду которого у нас нет доступа, данный подход поможет решить большинство вопросов. Но если мы запускаем процесс приложения, которое мы программируем сами или хотя бы имеем доступ к его исходному коду, то возможно есть смысл сделать контроль и взаимодействие процессов более надежным."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Речь здесь идет о том, что в такой ситуации мы можем подружить процессы между собой, наладить межпроцессное взаимодействие между ними. Через обмен сообщений можно будет реализовать не только контроль выполнения, но и обмен другими полезными сообщениями."}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Создадим для примера два простых консольных приложения с самым примитивным контролем. Первое консольное приложение будет дочерним (то есть запускаться из другого приложения). В качестве параметров командной строки оно будет принимать:",(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:"Идентификатор родительского процесса"}),(0,t.jsx)("li",{children:"Имя родительского процесса"})]})]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Переданные параметры сохраняются на время работы приложения и периодически проверяется наличие такого процесса в системе. Если родительский процесс с такими параметрами отсутствует, то и это приложение само себя завершит."}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Ниже листинг дочернего консольного приложения ",(0,t.jsx)("b",{children:"ChildProcess"}),":"]}),(0,t.jsx)(r.Z,{code:'\nusing System.Diagnostics;\n\nstring parentProcessId = args[0];\nstring parentProcessName = args[1];\n\nConsole.WriteLine($"Родительский процесс. ID: {parentProcessId}");\nConsole.WriteLine($"Родительский процесс. Имя: {parentProcessName}");\n\nvar currentProcess = Process.GetCurrentProcess();\nstring currentProcessId = currentProcess.Id.ToString();\nstring currentProcessName = currentProcess.ProcessName;\n\nbool parentProcessExists = Process\n    .GetProcesses()\n    .Where(e => e.ProcessName.Equals(parentProcessName, StringComparison.CurrentCultureIgnoreCase))\n    .Any(e => e.Id == int.Parse(parentProcessId));\n\nwhile (parentProcessExists)\n{\n    Console.WriteLine($"Дочерний процесс. ID: {currentProcessId}");\n    Console.WriteLine($"Дочерний процесс. Имя: {currentProcessName}");\n    Console.WriteLine("Родительский процесс активен. Продолжаем работу...");\n    Thread.Sleep(1000);\n\n    parentProcessExists = Process\n        .GetProcesses()\n        .Where(e => e.ProcessName.Equals(parentProcessName, StringComparison.CurrentCultureIgnoreCase))\n        .Any(e => e.Id == int.Parse(parentProcessId));\n}\n\nConsole.WriteLine("Родительский процесс остановлен. Завершаем работу...");\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Листинг дочернего приложения ",(0,t.jsx)("b",{children:"ParentProcess"}),":"]}),(0,t.jsx)(r.Z,{code:'\nusing System.Diagnostics;\n\nvar currentProcess = Process.GetCurrentProcess();\nstring parentProcessId = currentProcess.Id.ToString();\nstring parentProcessName = currentProcess.ProcessName;\n\nstring childApp = "ChildProcess.exe";\nstring argumentsApp = $""{parentProcessId}" "{parentProcessName}"";\nProcess.Start(childApp, argumentsApp);\n\nConsole.WriteLine("Для выхода нажмите любую клавишу...");\nConsole.ReadKey();\n\n                ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Файлы обоих приложений поместим в один каталог и запустим дочернее приложение ",(0,t.jsx)("b",{children:"ParentProcess"}),". Вот как это будет выглядеть."]}),(0,t.jsx)(i.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-07/processes-under-control/1. parent-chile-process.gif",alt:"Запуск зависимых процессов",size:o.h2.FUll}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Нажав любую клавишу мы завершим родительский процесс, а дочерний процесс завершится сам, как только проверка это обнаружит."}),(0,t.jsxs)(i.xv,{textAlign:o.PH.JUSTIFY,children:["Конечно, это лишь простейший пример. Но его суть и посыл должны быть понятны:",(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:"Зависимые процессы должны мониторить состояние друг друга."}),(0,t.jsx)("li",{children:"Обмен сообщениями между процессами возможен через TCP-соединения, файлы, общую память, HTTP-запросы и многие другие способы."}),(0,t.jsx)("li",{children:"Нужно обязательно предусмотреть на стороне родительского процесса поведение, если дочерний процесс был внезапно завершен."}),(0,t.jsx)("li",{children:"Аналогично на стороне дочернего процесса предусмотреть действия, если родительский процесс был завершен."})]})]}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Все это лишь базовая информация и межпроцессное взаимодействие более обширная и интересная тема. Но именно благодаря такому подходу взаимодействие и контроль процессов можно выстроить максимально эффективным. Но сегодня на этом все."})]}),(0,t.jsxs)("section",{id:"section-the-end",children:[(0,t.jsx)(i.xv,{id:"the-end",title:!0,className:"mt-10 md:text",children:"Мысли напоследок"}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Путь был небольшой, но мы успели рассмотреть шаги по укреплению контроля за внешними процессами, запущенными из среды .NET (C#). По сути контролировать процесс, поведение которого не может быть гарантировано стабильным, дело неблагодарное. Хоть мы и добавили разные виды таймаутов работы процесса, анализируем его консольный вывод и вывод лога на примере утилиты BCP.exe для SQL Server, контролируем потребляемые ресурсы этого процесса и так далее, но гарантировать приемлемый результат работы все равно нельзя."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:'Описанный подход контроля запущенного процесса лишь дает возможность защититься от зависаний и обработать типичные ошибки. Но если результат работы запущенного процесса будет непредсказуемым, то и обработать такие "внезапные" ошибки у нас нормально не получится. Например, если BCP.exe внезапно удалит существующие таблицы, то такое развитие событий Вы никак предусмотреть не сможете. Отсюда следует, что запуск внешних процессов это всегда риск и нужно лишь определять приемлемо ли это для решения Вашей задачи или нет.'}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Под конец статьи мы коснулись такого способа контроля и взаимодействия с процессами, который позволяет выстроить более тесные проверки и даже способы взаимодействия между процессами. Это максимально эффективный подход, но требует доступа к исходным кодам всех приложений, что не всегда возможно. Конечно, примеры были совсем примитивными и мы даже не создали пример сетевого взаимодействия между процессами, но это здесь и не было нужно. Главное - показать, что для эффективной работы нужно наладить хоть какой-то канал связи между процессами."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"За рамками статьи остается обширная тема межпроцессного взаимодействия, создание дочерних процессов и многое другое. Ниже Вы найдете ссылки на некоторые интересные библиотеки, в которых описанные в статье подходы в какой-то мере используются. Также там Вы найдете и альтернативные подходы."}),(0,t.jsx)(i.xv,{textAlign:o.PH.JUSTIFY,children:"Спасибо, что дочитали до конца! Теперь Вы знаете в какую сторону держать путь, если Вам нужно работать с внешними процессами и приложениями. Удачи в делах!"})]}),(0,t.jsxs)("section",{id:"section-links",children:[(0,t.jsx)(i.xv,{id:"links",title:!0,className:"mt-10 md:text",children:"Это интересно"}),(0,t.jsxs)(i.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{newTab:!0,href:"https://github.com/YPermitin/YPermitin.DBTools/tree/master/Libs/YPermitin.DBTools.SQLServer.BulkCopyProgramWrapper",children:(0,t.jsx)("u",{children:(0,t.jsx)("b",{children:"BulkCopyProgramWrapper - библиотека-оболочка для использования утилиты BCP (Bulk Copy Program)."})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{newTab:!0,href:"https://github.com/Cysharp/ProcessX",children:(0,t.jsx)("u",{children:(0,t.jsx)("b",{children:"ProcessX - простая библиотека для вызова внешних процессов с поддержкой асинхронности."})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{newTab:!0,href:"https://github.com/lolp1/Process.NET",children:(0,t.jsx)("u",{children:(0,t.jsx)("b",{children:'Process.NET - Process.NET is a tool for interacting with processes based around a library called "MemorySharp" by J\xe4mes M\xe9n\xe9trey aka ZenLulz under the license on the pages linked below.'})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{newTab:!0,href:"https://github.com/huysentruitw/process-manager",children:(0,t.jsx)("u",{children:(0,t.jsx)("b",{children:"ProcessManager - управляемая библиотека для запуска очереди процессов и управления ею."})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(i.e9,{newTab:!0,href:"https://github.com/asmichi/ChildProcess",children:(0,t.jsx)("u",{children:(0,t.jsx)("b",{children:"Asmichi.ChildProcess - библиотека для создания дочерних процессов и взаимодействия с ними."})})})})]})]})]})},7855:function(e,n,s){"use strict";var t,i;s.d(n,{b:function(){return t}}),(i=t||(t={})).Min="350px",i.Standard="700px",i.Large="1000x",i.Unlimited=""},4313:function(e,n,s){"use strict";var t=s(7340),i=s(5893),r=s(7294),o=s(4965),l=s(1240),c=s(1686),a=s(7855);function d(){let e=(0,t._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return d=function(){return e},e}function u(){let e=(0,t._)(["\n        max-height: ","\n    "]);return u=function(){return e},e}n.Z=e=>{let{code:n,className:t,language:x,maxHeight:h=a.b.Standard}=e;(void 0!==s.g?s.g:window).Prism=o.p1,s(1354),s(9016),s(5266),s(2927),s(1315),s(7874),s(6862);let m=null!=h?h:a.b.Standard,p=c.ZP.pre(d()),g=(0,c.ZP)(p)(u(),m);return(0,i.jsx)("div",{className:(0,l.GF)("bg-blue-500 md:p-1 p-2",t),children:(0,i.jsx)("div",{className:"shadow-lg",children:(0,i.jsx)(o.y$,{theme:o.np.vsDark,code:n.trim(),language:null!=x?x:x="tsx",children:e=>{let{className:n,style:s,tokens:t,getLineProps:o,getTokenProps:l}=e;return(0,i.jsx)(g,{className:n,style:s,children:t.map((e,n)=>(0,r.createElement)("div",{...o({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,r.createElement)("span",{...l({token:e,key:n}),key:Math.random()}))))})}})})})}},4853:function(e,n,s){"use strict";s.d(n,{Ee:function(){return l},Xg:function(){return r},Y7:function(){return u},aV:function(){return a},e9:function(){return d},o_:function(){return x},ty:function(){return c},xv:function(){return o}});var t=s(5152),i=s.n(t);let r=i()(()=>Promise.all([s.e(9686),s.e(4838),s.e(4738),s.e(1664),s.e(8765)]).then(s.bind(s,8765)),{loadableGenerated:{webpack:()=>[8765]}}),o=i()(()=>Promise.all([s.e(9511),s.e(935)]).then(s.bind(s,935)),{loadableGenerated:{webpack:()=>[935]}}),l=i()(()=>Promise.all([s.e(328),s.e(7651)]).then(s.bind(s,7651)),{loadableGenerated:{webpack:()=>[7651]}}),c=i()(()=>Promise.all([s.e(9686),s.e(6979)]).then(s.bind(s,6979)),{loadableGenerated:{webpack:()=>[6979]}}),a=i()(()=>Promise.all([s.e(4159),s.e(7355)]).then(s.bind(s,7355)),{loadableGenerated:{webpack:()=>[7355]}}),d=i()(()=>Promise.all([s.e(1664),s.e(3220)]).then(s.bind(s,3220)),{loadableGenerated:{webpack:()=>[3220]}});i()(()=>s.e(3140).then(s.bind(s,3140)),{loadableGenerated:{webpack:()=>[3140]}});let u=i()(()=>Promise.all([s.e(2004),s.e(736)]).then(s.bind(s,736)),{loadableGenerated:{webpack:()=>[736]}}),x=i()(()=>Promise.all([s.e(8331),s.e(9996),s.e(2660),s.e(9718),s.e(5826),s.e(9606)]).then(s.bind(s,9606)),{loadableGenerated:{webpack:()=>[9606]}})}},function(e){e.O(0,[6443,2888,9774,179],function(){return e(e.s=2439)}),_N_E=e.O()}]);