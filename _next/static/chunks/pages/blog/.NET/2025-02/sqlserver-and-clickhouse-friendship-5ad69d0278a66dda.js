(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[134],{71698:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/.NET/2025-02/sqlserver-and-clickhouse-friendship",function(){return r(10971)}])},10971:function(e,n,r){"use strict";r.r(n);var l=r(85893),s=r(97037);r(67294);var i=r(13803),t=r(46416);n.default=()=>(0,l.jsxs)(s.Xg,{blogcentered:!0,children:[(0,l.jsxs)(s.xv,{textAlign:t.PH.RIGHT,quote:!0,children:["Настоящая дружба правдива и отважна.",(0,l.jsx)("br",{}),"(с) Байрон Д."]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Создаем дружбу между SQL Server и ClickHouse через SQLCLR (SELECT, BULK INSERT и любые другие операции)."}),(0,l.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Содержание"}),(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#integration",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Интеграция - вечная задача"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#show-me-cards",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Раскройте все карты"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#sqlclr-and-legacy",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"SQLCLR и мир легаси"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#where-is-library",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Как пройти в библиотеку?"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#setup-and-config",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Установка и настройка"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#queries",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Запросы, запросы, запросы"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#thoughts",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Немного мыслей"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)(s.e9,{href:"#link",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Полезные материалы"})})})})]}),(0,l.jsxs)("section",{id:"section-integration",children:[(0,l.jsx)(s.xv,{id:"integration",title:!0,className:"mt-10 md:text",children:"Интеграция - вечная задача"}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Мы живем в мире разнообразного ПО, написанного на разных языках, платформах, для разных ОС и выполняющего абсолютно (или почти) разные задачи. Таков наш путь, а значит и таковы задачи."}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"В таких условиях задача интеграции будет всегда актуальной. Не обошел этот вопрос стороной и интеграцию между такими СУБД как SQL Server и ClickHouse. Причин подружить эти две великолепные СУБД может быть много. Да даже организация массовых выгрузок из OLTP-базы на SQL Server в DWH на ClickHouse может быть весьма распространённой задачей."}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Сегодня мы как раз этим делом и займемся, но обо всем по порядку. Сначала мы рассмотрим в общих чертах самые популярные пути, а после остановимся на одном из них немного подробней. Речь идет, конечно, об интеграции SQL Server с ClickHouse средствами расширения SQLCLR."}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["В статье мы пройдем весь путь от подготовки клиентской библиотеки и ее корректной установки в среде CLR для SQL Server, до установки расширения и его использования различными способами. Для тех, кто хочет сразу посмотреть на готовую библиотеку и примеры использования - прошу перейти к GitHub на ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Readme.md",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"страницу проекта"})})}),"."]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Для любопытных - добро пожаловать в дальнейшее путешествие! Настало время погрузиться в перекрестный мир .NET / SQL Server / ClickHouse!"})]}),(0,l.jsxs)("section",{id:"section-show-me-cards",children:[(0,l.jsx)(s.xv,{id:"show-me-cards",title:!0,className:"mt-10 md:text",children:"Раскройте все карты"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Существуют различные пути реализовать интеграцию SQL Server с базами ClickHouse. Вот самые распространенные решения:",(0,l.jsxs)(s.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Выгрузка данных из SQL Server в файлы и их последующая загрузка в ClickHouse."})," Это могут быть обычные csv / tsv файлы, которые ClickHouse обрабатывает достаточно эффективно. Выгрузку из SQL Server можно выполнять ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/SQL-Server-BCP",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"средствами штатной утилиты BCP"})})})," или любым другим удобным способом."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Linked Server"})," - еще одно решение. Со стороны SQL Server можно подключить инстанс / базы ClickHouse в качестве Linked Server'а и работать с ней через обычные запросы T-SQL, но, к сожалению, с существенными ограничениями. Более подробную информацию ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/ClickHouseTools/tree/main/CH-Integration",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"можно найти здесь"})})}),", в том числе ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/ClickHouse/clickhouse-odbc/blob/master/test/mssql.linked.server.sql",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"пример настройки"})})}),". Работа с ClickHouse при это будет выполняться через ODBC-драйвер, а обработку типов и вообще любой результат запроса нужно будет обрабатывать вручную."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Подключение ClickHouse к SQL Server через ODBC"})," - еще один альтернативный способ интеграции. Можно делать запросы через ODBC-драйвер со стороны ClickHouse до SQL Server. Для этого можно либо использовать конструкцию:",(0,l.jsx)(i.Z,{code:"\nselect * from odbc([СтрокаПодключенияКSQLServer],[Схема],[ИмяТаблицы])\n                                ",className:"my-5",language:"sql"}),"Либо создать таблицу с движком OBDC. Дополнительную информацию можно узнать в ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://clickhouse.com/docs/knowledgebase/how-to-set-up-ch-on-docker-odbc-connect-mssql",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"официальной документации"})})}),"."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Промежуточное ПО"})," - можно создать свое или купить готовое ПО, которое выступит посредником в передаче данных между SQL Server и ClickHouse (в обоих направлениях). Тут уже все ограничено лишь воображением, готовыми техническими инструментами для выбранного языка / платформы, ну и, конечно же, бюджетом!"]})]})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Но мы пойдем другим путем, чтобы получить большую гибкость в функционале и крутые фичи в виде операций BULK INSERT из SQL Server в ClickHouse! В прошлой статье ",(0,l.jsx)(s.e9,{newTab:!0,href:"/pages/blog/.NET/2024-09/simple-and-fast-sql-clr.tsx",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:'"Расширение для SQL Server. Быстро и просто. SQLCLR снова в деле"'})})})," мы уже рассмотрели процесс создания простого расширения SQLCLR для SQL Server. Так почему бы не пойти тем же путем и не организовать работу с ClickHouse из SQL Server этим же способом?"]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Задача эта не так проста, как кажется на первый взгляд. Ведь среда CLR, которую использует SQL Server, весьма ограничена в возможностях, а также базируется на устаревшем .NET Framework 4.x. Да что уж тут говорить, если даже не все стандартные сборки доступны для использования из этой среды."}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Но, если очень захотеть, то все преграды можно обойти! Займемся же этим!"})]}),(0,l.jsxs)("section",{id:"section-sqlclr-and-legacy",children:[(0,l.jsx)(s.xv,{id:"sqlclr-and-legacy",title:!0,className:"mt-10 md:text",children:"SQLCLR и мир легаси"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Мы работаем с SQLCLR, среда выполнения которого имеет собственные ограничения. Какие? Их много, но нас интересуют следующие:",(0,l.jsxs)(s.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Использование среды выполнения .NET Framework 4.x"})," - в конфигурационном файле ",(0,l.jsx)("b",{children:"sqlservr.exe.config"}),", расположенном в каталоге исполняемых файлов SQL Server (например по пути ",(0,l.jsx)("b",{children:'"C:\\Program Files\\Microsoft SQL Server\\MSSQL15.MSSQLSERVER\\MSSQL\\Binn\\sqlservr.exe.config"'}),", который зависит от версии SQL Server), указывается версия .NET Framework 4.x:",(0,l.jsx)(i.Z,{code:'\n<?xml version ="1.0"?>\n<configuration>\n    <startup useLegacyV2RuntimeActivationPolicy="true">\n        <supportedRuntime version="v4.0" />\n    </startup>\n    <runtime>\n        <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">\n            <dependentAssembly>\n              <assemblyIdentity name="Microsoft.SqlServer.Types" publicKeyToken="89845dcd8080cc91"/>\n              <publisherPolicy apply="no"/>\n              <bindingRedirect oldVersion="11.0.0.0-15.0.0.0" newVersion="15.0.0.0"/>\n            </dependentAssembly>\n        </assemblyBinding>\n      <disableCachingBindingFailures enabled="1" />\n      <CodeHeapReserveForJumpStubs value="5" />\n    </runtime>\n</configuration>\n \n\n                                ',className:"my-5",language:"xml"}),"То есть мы не можем использовать библиотеки и новые возможности современной версии платформы .NET (все, что начинается от .NET Core и до .NET 9+)."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Нет возможности использовать библиотеки .NET Standard"})," - это вытекает из предыдущего пункта, хоть и не очевидным образом. .NET Standard - это спецификация для всех реализаций .NET. И хотя спецификация версии 2.0 и ниже поддерживают .NET Framework 4.x, среда выполнения SQLCLR работы с .NET Standard не поддерживает. То есть мы не сможем использовать современные библиотеки .NET даже с поддержкой .NET Standard."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Ограниченная поддержка стандартных библиотек в среде SQLCLR"})," - не все стандартные библиотеки .NET Framework поддерживаются в среде SQLCLR, а значит мы не можем просто так ссылаться на них. Вот список библиотек, которые по умолчанию нам доступы:",(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:"mscorlib.dll"}),(0,l.jsx)("li",{children:"CustomMarshalers.dll"}),(0,l.jsx)("li",{children:"Microsoft.VisualBasic.dll"}),(0,l.jsx)("li",{children:"Microsoft.VisualC.dll"}),(0,l.jsx)("li",{children:"System.Configuration.dll"}),(0,l.jsx)("li",{children:"System.Core.dll"}),(0,l.jsx)("li",{children:"System.Data.OracleClient.dll"}),(0,l.jsx)("li",{children:"System.Data.SqlXml.dll"}),(0,l.jsx)("li",{children:"System.Data.dll"}),(0,l.jsx)("li",{children:"System.Deployment.dll"}),(0,l.jsx)("li",{children:"System.Security.dll"}),(0,l.jsx)("li",{children:"System.Transactions.dll"}),(0,l.jsx)("li",{children:"System.Web.Services.dll"}),(0,l.jsx)("li",{children:"System.Xml.Linq.dll"}),(0,l.jsx)("li",{children:"system.Xml.dll"}),(0,l.jsx)("li",{children:"System.dll"})]}),"Мы можем подключать сторонние сборки и обойти это ограничение, чем мы далее и займемся. Более подробную информацию Вы можете найти в ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/relational-databases/clr-integration/database-objects/supported-net-framework-libraries?view=sql-server-ver16",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"официальной документации"})})}),"."]})]})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Ограничения мы знаем, но как это влияет на нас? Первый важный шаг - это реализация клиентской библиотеки для отправки запросов в ClickHouse из среды .NET. Конечно, можно создать собственное решение на .NET Framework с нуля, но это долго. Очень долго. Поэтому возьмем готовую библиотеку ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/DarkWanderer/ClickHouse.Client",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"ClickHouse.Client"})})}),", но вот незадача - библиотека поддерживает работу из .NET Framework через .NET Standard. Но мы уже знаем, что SQLCLR такое не поддерживает."]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Выход только один - взять исходный код библиотеки и перевести её полностью на .NET Framework 4.x (например, версию 4.8). Причем важно учитывать и зависимости, на которые ссылается библиотека. Они также не должны содержать ссылок на неподдерживаемые версии .NET."}),(0,l.jsxs)(s.xv,{children:["На момент создания статьи была использована версия 7.9.1. Мы сделаем обзор основных шагов для адаптации библиотеки под .NET Framework, а финальную версию Вы можете сразу посмотреть ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"в готовом проекте расширения SQLCLR для ClickHouse"})})}),". Вот такие изменения были сделаны:"]}),(0,l.jsxs)(s.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Было выполнено понижение версий библиотек"})," из зависимостей, чтобы избавиться от ссылок на .NET Standard. Изменение версий существенное, но такова цена возврата к legacy:",(0,l.jsxs)(s.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Newtonsoft.Json"})," - установлена версия 8.0.3 взамен ",(0,l.jsx)("b",{children:"System.Text.Json"}),", которого для .NET Framework еще не существовало."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"NodaTime"})," - с версии 3.2.1 на 1.4.7, в которой имеется поддержка .NET Framework без поддержи современных реализаций .NET."]})]}),"Вот содержимое файла настроек зависимостей ",(0,l.jsx)("b",{children:"packages.config"}),":",(0,l.jsx)(i.Z,{code:'\n\uFEFF<?xml version="1.0" encoding="utf-8"?>\n<packages>\n  <package id="Newtonsoft.Json" version="8.0.3" targetFramework="net48" />\n  <package id="NodaTime" version="1.4.7" targetFramework="net48" />\n</packages>\n                            ',className:"my-5",language:"xml"}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Именно эти версии библиотек выбраны, потому что они самые последние из доступных, где есть только поддержка .NET Framework без ссылок на .NET Standard или более новые версии .NET."})]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Исключено использование новых возможностей платформы .NET:"}),(0,l.jsxs)(s.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"record struct"})," - убрано использование ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient/TypeSettings.cs",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:" неподдерживаемой конструкции"})})}),"."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Переезд на Newtonsoft.Json"})," - мы убрали ",(0,l.jsx)("b",{children:"System.Text.Json"})," и установили ",(0,l.jsx)("b",{children:"Newtonsoft.Json"}),", а значит нужно и изменить алгоритмы работы с JSON. Прмер файла ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient/ADO/ClickHouseCommand.cs",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"с изменением"})})}),".",(0,l.jsx)(i.Z,{code:"\n// Было\nreturn JsonSerializer.Deserialize<QueryStats>(value, SummarySerializerOptions);\n\n// Стало\nvar queryStats = JsonConvert.DeserializeObject<QueryStats>(value);\nreturn queryStats;\n                                    ",className:"my-5",language:"csharp"})]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ArrayPool"})," - эх, пришлось отказаться от ",(0,l.jsx)("b",{children:"ArrayPool"}),". Это пул переиспользуемых ресурсов для оптимизации потребления памяти. В .NET Framework об этих возможностях ничего неизвестно, а значит пришлось убрать его использование и вернуться к менее оптимальным алгоритмам. Больше всего пострадала пакетная обработка коллекций ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient/Utility/EnumerableExtensions.cs",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"класса EnumerableExtensions.cs"})})}),".",(0,l.jsx)(i.Z,{code:"\npublic static IEnumerable<(T[], int)> BatchRented<T>(this IEnumerable<T> enumerable, int batchSize)\n{\n    List<T> items = new List<T>();\n\n    //var array = ArrayPool<T>.Shared.Rent(batchSize);\n    int counter = 0;\n\n    foreach (var item in enumerable)\n    {\n        //array[counter++] = item;\n        counter++;\n        items.Add(item);\n\n        if (counter >= batchSize)\n        {\n            yield return (items.ToArray(), counter);\n            //yield return (array, counter);\n            counter = 0;\n            //array = ArrayPool<T>.Shared.Rent(batchSize);\n            items = new List<T>();\n        }\n    }\n    if (counter > 0)\n        //yield return (array, counter);\n        yield return (items.ToArray(), counter);\n}\n                                    ",className:"my-5",language:"csharp"}),"Класс используется при работе с операциями BULK INSERT, так что они станут менее оптимальными в части потребления ресурсов, но в целом все равно рабочими и эффективными."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Удалено использование стандартных классов логирования"})," - убрали использование ",(0,l.jsx)("b",{children:"Microsoft.Extensions.Logging"}),". Замену добавлять не стал. Относится к реализации ",(0,l.jsx)("b",{children:"ClickHouseConnection"}),", ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient/ADO/ClickHouseConnection.cs",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"вот файл этого класса"})})}),"."]}),(0,l.jsx)("li",{children:"И другие мелочи."})]})]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Включена поддержка C# 9.0"})," - это для поддержки некоторых новых функций из современного .NET, но в контексте .NET Framework. Например, это записи (records) и некоторые другие мелочи. В файле проекта ",(0,l.jsx)("b",{children:"ClickHouseClient.csproj"})," это достигнуто добавлением строки:",(0,l.jsx)(i.Z,{code:"\n<LangVersion>9.0</LangVersion>\n                            ",className:"my-5",language:"xml"}),"Здесь Вы ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient/ClickHouseClient.csproj",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"можете посмотреть файл полностью"})})}),"."]}),(0,l.jsx)("li",{children:"И другие мелкие изменения."})]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:'По большей части изменений не так уж и много. Вот она сила обратной совместимости .NET! Теперь у нас есть чистая версия библиотеки для .NET Framework 4 без каких-либо "подозрительных" зависимостей. А самое главное - совместимая со средой выполнения SQLCLR.'}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Но работа по погружению в мир legacy еще не окончена. Для работы с ClickHouse внутри библиотеки используется класс ",(0,l.jsx)("b",{children:"HttpClient"})," из пространства имен ",(0,l.jsx)("b",{children:"System.Net.Http"}),". Проблема в том, что в среде SQLCLR по умолчанию сборка с реализацией этого класса отсутствует. При попытке использования нашей адаптированной библиотеки мы получим ошибку вида:",(0,l.jsx)(i.Z,{code:"\nAssembly 'system.net.http, version=4.0.0.0, culture=neutral, publickeytoken=b03f5f7f11d50a3a.' was not found in the SQL catalog.\n                        ",className:"my-5",language:"text"}),"или",(0,l.jsx)(i.Z,{code:"\nAssembly 'System.Net.Http' could not be installed because existing policy would keep it from being used.\n                        ",className:"my-5",language:"text"}),"То есть эта сборка просто недоступна по умолчанию!"]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Это значит, что нам нужно эту сборку зарегистрировать! Но не все так просто. Убедившись, что .NET Framework 4.х установлен на машине вместе со SQL Server, нужно выполнить следующие действия ",(0,l.jsx)("b",{children:"в контексте базы данных"})," (пусть в примере будет база ",(0,l.jsx)("b",{children:"PowerSQLCLR"}),"), где потом будет установлено расширение SQLCLR:",(0,l.jsx)(i.Z,{code:"\n-- Этап 1. Включаем поддержку SQLCLR для инстанса SQL Server и доверие для базы данных.\nEXEC sp_configure 'clr enabled', 1;  \nRECONFIGURE;  \nGO  \nALTER DATABASE [PowerSQLCLR] SET TRUSTWORTHY ON;\nGO\n\n-- Этап 2. Подготавливаем сертификаты Microsoft для сборок .NET Framework.\n-- Этот шаг необходим для подключения стандартных сборок .NET\n-- к инстансу SQL Server. Для добавленного сертификата создаем\n-- служебную учетную запись и разрешаем работать со сборками.\nUSE [master];\n\nCREATE CERTIFICATE [MS.NETcer]\nFROM EXECUTABLE FILE =\n   'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\System.Net.Http.dll';\nGO\nCREATE LOGIN [MS.NETcer] FROM CERTIFICATE [MS.NETcer];\nGO \nGRANT UNSAFE ASSEMBLY TO [MS.NETcer];\nGO\nDENY CONNECT SQL TO [MS.NETcer]\nGO\nALTER LOGIN [MS.NETcer] DISABLE\nGO\n\n-- Этап 3. Добавляем стандартные сборки .NET Framework в служебную базу.\n-- Эти сборки необходимы для работы клиента ClickHouse.\nUSE [PowerSQLCLR];\n\nCREATE ASSEMBLY [System.Net.Http]\nFROM 'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\System.Net.Http.dll'\nWITH PERMISSION_SET = UNSAFE;\nGO\n\nCREATE ASSEMBLY [System.Web]\nFROM 'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\System.Web.dll'\nWITH PERMISSION_SET = UNSAFE;\nGO\n                        ",className:"my-5",language:"sql"}),"То есть мы выполнили следующие шаги:",(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:"Включили поддержку SQLCLR, если она еще не была включена."}),(0,l.jsx)("li",{children:"Зарегистрировали сертификат стандартных сборок .NET Framework для последующего импорта этих сборок."}),(0,l.jsxs)("li",{children:["Добавили стандартные сборки ",(0,l.jsx)("b",{children:"System.Net.Http"})," и ",(0,l.jsx)("b",{children:"System.Web"})," для корректной работы класса ",(0,l.jsx)("b",{children:"HttpClient"})]})]})]}),(0,l.jsx)(s.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2025-02/sqlserver-and-clickhouse-friendship/1. Сборки.png",alt:"Установленные сборки .NET в SQL Server",size:t.h2.SMALL}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Теперь все готово для непосредственного создания расширения SQLCLR. Все, что нужно в мире legacy, мы подготовили."})]}),(0,l.jsxs)("section",{id:"section-where-is-library",children:[(0,l.jsx)(s.xv,{id:"where-is-library",title:!0,className:"mt-10 md:text",children:"Как пройти в библиотеку?"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Вот мы вплотную подошли к непосредственному созданию библиотеки расширения SQLCLR, ведь все legacy-подготовки уже закончились. Мы не будем рассматривать базовые принципы создания расширений SQLCLR, ведь мы это делали уже в статье ",(0,l.jsx)(s.e9,{newTab:!0,href:"/pages/blog/.NET/2024-09/simple-and-fast-sql-clr.tsx",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Расширение для SQL Server. Быстро и просто. SQLCLR снова в деле"})})}),". Здесь мы сразу определимся, что собираемся реализовать."]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Наше расширение будет содержать следующие методы:",(0,l.jsxs)(s.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteScalar"})," - это скалярная функция, возвращающее первое значение из первой колонки по результатам выполнения запроса."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteSimple"})," - это табличная функция, возвращающая таблицу с единственной колонкой ",(0,l.jsx)("b",{children:"ResultValue"})," строкового типа, в котором содержатся значения произвольного запроса. Любой возвращаемый тип будет преобразован к строке. Если в первой колонке содержится кортеж ClickHouse с несколькими значениями, то значение будет преобразовано к строке JSON."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteStatement"})," - это хранимая процедура для выполнения любого выражения без возвращаемых значений. Например, для создания таблицы в базе ClickHosue."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteToTempTable"})," - выполнение произвольного запроса SELECT к ClickHouse с сохранением полученного результата во временную таблицу SQL Server."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteToGlobalTempTable"})," - выполнение произвольного запроса SELECT к ClickHouse с сохранением полученного результата во временную ГЛОБАЛЬНУЮ таблицу SQL Server."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteBulkInsertFromTempTable"})," - выполнение операции BULK INSERT в таблицу ClickHouse из подготовленного набора данных, которых хранится во временной таблице SQL Server."]})]})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Полную реализацию библиотеки расширения SQLCLR Вы можете посмотреть в проекте ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient.Entry",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"ClickHouseClient.Entry"})})}),", а ниже мы пробежимся по основным моментам её реализации. Верхний уровень реализации находится в файле ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient.Entry/EntryClickHouseClient.cs",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"EntryClickHouseClient.cs"})})}),"."]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Функция ",(0,l.jsx)("b",{children:"ExecuteScalar"})," самая простая в реализации. В качестве параметров получаем строку подключения к ClickHouse и текст запроса, а результатом будет срока со значением из запроса.",(0,l.jsx)(i.Z,{code:'\n/// <summary>\n/// Функция для выполнения запроса к ClickHouse и получения скалярного значения\n/// </summary>\n/// <param name="connectionString">Строка подключения к ClickHouse</param>\n/// <param name="queryText">SQL-текст запроса для выполнения</param>\n/// <returns>Результат запроса, представленный строкой</returns>\n[SqlFunction(DataAccess = DataAccessKind.Read)]\npublic static SqlChars ExecuteScalar(SqlChars connectionString, SqlChars queryText)\n{\n    string connectionStringValue = new string(connectionString.Value);\n    string queryTextValue = new string(queryText.Value);\n\n    string resultAsString = string.Empty;\n\n    using (var connection = new ClickHouseConnection(connectionStringValue))\n    {\n        var queryResult = connection.ExecuteScalarAsync(queryTextValue)\n            .GetAwaiter().GetResult();\n\n        resultAsString = queryResult.ToString();\n    }\n\n    return new SqlChars(resultAsString);\n}\n                        ',className:"my-5",language:"csharp"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Мы используем адаптированную ранее библиотеку ",(0,l.jsx)("b",{children:"ClickHouse.Client"})," и ее класс ",(0,l.jsx)("b",{children:"ClickHouseConnection"}),". Все просто, как дважды два!"]})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Функция ",(0,l.jsx)("b",{children:"ExecuteSimple"})," также простая в реализации, как и предыдущая. В качестве параметров получаем строку подключения к ClickHouse и текст запроса, а результатом будет коллекция строк, представляющих значения первой колонки запроса, преобразованные к строке (представление строки для примитивных типов и JSON для сложных типов).",(0,l.jsx)(i.Z,{code:'\n/// <summary>\n/// Функция для выполнения простого запроса.\n/// \n/// Возвращается только первая колонка из результата запроса в виде строки.\n/// </summary>\n/// <param name="connectionString">Строка подключения к ClickHouse</param>\n/// <param name="queryText">SQL-текст запроса для выполнения</param>\n/// <returns>Набор результата запроса (только первая колонка в виде строки)</returns>\n[SqlFunction(\n    FillRowMethodName = "ExecuteSimpleFillRow",\n    SystemDataAccess = SystemDataAccessKind.Read,\n    DataAccess = DataAccessKind.Read)]\npublic static IEnumerable ExecuteSimple(SqlChars connectionString, SqlChars queryText)\n{\n    List<ExecuteSimpleRowResult> resultRows = new List<ExecuteSimpleRowResult>();\n\n    string connectionStringValue = new string(connectionString.Value);\n    string queryTextValue = new string(queryText.Value);\n\n    using (var connection = new ClickHouseConnection(connectionStringValue))\n    {\n        using (var reader = connection.ExecuteReaderAsync(queryTextValue)\n            .GetAwaiter().GetResult())\n        {\n            while (reader.Read())\n            {\n                resultRows.Add(new ExecuteSimpleRowResult()\n                {\n                    ResultValue = ConvertTypeToSqlCommandType(reader.GetValue(0)).ToString()\n                });\n            }\n        }\n    }\n\n    return resultRows;\n}\npublic static void ExecuteSimpleFillRow(object resultRow, out SqlChars rowValue)\n{\n    var resultRowObject = (ExecuteSimpleRowResult)resultRow;\n    rowValue = new SqlChars(resultRowObject.ResultValue);\n}\n                        ',className:"my-5",language:"csharp"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Отличие от функции ",(0,l.jsx)("b",{children:"ExecuteScalar"})," в обработке результата запроса, где каждую строку мы преобразуем к объекту класса ",(0,l.jsx)("b",{children:"ExecuteSimpleRowResult"}),":",(0,l.jsx)(i.Z,{code:"\nnamespace YPermitin.SQLCLR.ClickHouseClient.Models\n{\n    public class ExecuteSimpleRowResult\n    {\n        public string ResultValue { get; set; }\n    }\n}\n                            ",className:"my-5",language:"csharp"}),"Преобразования значений к строке выполняем через метод ",(0,l.jsx)("b",{children:"ConvertTypeToSqlCommandType"}),", суть которого получение представления для примитивных типов и JSON-строки для сложных типов. Приводить здесь листинг не буду, вы можете посмотреть реализацию ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient.Entry/EntryClickHouseClient.cs",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"воооот здесь"})})}),"."]})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Хранимая процедура ",(0,l.jsx)("b",{children:"ExecuteStatement"})," еще проще в реализации, чем предыдущие примеры. Также принимает строку подключения к ClickHouse и текст запроса, но при выполнении не считывает результат, т.к. предназначена в основном для отправки DDL/DML-команд.",(0,l.jsx)(i.Z,{code:'\n/// <summary>\n/// Выполнение команды к ClickHouse без получения результата\n/// </summary>\n/// <param name="connectionString">Строка подключения к ClickHouse</param>\n/// <param name="queryText">SQL-текст команды</param>\n[SqlProcedure]\npublic static void ExecuteStatement(SqlChars connectionString, SqlChars queryText)\n{\n    string connectionStringValue = new string(connectionString.Value);\n    string queryTextValue = new string(queryText.Value);\n\n    using (var connection = new ClickHouseConnection(connectionStringValue))\n    {\n        var queryResult = connection.ExecuteStatementAsync(queryTextValue)\n            .GetAwaiter().GetResult();\n    }\n}\n                        ',className:"my-5",language:"csharp"}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Без комментариев, ведь нового тут ничего нет."})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:[(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Две хранимые процедуры ",(0,l.jsx)("b",{children:"ExecuteToTempTable"})," и ",(0,l.jsx)("b",{children:"ExecuteToGlobalTempTable"})," нужны для выполнения запроса SELECT к ClickHouse с целью сохранения результата в указанные и подготовленные заранее временные таблицы. Процедуры принимают строку подключения к ClickHouse, текст запроса к Clickhouse и имя временной таблицы для сохранения результата. Различий между ними немного:",(0,l.jsxs)(s.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteToTempTable"})," - предназначен для работы с ",(0,l.jsx)("b",{children:"локальными"})," временными таблицами, имена которых начинаются с #, а их жизненный цикл привязан к соединению, которое эту таблицу создало."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ExecuteToGlobalTempTable"})," - предназначен для работы с ",(0,l.jsx)("b",{children:"глобальными"})," временными таблицами, имена которых начинаются с ##, а их жизненный цикл не привязан к соединениям. То есть таблицы могут использоваться разными соединениями. Также этот вариант процедуры принимает четвертый параметр со строкой подключения SQL Server. Если указать этот параметр, то для сохранения результата запроса во временную таблицу будут использования операции BULK INSERT на стороне SQL Server, что ускорит работу. Так реализоано, потому что контекстное подключение не позволяет выполнять BULK-операции. Можно передать пустую строку, тогда будет использованы обычные конструкции INSERT."]})]})]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Вот листинг двух этих процедур."}),(0,l.jsx)(i.Z,{code:'\n/// <summary>\n/// Выполнение запроса к ClickHouse с сохранением результата во временную локальную таблицу\n/// </summary>\n/// <param name="connectionString">Строка подключения к ClickHouse</param>\n/// <param name="queryText">SQL-текст команды</param>\n/// <param name="tempTableName">Имя временной таблицы для сохранения результата</param>\n[SqlProcedure]\npublic static void ExecuteToTempTable(SqlChars connectionString, SqlChars queryText, SqlChars tempTableName)\n{\n    string tempTableNameValue = new string(tempTableName.Value);\n\n    if (!tempTableNameValue.StartsWith("#", StringComparison.InvariantCultureIgnoreCase))\n    {\n        throw new Exception("Temp table name should begin with # (local temp table)");\n    }\n    if (tempTableNameValue.StartsWith("##", StringComparison.InvariantCultureIgnoreCase))\n    {\n        throw new Exception("Temp table name should begin with # (local temp table). Global temp table with ## not supported by this method.");\n    }\n\n    ExecuteToTempTableInternal(connectionString, queryText, tempTableName, _emptyString);\n}\n\n/// <summary>\n/// Выполнение запроса к ClickHouse с сохранением результата во временную глобальную таблицу\n/// </summary>\n/// <param name="connectionString">Строка подключения к ClickHouse</param>\n/// <param name="queryText">SQL-текст команды</param>\n/// <param name="tempTableName">Имя временной таблицы для сохранения результата</param>\n/// <param name="sqlServerConnectionString">Строка подключения к SQL Server для выполнения BULK INSERT.\n/// Если передана пустая строка, то вставка во временную таблицу будет выполняться обычными инструкциями INSERT.\n/// </param>\n[SqlProcedure]\npublic static void ExecuteToGlobalTempTable(SqlChars connectionString, SqlChars queryText, SqlChars tempTableName, SqlChars sqlServerConnectionString)\n{\n    string tempTableNameValue = new string(tempTableName.Value);\n\n    if (!tempTableNameValue.StartsWith("##", StringComparison.InvariantCultureIgnoreCase))\n    {\n        throw new Exception("Temp table name should begin with ## (global temp table).");\n    }\n\n    ExecuteToTempTableInternal(connectionString, queryText, tempTableName, sqlServerConnectionString);\n}\n                        ',className:"my-5",language:"csharp"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Как вы можете заметить, вся фактическая реализация метода находится в ",(0,l.jsx)("b",{children:"ExecuteToTempTableInternal"}),". Листинг этого метода приводить здесь не будем, Вы можете посмотреть его ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient.Entry/EntryClickHouseClient.cs#L25",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"здесь"})})}),". Суть его в следующем:",(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:"Проверяем наличие временной таблицы."}),(0,l.jsx)("li",{children:"Открываем подключение к ClickHouse и выполняем запрос с обработкой результата."}),(0,l.jsx)("li",{children:"Если доступно использование BULK INSERT к SQL Server, то загружаем полученные записи из ClickHouse во временную таблицу таким образом. В противном случае выполняем команды INSERT для заполнения временной таблицы."})]})]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"После в скрипте T-SQL можно работать с полученными данными, выполняя запросы к этой временной таблице. Примеры работы будут представлены ниже."})]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:[(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["И последняя хранимая процедура ",(0,l.jsx)("b",{children:"ExecuteBulkInsertFromTempTable"})," для отправки данных из временной таблицы SQL Server в таблицу ClickHouse через BULK INSERT. Процедура принимает три параметра:",(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:"Строка подключения ClickHouse."}),(0,l.jsx)("li",{children:"Имя временной таблицы SQL Server."}),(0,l.jsx)("li",{children:"Имя таблицы ClickHouse для загрузки данных."})]})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["В библиотеке ",(0,l.jsx)("b",{children:"ClickHouse.Client"})," уже была реализация операции BULK INSERT в таблицу ClickHouse, ее мы и используем!"]}),(0,l.jsx)(i.Z,{code:'\n/// <summary>\n/// Операция массовой вставки данных из временной таблицы SQL Server\n/// в таблицу ClickHouse\n/// </summary>\n/// <param name="connectionString">Строка подключения к ClickHouse</param>\n/// <param name="sourceTempTableName">Имя временной таблицы с исходными данными</param>\n/// <param name="destinationTableName">Имя таблицы ClickHouse для вставки данных</param>\n[SqlProcedure]\npublic static void ExecuteBulkInsertFromTempTable(SqlChars connectionString, SqlChars sourceTempTableName, SqlChars destinationTableName)\n{\n    string connectionStringValue = new string(connectionString.Value);\n    string sourceTempTableNameValue = new string(sourceTempTableName.Value);\n    string destinationTableNameValue = new string(destinationTableName.Value);\n\n\n    using (SqlConnection sqlConnection = GetSqlConnection())\n    {\n        if (sqlConnection.State != ConnectionState.Open)\n        {\n            sqlConnection.Open();\n        }\n\n        List<object[]> rowsForInsert = new List<object[]>();\n\n        string tempTableSelectQuery =\n            @"\nSELECT * FROM " + sourceTempTableNameValue + @"\n";\n        using (SqlCommand tempTableReader = new SqlCommand(tempTableSelectQuery, sqlConnection))\n        {\n            tempTableReader.CommandType = CommandType.Text;\n\n            using (var reader = tempTableReader.ExecuteReader())\n            {\n                while (reader.Read())\n                {\n                    object[] rowValues = new object[reader.FieldCount];\n                    for (int i = 0; i < reader.FieldCount; i++)\n                    {\n                        var columnValue = reader.GetValue(i);\n                        rowValues[i] = columnValue;\n                    }\n                    rowsForInsert.Add(rowValues);\n                }\n            }\n        }\n\n        using (var connection = new ClickHouseConnection(connectionStringValue))\n        {\n            using (var bulkCopy = new ClickHouseBulkCopy(connection)\n            {\n                DestinationTableName = destinationTableNameValue,\n                BatchSize = 100000,\n                MaxDegreeOfParallelism = 1\n            })\n            {\n                bulkCopy.InitAsync().GetAwaiter().GetResult();\n                bulkCopy.WriteToServerAsync(rowsForInsert).GetAwaiter().GetResult();\n            }\n        }\n    }\n}\n                            ',className:"my-5",language:"csharp"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Весь смысл процедуры в простых шагах:",(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:"Считываем все записи из указанной временной таблицы."}),(0,l.jsx)("li",{children:"Создаем коллекцию записей для отправки в ClickHouse."}),(0,l.jsx)("li",{children:"Вызываем операцию BULK INSERT в ClickHouse."})]})]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"И всё!"})]})}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Все функции и процедуры готовы! Всё наше расширение SQLCLR готово к установке и использованию!"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Напомню, что исходный код рабочей версии расширения можно ",(0,l.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-SQLCLR/Projects/ClickHouseClient/Libs/ClickHouseClient.Entry/EntryClickHouseClient.cs",children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"найти здесь"})})}),"."]})]}),(0,l.jsxs)("section",{id:"section-setup-and-config",children:[(0,l.jsx)(s.xv,{id:"setup-and-config",title:!0,className:"mt-10 md:text",children:"Установка и настройка"}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Библиотека готова, пора перейти к установке и настройке. В Visual Studio соберем проект в конфигурации ",(0,l.jsx)("b",{children:"Release"})," и получим следующие необходимые файлы:",(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:"NodaTime.dll"}),(0,l.jsx)("li",{children:"Newtonsoft.Json.dll"}),(0,l.jsx)("li",{children:"ClickHouseClient.dll"}),(0,l.jsx)("li",{children:"ClickHouseClient.Entry.dll"})]}),"Все эти файлы скопируем в каталог, например: ",(0,l.jsx)("b",{children:'"C:\\Share\\SQLCLR"'}),".",(0,l.jsx)(s.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2025-02/sqlserver-and-clickhouse-friendship/2. Файлы сборки расширения.png",alt:"Файлы сборки расширения",size:t.h2.MEDIUM})]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Теперь нужно установить и настроить сборку. Ранее мы показывали скрипты по установке стандартных сборок .NET Framework. Теперь мы рассмотрим скрипт со всеми шагами установки, в том числе по созданию объектов функций и процедур, через которые будет вызов методов расширения SQLCLR."}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Вот полный скрипт со всеми шагами установки и настройки расширения:",(0,l.jsx)(i.Z,{code:"\n-- Этап 1. Включаем поддержку SQLCLR для инстанса SQL Server и доверие для базы данных.\nEXEC sp_configure 'clr enabled', 1;  \nRECONFIGURE;  \nGO  \nALTER DATABASE [PowerSQLCLR] SET TRUSTWORTHY ON;\nGO\n\n-- Этап 2. Подготавливаем сертификаты Microsoft для сборок .NET Framework.\n-- Этот шаг необходим для подключения стандартных сборок .NET\n-- к инстансу SQL Server. Для добавленного сертификата создаем\n-- служебную учетную запись и разрешаем работать со сборками.\nUSE [master];\n\nCREATE CERTIFICATE [MS.NETcer]\nFROM EXECUTABLE FILE =\n   'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\System.Net.Http.dll';\nGO\nCREATE LOGIN [MS.NETcer] FROM CERTIFICATE [MS.NETcer];\nGO \nGRANT UNSAFE ASSEMBLY TO [MS.NETcer];\nGO\nDENY CONNECT SQL TO [MS.NETcer]\nGO\nALTER LOGIN [MS.NETcer] DISABLE\nGO\n\n-- Этап 3. Добавляем стандартные сборки .NET Framework в служебную базу.\n-- Эти сборки необходимы для работы клиента ClickHouse.\nUSE [PowerSQLCLR];\n\nCREATE ASSEMBLY [System.Net.Http]\nFROM 'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\System.Net.Http.dll'\nWITH PERMISSION_SET = UNSAFE;\nGO\n\nCREATE ASSEMBLY [System.Web]\nFROM 'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\System.Web.dll'\nWITH PERMISSION_SET = UNSAFE;\nGO\n\n-- Этап 4. Удаляем объекты расширения SQLCLR клиента ClickHouse,\n-- если они уже существуют. Ниже они будут созданы заново.\nUSE [PowerSQLCLR];\nDROP FUNCTION IF EXISTS [dbo].[fn_CHExecuteScalar];\nDROP FUNCTION IF EXISTS [dbo].[fn_CHExecuteSimple];\nDROP FUNCTION IF EXISTS [dbo].[fn_CHGetCreateTempDbTableCommand];\nDROP PROCEDURE IF EXISTS [dbo].[sp_CHExecuteToTempTable];\nDROP PROCEDURE IF EXISTS [dbo].[sp_CHExecuteToGlobalTempTable];\nDROP PROCEDURE IF EXISTS [dbo].[sp_CHExecuteStatement];\nDROP PROCEDURE IF EXISTS [dbo].[sp_CHExecuteBulkInsertFromTempTable];\nDROP ASSEMBLY IF EXISTS [ClickHouseClient.Entry];\nDROP ASSEMBLY IF EXISTS [ClickHouseClient];\nGO\n\n-- Этап 5. Создаем сборку клиента ClickHouse и расширения SQLCLR в служебной базе,\n-- а также все объекты для работы с ней.\n-- ВНИМАНИЕ!!! Путь к файлу DLL нужно актуализировать под ваше окружение.\nUSE [PowerSQLCLR];\n\nCREATE ASSEMBLY [ClickHouseClient]\n	FROM 'C:\\Share\\SQLCLR\\ClickHouseClient.dll'\n	WITH PERMISSION_SET = UNSAFE;\nGO\n\nCREATE ASSEMBLY [ClickHouseClient.Entry]\n	FROM 'C:\\Share\\SQLCLR\\ClickHouseClient.Entry.dll'\n	WITH PERMISSION_SET = UNSAFE;\nGO\n\nCREATE FUNCTION [fn_CHExecuteScalar](\n	@connectionString nvarchar(max),\n	@queryText nvarchar(max)\n) \nRETURNS nvarchar(max)   \nAS EXTERNAL NAME [ClickHouseClient.Entry].[YPermitin.SQLCLR.ClickHouseClient.Entry.EntryClickHouseClient].[ExecuteScalar];   \nGO\n\nCREATE FUNCTION [dbo].[fn_CHExecuteSimple](\n	@connectionString nvarchar(max),\n	@queryText nvarchar(max)\n)  \nRETURNS TABLE (\n	[ResultValue] nvarchar(max)\n)\nAS   \nEXTERNAL NAME [ClickHouseClient.Entry].[YPermitin.SQLCLR.ClickHouseClient.Entry.EntryClickHouseClient].[ExecuteSimple];\nGO\n\nCREATE FUNCTION [fn_CHGetCreateTempDbTableCommand](\n	@connectionString nvarchar(max),\n	@queryText nvarchar(max),\n	@tempTableName nvarchar(max)\n) \nRETURNS nvarchar(max)   \nAS EXTERNAL NAME [ClickHouseClient.Entry].[YPermitin.SQLCLR.ClickHouseClient.Entry.EntryClickHouseClient].[GetCreateTempDbTableCommand];   \nGO\n\nCREATE PROCEDURE [dbo].[sp_CHExecuteStatement]\n(\n	@connectionString nvarchar(max),\n	@queryText nvarchar(max)\n)\nAS EXTERNAL NAME [ClickHouseClient.Entry].[YPermitin.SQLCLR.ClickHouseClient.Entry.EntryClickHouseClient].[ExecuteStatement];\nGO\n\nCREATE PROCEDURE [dbo].[sp_CHExecuteToTempTable]\n(\n	@connectionString nvarchar(max),\n	@queryText nvarchar(max),\n	@tempTableName nvarchar(max)\n)\nAS EXTERNAL NAME [ClickHouseClient.Entry].[YPermitin.SQLCLR.ClickHouseClient.Entry.EntryClickHouseClient].[ExecuteToTempTable];\nGO\n\nCREATE PROCEDURE [dbo].[sp_CHExecuteToGlobalTempTable]\n(\n	@connectionString nvarchar(max),\n	@queryText nvarchar(max),\n	@tempTableName nvarchar(max),\n	@sqlServerConnectionString nvarchar(max)\n)\nAS EXTERNAL NAME [ClickHouseClient.Entry].[YPermitin.SQLCLR.ClickHouseClient.Entry.EntryClickHouseClient].[ExecuteToGlobalTempTable];\nGO\n\nCREATE PROCEDURE [dbo].[sp_CHExecuteBulkInsertFromTempTable]\n(\n	@connectionString nvarchar(max),\n	@sourceTempTableName nvarchar(max),\n	@destinationTableName nvarchar(max)\n)\nAS EXTERNAL NAME [ClickHouseClient.Entry].[YPermitin.SQLCLR.ClickHouseClient.Entry.EntryClickHouseClient].[ExecuteBulkInsertFromTempTable];\nGO\n                            ",className:"my-5",language:"sql"})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Скрипт работает в 5 этапов:",(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:"Включаем поддержку SQLCLR для инстанса SQL Server и доверие для базы данных."}),(0,l.jsx)("li",{children:"Подготавливаем сертификаты Microsoft для сборок .NET Framework."}),(0,l.jsx)("li",{children:"Добавляем стандартные сборки .NET Framework в служебную базу."}),(0,l.jsx)("li",{children:"Удаляем объекты расширения SQLCLR клиента ClickHouse."}),(0,l.jsx)("li",{children:"Создаем сборку клиента ClickHouse и расширения SQLCLR в служебной базе, а также все объекты для работы с ней."})]})]}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Теперь мы можем работать с ClickHouse из T-SQL! Время пришло!"})]}),(0,l.jsxs)("section",{id:"section-queries",children:[(0,l.jsx)(s.xv,{id:"queries",title:!0,className:"mt-10 md:text",children:"Запросы, запросы, запросы"}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Вот несколько примеров, где мы из T-SQL выполним несколько запросов к ClickHouse. Воспользуемся всеми методами, которые мы реализовали выше."}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Получаем версию ClickHouse.",(0,l.jsx)(i.Z,{code:"\nSELECT [PowerSQLCLR].[dbo].[fn_CHExecuteScalar](\n		-- Строка подключения\n		'Host=yy-comp;Port=8123;Username=default;password=;Database=default;',\n		-- текст запроса\n		'select version()')\n\n-- Пример результата:\n-- 25.2.1.2434\n                        ",className:"my-5",language:"sql"})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Пример выполнения простого запроса, который возвращает одну колонку. Для возврата нескольких колонок используется кортеж, сериализованный в JSON. В T-SQL полученные элементы JSON разбираются конструкциями SQL Server.",(0,l.jsx)(i.Z,{code:"\nselect\n	JSON_VALUE(d.ResultValue, '$.Item1') AS [DatabaseName],\n	JSON_VALUE(d.ResultValue, '$.Item2') [Engine],\n	JSON_VALUE(d.ResultValue, '$.Item3') AS [DataPath],\n	CAST(JSON_VALUE(d.ResultValue, '$.Item4') AS uniqueidentifier) AS [UUID]\nfrom [PowerSQLCLR].[dbo].fn_CHExecuteSimple(\n	-- Строка подключения\n	'Host=yy-comp;Port=8123;Username=default;password=;Database=default;',\n	-- Запрос\n	'\nSELECT\n	tuple(name, engine, data_path,uuid)\nFROM `system`.`databases`\n'\n) d\n                        ",className:"my-5",language:"sql"})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Создаем временную таблицу и сохраняем в нее результат запроса.",(0,l.jsx)(i.Z,{code:"\nIF(OBJECT_ID('tempdb..#logs') IS NOT NULL)\n    DROP TABLE #logs;\nCREATE TABLE #logs\n(\n    [EventTime] datetime2(0),\n    [Query] nvarchar(max),\n    [Tables] nvarchar(max),\n    [QueryId] uniqueidentifier\n);\n\nEXECUTE [PowerSQLCLR].[dbo].[sp_CHExecuteToTempTable]\n		-- Строка подключения\n		'Host=yy-comp;Port=8123;Username=default;password=;Database=default;',\n		-- Текст запроса\n		'\nselect\n	event_time,\n	query,\n	tables,\n	query_id\nfrom `system`.query_log\nlimit 1000\n',\n		-- Имя временной таблицы для сохранения результата\n		'#logs';\n\n-- Считываем результат\nSELECT * FROM #logs\n                        ",className:"my-5",language:"sql"})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Создаем ГЛОБАЛЬНУЮ временную таблицу и сохраняем в нее результат запроса.",(0,l.jsx)(i.Z,{code:"\nIF(OBJECT_ID('tempdb..##logs') IS NOT NULL)\n    DROP TABLE ##logs;\nCREATE TABLE ##logs\n(\n    [EventTime] datetime2(0),\n    [Query] nvarchar(max),\n    [Tables] nvarchar(max),\n    [QueryId] uniqueidentifier\n);\n\nEXECUTE [PowerSQLCLR].[dbo].[sp_CHExecuteToGlobalTempTable]\n		-- Строка подключения\n		'Host=yy-comp;Port=8123;Username=default;password=;Database=default;',\n		-- Текст запроса\n		'\nselect\n	event_time,\n	query,\n	tables,\n	query_id\nfrom `system`.query_log\nlimit 1000\n',\n		-- Имя временной таблицы для сохранения результата\n		'##logs',\n		-- Строка подключения к SQL Server для BULK INSERT.\n		-- Строка контекстного подключения для этого не подходит.\n		'server=localhost;database=master;trusted_connection=true';\n\n-- Считываем результат\nSELECT * FROM ##logs\n                        ",className:"my-5",language:"sql"}),"При использовании глобальной таблицы можно достичь более высокой производительности за счет переноса в нее данных через BULK INSERT (если указана строка подключения к SQL Server)."]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Запуск произвольной команды без возвращения результата.",(0,l.jsx)(i.Z,{code:"\nEXECUTE [PowerSQLCLR].[dbo].[sp_CHExecuteStatement]\n	-- Строка подключения\n	'Host=yy-comp;Port=8123;Username=default;password=;Database=default;',\n	-- Запрос\n	'\nCREATE TABLE IF NOT EXISTS SimpleTable\n(\n	Id UInt64,\n	Period datetime DEFAULT now(),\n	Name String\n)\nENGINE = MergeTree\nORDER BY Id;\n'\n                        ",className:"my-5",language:"sql"})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Выполнение операции BULK INSERT в таблицу ClickHouse. Отправляется набор данных из временной таблицы.",(0,l.jsx)(i.Z,{code:"\nSET NOCOUNT ON;\n\n-- Создаем временную таблицу\nIF(OBJECT_ID('tempdb..#rowsForInsert') IS NOT NULL)\n	DROP TABLE #rowsForInsert;\nCREATE TABLE #rowsForInsert\n(\n    [Id] bigint,\n    [Period] datetime2(0),\n    [Name] nvarchar(max)\n);\n\n-- Заполняем набор данных\nWITH x AS (SELECT n FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(n))\nINSERT INTO #rowsForInsert\nSELECT \n	ROW_NUMBER() OVER (ORDER BY (SELECT NULL)),\n	GETDATE(),\n	'Value ' + CAST((ROW_NUMBER() OVER (ORDER BY (SELECT NULL))) as nvarchar(max))\nFROM x ones, x tens, x hundreds, x thousands\nORDER BY 1\n\n-- Отправляем в ClickHouse\nEXECUTE [PowerSQLCLR].[dbo].[sp_CHExecuteBulkInsertFromTempTable]\n	-- Строка подключения\n	'Host=yy-comp;Port=8123;Username=default;password=;Database=default;',\n	-- Имя временной таблицы с исходными данными\n	'#rowsForInsert',\n	-- Имя таблицы в ClickHouse для BULK INSERT\n	'SimpleTable'\n'\n                        ",className:"my-5",language:"sql"})]}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Вот и все примеры! Дело сделано, пути назад нет ",":)"]})]}),(0,l.jsxs)("section",{id:"section-thoughts",children:[(0,l.jsx)(s.xv,{id:"thoughts",title:!0,className:"mt-10 md:text",children:"Немного мыслей"}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Это было длинное путешествие, спасибо что прошли его вместе со мной!"}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Мы еще раз стали свидетелями мощи технологии SQLCLR. Несмотря на то, что сама технология уже перешла в статус legacy, т.к. больше не планируется её развития, но это не значит смерти SQLCLR. Ведь на его базе создано так много решений, что поддерживать его для совместимости в SQL Server будут еще многие десятилетия. Ломать - не строить! Microsoft будет беречь совместимость с этой технологией, а в будущем может и реализует ей замену в связке с современными версиями .NET (но это не точно)."}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"Дружба SQL Server + ClickHouse открывают большие возможности по интеграции двух СУБД и не только это! Мы можем открыть новые возможности использования SQL Server в приложениях, которые используют эту СУБД как основное хранилище данных. К этой теме мы еще вернемся в будущем."}),(0,l.jsxs)(s.xv,{textAlign:t.PH.JUSTIFY,children:["Оцените логотип новой СУБД в результате объединения функций SQL Server и ClickHouse ",":)))"]}),(0,l.jsx)(s.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2025-02/sqlserver-and-clickhouse-friendship/3. SQL Server + ClickHosue.png",alt:"SQL Server + ClickHouse",size:t.h2.XS}),(0,l.jsx)(s.xv,{textAlign:t.PH.JUSTIFY,children:"А на сегодня интернета достаточно! Удачи в делах и до скорых встреч!"})]}),(0,l.jsxs)("section",{id:"section-link",children:[(0,l.jsx)(s.xv,{id:"link",title:!0,className:"mt-10 md:text",children:"Полезные ссылки"}),(0,l.jsxs)(s.aV,{children:[(0,l.jsx)("li",{children:(0,l.jsxs)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/ClickHouseTools/tree/main/CH-Integration",children:[(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Интеграция"})})," - интеграция ClickHouse с другими СУБД или информационными системами.."]})}),(0,l.jsx)("li",{children:(0,l.jsxs)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/ClickHouseTools",children:[(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"ClickHouseTools"})})," - инструменты обслуживания и разработки для Yandex ClickHouse, а также другие интересности."]})}),(0,l.jsx)("li",{children:(0,l.jsxs)(s.e9,{newTab:!0,href:"/pages/blog/.NET/2024-09/simple-and-fast-sql-clr.tsx",children:[(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:"Расширение для SQL Server. Быстро и просто. SQLCLR снова в деле"})})," - создание простого расширения SQLCLR на сквозном примере."]})})]})]})]})},12250:function(e,n,r){"use strict";var l,s;r.d(n,{b:function(){return l}}),(s=l||(l={})).Min="350px",s.Standard="700px",s.Large="1000x",s.Unlimited=""},13803:function(e,n,r){"use strict";var l=r(37340),s=r(85893),i=r(67294),t=r(14965),c=r(54951),a=r(41686),o=r(12250);function d(){let e=(0,l._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return d=function(){return e},e}function u(){let e=(0,l._)(["\n        max-height: ","\n    "]);return u=function(){return e},e}n.Z=e=>{let{code:n,className:l,language:S,maxHeight:x=o.b.Standard}=e;(void 0!==r.g?r.g:window).Prism=t.p1,r(61354),r(79016),r(2731),r(35266),r(92927),r(51315),r(57874),r(86862);let m=null!=x?x:o.b.Standard,h=a.ZP.pre(d()),T=(0,a.ZP)(h)(u(),m);return(0,s.jsx)("div",{className:(0,c.GF)("bg-blue-500 md:p-1 p-2",l),children:(0,s.jsx)("div",{className:"shadow-lg",children:(0,s.jsx)(t.y$,{theme:t.np.vsDark,code:n.trim(),language:null!=S?S:S="tsx",children:e=>{let{className:n,style:r,tokens:l,getLineProps:t,getTokenProps:c}=e;return(0,s.jsx)(T,{className:n,style:r,children:l.map((e,n)=>(0,i.createElement)("div",{...t({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,i.createElement)("span",{...c({token:e,key:n}),key:Math.random()}))))})}})})})}},97037:function(e,n,r){"use strict";r.d(n,{Ee:function(){return c},Xg:function(){return i},Y7:function(){return u},aV:function(){return o},e9:function(){return d},o_:function(){return S},tf:function(){return x},ty:function(){return a},xv:function(){return t}});var l=r(5152),s=r.n(l);let i=s()(()=>Promise.all([r.e(549),r.e(4738),r.e(4838),r.e(1664),r.e(1274)]).then(r.bind(r,91274)),{loadableGenerated:{webpack:()=>[91274]}}),t=s()(()=>Promise.all([r.e(4454),r.e(7897)]).then(r.bind(r,97897)),{loadableGenerated:{webpack:()=>[97897]}}),c=s()(()=>Promise.all([r.e(3536),r.e(2726)]).then(r.bind(r,2726)),{loadableGenerated:{webpack:()=>[2726]}}),a=s()(()=>Promise.all([r.e(549),r.e(378)]).then(r.bind(r,90378)),{loadableGenerated:{webpack:()=>[90378]}}),o=s()(()=>Promise.all([r.e(9300),r.e(7200)]).then(r.bind(r,7200)),{loadableGenerated:{webpack:()=>[7200]}}),d=s()(()=>Promise.all([r.e(1664),r.e(8681)]).then(r.bind(r,28681)),{loadableGenerated:{webpack:()=>[28681]}});s()(()=>r.e(2857).then(r.bind(r,22857)),{loadableGenerated:{webpack:()=>[22857]}});let u=s()(()=>Promise.all([r.e(2004),r.e(3070)]).then(r.bind(r,63070)),{loadableGenerated:{webpack:()=>[63070]}}),S=s()(()=>Promise.all([r.e(162),r.e(3959),r.e(6050),r.e(239),r.e(727)]).then(r.bind(r,32215)),{loadableGenerated:{webpack:()=>[32215]}}),x=s()(()=>Promise.all([r.e(162),r.e(1664),r.e(3959),r.e(6050),r.e(4205)]).then(r.bind(r,84205)),{loadableGenerated:{webpack:()=>[84205]}})}},function(e){e.O(0,[4104,2888,9774,179],function(){return e(e.s=71698)}),_N_E=e.O()}]);