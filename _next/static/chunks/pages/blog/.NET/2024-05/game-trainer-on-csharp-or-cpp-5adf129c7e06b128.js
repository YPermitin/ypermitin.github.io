(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2941],{15726:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/.NET/2024-05/game-trainer-on-csharp-or-cpp",function(){return s(35576)}])},35576:function(e,n,s){"use strict";s.r(n);var r=s(85893),i=s(44853);s(67294);var t=s(74313),l=s(29209);n.default=()=>(0,r.jsxs)(i.Xg,{blogcentered:!0,children:[(0,r.jsxs)(i.xv,{textAlign:l.PH.RIGHT,quote:!0,children:["\xabВам случалось любоваться Матрицей? Ее гениальностью…\xbb",(0,r.jsx)("br",{}),"(с) Агент Смит."]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Создание простого трейнера для игры Grand Theft Auto 2 (GTA 2) на C++ и C#. Начинаем с небольшой порции теории и заканчиваем готовым приложением. Коснемся темы WinAPI и некоторых других нюансов."}),(0,r.jsx)(i.xv,{title:!0,className:"mt-10 md:text",children:"Содержание"}),(0,r.jsxs)(i.aV,{children:[(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{href:"#game-without-rules",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Игра не по правилам"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{href:"#win-api",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WinAPI нам поможет"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{href:"#cheat-engine",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Cheat Engine. Заглядываем внутрь игры"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{href:"#cpp",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Мир вращается вокруг C++"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{href:"#csharp",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Шаг к .NET и C#"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{href:"#final",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Радуемся результату"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{href:"#links",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Это интересно"})})})})]}),(0,r.jsx)(i.xv,{id:"game-without-rules",title:!0,className:"mt-10 md:text",children:"Игра не по правилам"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Игры остаются со мной большую часть жизни. Все начиналось с приключений в мирах ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/Nintendo_Entertainment_System",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"приставки NES"})})})," несколько десятилетий назад. Тогда было трудно представить, как далеко этот путь может завести. На дворе 2024 год и до сих пор приключения не закончились. Считаю это прекрасным фактом."]}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Недавно перепрошел всю серию игр Gtand Theft Auto ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/Grand_Theft_Auto_(%D0%B8%D0%B3%D1%80%D0%B0)",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:",начиная с 1 части"})})})," еще мира DOS и заканчивая ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/Grand_Theft_Auto_V",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"последней выпущенной версией GTA 5"})})}),". Даже прошел ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/Grand_Theft_Auto:_Vice_City_Stories",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"GTA: Vice City Stories"})})}),", выпущенную только на Play Station 2. Да, я фанат GTA!"]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:'Но речь сегодня не об этом. Погружаясь в другие миры, правильно принимать те правила, на которых этот мир построен. Иначе весь процесс не будет приносить удовольствия и удовлетворения, а смысл и посыл игры вообще может быть утерян. Поэтому официально заявляю, что я против читов и хулиганства в играх, особенно в онлайн. Но иногда читы все же не являются чем-то плохим. Например, если это просто веселье в однопользовательской игре, которую Вы перепрошли уже десятки раз. Самое главное, что таким "хулиганством" Вы не мешаете другим!'}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Поэтому мы будем создавать программу - трейнер для игры GTA 2, которая даст нам бесконечное количество денег в игре. Но это этичный хакинг игры, так как она однопользовательская, и мы никому этим действием не будем мешать. И да, если Вы не проходили GTA 2 до этого, то крайне не рекомендую пользоваться трейнером. Пройдите игру самостоятельно без жульничества! Вы только посмотрите на этот шедевр!"}),(0,r.jsx)(i.Y7,{className:"margin: 5px",url:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/1. GTA2.webm"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Ни в коем случае не пропагандирую такую езду! Будьте аккуратны на дорогах!"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Итак, мы погружаемся в мир взлома игр. Начнем с теории и коснемся внутреннего API операционной системы Windows. Далее перейдем к инструментам анализа работы игры. И уже после напишем трейнер на C++, чтобы почувствовать крупицу его мощи. И то же самое сделаем на C#."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Поехали брать виртуальный мир под контроль!"}),(0,r.jsx)(i.xv,{title:!0,id:"win-api",className:"mt-10 md:text",children:"WinAPI нам поможет"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Итак, наша задача написать трейнер для GTA 2. Его главной функцией будет увеличение суммы игровых денег до значения 9.999.999$ и фиксирование этого значения, чтобы наши финансы в игре стали неограниченными."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Мы не можем переписать исходный код игры, поэтому и пишем отдельную программу для этого. Трейнер будет вмешиваться в работу исходного процесса игры и исправлять нужные нам данные в памяти. Но как это можно достичь?"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Мы имеем дело с операционной системой Windows. Значит, для низкоуровневой работы нам придется обратиться к ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://ru.wikipedia.org/wiki/Windows_API",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WinAPI"})})})," - набору базовых интерфейсов ОС Windows, позволяющих работать с возможностями операционной системы напрямую из приложений. По факту, большая часть работы приложений, написанных на разных языках, в любом случае используют WinAPI для взаимодействия с ОС. И мы не будем исключением при решении нашей задачи."]}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Итак, обращаясь к документации WinAPI, мы можем выяснить, что нам понадобится ряд функций:",(0,r.jsxs)(i.aV,{children:[(0,r.jsxs)("li",{children:[(0,r.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-getwindowthreadprocessid",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"GetWindowThreadProcessId"})})})," - для получения идентификатора потока / процесса, создавшее окно. Оно нам понадобится, чтобы определить эти параметры для запущенной игры."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"OpenProcess"})})})," - для открытия запущенного процесса."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ReadProcessMemory"})})})," - для чтения памяти процесса."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WriteProcessMemory"})})})," - для записи (изменения) памяти процесса."]})]})]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Не переживайте, если назначение этих функций и вообще смысл WinAPI Вам сейчас не понятен. Мы посмотрим работу этих функций ниже на практике."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Самое важное сейчас - это понять, что с помощью этих функций WinAPI мы вмешаемся в работу процесса игры и будем изменять ее память так, как нам нужно. Процессы взламывают процессы..."}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Прежде чем перейти непосредственно к разработке, нам нужно проанализировать работу игры и понять что именно в памяти нужно изменять. Для этого нам поможет утилита ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://github.com/cheat-engine/cheat-engine",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Cheat Engine"})})}),"."]}),(0,r.jsx)(i.xv,{title:!0,id:"cheat-engine",className:"mt-10 md:text",children:"Cheat Engine. Заглядываем внутрь игры"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:[(0,r.jsx)(i.e9,{newTab:!0,href:"https://www.cheatengine.org/index.php",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"Cheat Engine"})})})," - программа, или даже окружение, для создания модов игр или других приложений. И только для персонального использования (как гласит официальное описание)!"]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:'Конечно, решить задачу можно и без этого инструмента, но тогда будет затрачено значительно больше времени на анализ приложения. В нашем же случае в этом нет никакого смысла, поэтому используем готовый инструмент без изобретения "костылей".'}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Многие помнят такую программу как ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://www.artmoney.ru/",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ArtMoney"})})})," - программу для редактирования параметров в компьютерных играх для бесконечных денег, жизней и других ресурсов. То же самое можно сделать и с помощью Cheat Engine. В контексте GTA 2 мы можем проделать этот трюк в несколько шагов.",(0,r.jsxs)(i.aV,{type:l.RH.number,children:[(0,r.jsx)("li",{children:"Запускаем игру, сворачиваем через Alt+Tab и запускаем Cheat Engine. Далее выбираем процесс игры."}),(0,r.jsx)("li",{children:'После выбора процесса начинаем поиск значения по команде "First Scan" - в нашем случае у нас было 226$. Программа найдет множества значений у запущенной игры.'}),(0,r.jsx)("li",{children:"Возвращаемся в игру и, немного поиграв, изменяем сумму денег. Например до 256$."}),(0,r.jsx)("li",{children:'Сворачиваем игру и выполняем повторный поиск по команде "Next Scan". В итоге будет найдено единственное значение в памяти, соответствующее прошлому и новому значению. Оно то нам и нужно!'}),(0,r.jsx)("li",{children:"Добавляем найденный адрес в памяти и значение в список адресов внизу экрана (двойным кликом)."}),(0,r.jsx)("li",{children:"Это целое значение (4 байта). Поменяем его значение и вернемся в игру посмотреть результат."}),(0,r.jsx)("li",{children:"Ура! Теперь мы богаты!"})]}),"Посмотрите все эти действия на видео ниже."]}),(0,r.jsx)(i.Y7,{className:"margin: 5px",url:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/2. Ручной взлом GTA 2.webm"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Возникает вопрос: а зачем писать дополнительно трейнер, если можно вручную делать все через Cheat Engine. Причин несколько:",(0,r.jsxs)(i.aV,{children:[(0,r.jsx)("li",{children:"Манипуляции с поиском и изменением значения нужно будет повторять каждый раз после перезапуска игры, потому что найденный адрес памяти со значением игровых денег будет изменяться."}),(0,r.jsx)("li",{children:"Могут быть и более сложные манипуляции с данными игры, которые повторять вручную никто не захочет."}),(0,r.jsxs)("li",{children:["Потому что это весело! Копаться в играх намного интереснее, чем в корпоративном софте ",":)","."]})]})]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Поэтому мы автоматизируем эти действия, но сначала нужно понять как универсальным способом искать нужный адрес памяти процесса игры, чтобы не повторять поиск значения, как мы делали выше."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Первое, что нужно знать - при запуске процесс игры получает некоторый начальный адрес в памяти, отталкиваясь от которого можно получать другие адреса памяти с некоторым смещением. Затем игра инициализирует внутренние структуры данных с информацией игры. В большинстве игр этот процесс относительно предсказуем, и мы можем найти указатель на нужный адрес памяти через постоянные смещения от начального адреса. Это описание очень упрощенное, но в целом отражает суть."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Как мы уже говорили, найденный нами адрес памяти для значения $$$ будет меняться каждый раз при запуске игры. Поэтому нам нужно найти стабильный указатель, который и будет тем путем, через который мы сможем контролировать наше финансовое благополучие в игре."}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["На помощь нам опять же приходит Cheat Engine, но в этот раз мы сделаем серию поисков значений с перезапуском процесса игры. На первом этапе найдем адрес памяти для изменения суммы игровых $$$, как это делали ранее в примере, но дополнительно сформируем карту указателей (pointmap) для дальнейшего анализа:",(0,r.jsxs)(i.aV,{type:l.RH.number,children:[(0,r.jsx)("li",{children:'Запускаем игру и "зарабатываем" начальное значение суммы денег. Например, у нас 30$.'}),(0,r.jsx)("li",{children:'Запускаем Cheat Engine, подключаемся к процессу игры и находим возможные значения в памяти игры через "New Scan".'}),(0,r.jsx)("li",{children:'Затем в игре изменяем сумму $$$, например, на 40 и ищем адрес в памяти повторно через "Next Scan". В примере нам не повезло и мы получили два адреса в памяти. Для поиска точного адреса сначала мы изменили значение у первого найденного элемента, но сумму $$$ это никак не повлияло. Затем попробовали на втором найденном элементе и все получилось. Теперь у нас есть точный адрес в памяти для изменения значения суммы игровых денег. Для удобства задали описание для найденного адреса на "Money 1".'}),(0,r.jsx)("li",{children:'И на последнем шаге мы у найденного адреса выбрали "Generate pointmap" для создания карты указателей для найденного адреса и сохранили результат в файл. Эта информация нам будет нужна для повторного анализа процесса после перезапуска игры.'}),(0,r.jsx)("li",{children:"Закрываем игру. Но Cheat Engine оставляем запущенным!"})]}),"Ниже наглядное представление всех этих действий.",(0,r.jsx)(i.Y7,{className:"margin: 5px",url:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/3. Исследуем игру №1.webm"}),"Первый этап закончен, идем дальше."]}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["На втором этапе нам нужно частично повторить действия:",(0,r.jsxs)(i.aV,{type:l.RH.number,children:[(0,r.jsx)("li",{children:"Запускаем игру заново и зарабатываем первую сумму $$$, например, 45$."}),(0,r.jsx)("li",{children:"Возвращаемся в Cheat Engine, подключаемся к новому процессу игры и ищем новое значение."}),(0,r.jsx)("li",{children:"Возвращаемся в игру, изменяем сумму $$$, например, до 75$."}),(0,r.jsx)("li",{children:'Возвращаемся в Cheat Engine, находим новый адрес памяти со значением $$$ и добавляем его в список адресов. В примере мы нашли изначально два адреса, как это происходило у нас в самом начале. Сразу выбрали второй адрес "наугад" и проверили, что именно он указывает на фактическую сумму игровых денег, изменив сумму на 666$. Сработало! Для удобства даем имя найденному адресу "Money 2".'}),(0,r.jsx)("li",{children:'Выполняем команду "Pointer scan for this address" для поиска указателей на найденны адрес (Money 2), но при этом нужно учесть ранее сохраненную карту указателей в файл. Для этого в настройках сканера выбираем "Compare results with other saved pointermap(s)" и выбираем ранее сохраненный файл "1.scandata". Программа автоматически подставит адрес "Money 1" для этого файла, который был найден на первом этапе. Это нам и нужно! Результат поиска сохраняем опять же в файл, можете назвать его как угодно.'}),(0,r.jsx)("li",{children:'В результате мы получим множество найденных указателей, почти 6.5 тысяч! Отсортируем их по возрастанию по колонке "Offset 1" и увидим, что есть два указателя с самым "коротким" (в плане количества смещений) путем до нужного значения. Добавим двойным кликом их в список адресов.'}),(0,r.jsx)("li",{children:"Предположительно у нас есть надежные указатели на значение игровых денег, которые будут сохраняться после перезапуска процесса. Но мы это проверим на 3 этапе."}),(0,r.jsx)("li",{children:"Закрываем игру. Но Cheat Engine оставляем запущенным!"})]}),"Ниже наглядное представление этих шагов.",(0,r.jsx)(i.Y7,{className:"margin: 5px",url:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/4. Исследуем игру №2.webm"}),"Второй этап закончен, проверим что найденные указатели действительно работают."]}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["На последнем третьем этапе проверим, что мы собрали надежные указатели.",(0,r.jsxs)(i.aV,{type:l.RH.number,children:[(0,r.jsx)("li",{children:"Запускаем игру повторно и зарабатываем любую начальную сумму игровых денег."}),(0,r.jsx)("li",{children:"Возвращаемся в Cheat Engine и переподключаемся к новому игровому процессу."}),(0,r.jsx)("li",{children:"В добавленных указателях в списке адресов появилось значение актуальной суммы $$$ в игре, хотя процесс уже новый!"}),(0,r.jsx)("li",{children:"Повторим действие. Вернемся в игру и заработаем еще немного $$$. После свернем игру и посмотрим на значения указателей. Все корректно, значения обновились до актуальных!"}),(0,r.jsx)("li",{children:"Обновим значение одного из указателей до 777$. При этом как в самой игре, так и в обоих ранее найденных указателях мы получим новое значение."}),(0,r.jsx)("li",{children:"Мы можем использовать оба указателя для контроля игровых финансов! Успех!"})]}),"Наглядно эти действия ниже. Вы только посмотрите на сколько суровая игра, в те времена было принято ездить на капоте авто! ",":)",(0,r.jsx)(i.Y7,{className:"margin: 5px",url:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/5. Исследуем игру №3.webm"}),"Теперь у нас есть все что нужно для создания трейнера."]}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Но какой из двух указателей выбрать? Ответ очень просто: любой! В нашем случае они оба рабочие. В дальнейших примерах мы будем использовать первый вида:",(0,r.jsx)(t.Z,{code:'\n"GTA2.EXE" + 002649A8 + 188\n                    ',className:"my-5",language:"text"}),(0,r.jsx)(i.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/6. Выбранный указатель.png",alt:"Выбранный указатель",size:l.h2.MEDIUM}),"В примере с C++ это уже будет объесняно детальней."]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Теперь у нас есть все данные, чтобы автоматизировать изменение денег с помощью трейнера."}),(0,r.jsx)(i.xv,{id:"cpp",title:!0,className:"mt-10 md:text",children:"Мир вращается вокруг C++"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Начнем с написания трейнера на C++. Окружение для разработки у нас будет простейшее:",(0,r.jsxs)(i.aV,{children:[(0,r.jsx)("li",{children:"Visual Studio Code"}),(0,r.jsx)("li",{children:"Mingw-w64"}),(0,r.jsxs)("li",{children:["И некоторые другие составляющие части ",":)"]})]}),"В детали погружаться не будем. Если Вам нужно настроить окружение, то проделайте все, что сказано в ",(0,r.jsx)(i.e9,{newTab:!0,href:"https://code.visualstudio.com/docs/languages/cpp",children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"этой документации"})})}),"."]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Создаем в VSCode файл main.cpp с простым содержимым."}),(0,r.jsx)(t.Z,{code:"\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    // 1. Находим процесс игры и получаем доступ к процессу\n\n    // 2. Находим базовый модуль и его адрес\n\n    // 3. Рассчитываем адрес указателя с учетом первого смещения\n    // и получаем его значение\n\n    // 4. Рассчитываем адрес указателя на значение игровых денег\n    // с учетом смещения\n\n    // 5. Считываем текущее значение суммы игровых денег.\n\n    // 6. Изменяем значение на 9 999 999.\n\n    // 7. Затем раз в секунду проверяем изменилось ли значение и если есть изменения,\n    // то возвращаем значение к 9 999 999. \n    // Выполняем этот цикл до тех пор, пока не будет нажата клавиша TAB.\n\n    return 0;\n}\n                ",className:"my-5",language:"cpp"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:'Здесь же мы сразу "набросали" план, что должна делать наша программа. Если кратко, то при запуске находит процесс игры, меняет в нем сумму денег на 9.999.999 и фиксирует это значение. Но все по порядку. Сначала найдем окно игры и получим доступ к ее процессу. Для этого нам как раз пригодятся функции WinAPI "FindWindowA", "GetWindowThreadProcessId" и "OpenProcess", о которых мы говорили в самом начале.'}),(0,r.jsx)(t.Z,{code:'\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    // 1. Находим процесс игры и получаем доступ к процессу\n    // Находим окно игры\n    HWND hwnd = FindWindowA(NULL, "GTA2");    \n    DWORD procID;\n    // Получаем идентификатор процесса\n    GetWindowThreadProcessId(hwnd, &procID);\n    // Получаем доступ к процессу. В результате получим дескриптор процесса.\n    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);\n    if(hwnd == 0x0 || processHandle == 0x0 || procID == 0)\n    {\n        cout << "Не найдено приложение "GTA 2". Процесс завершен.";\n        exit(0);\n    }\n\n    // 2. Находим базовый модуль и его адрес\n\n    // 3. Рассчитываем адрес указателя с учетом первого смещения\n    // и получаем его значение\n\n    // 4. Рассчитываем адрес указателя на значение игровых денег\n    // с учетом смещения\n\n    // 5. Считываем текущее значение суммы игровых денег.\n\n    // 6. Изменяем значение на 9 999 999.\n\n    // 7. Затем раз в секунду проверяем изменилось ли значение и если есть изменения,\n    // то возвращаем значение к 9 999 999. \n    // Выполняем этот цикл до тех пор, пока не будет нажата клавиша TAB.\n\n    return 0;\n}\n                ',className:"my-5",language:"cpp"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Теперь нужно получить базовый модуль процесса и его адрес для следующих вычислений. Теперь добавим функцию ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"GetBaseModule"})})," для удобства, она и получит базовый модуль, из которого мы извлечем базовый адрес. В комментариях найдете более детальную информацию."]}),(0,r.jsx)(t.Z,{code:'\n#include <iostream>\n\nusing namespace std;\n\nHMODULE GetBaseModule(const HANDLE hProcess) {\n	if (hProcess == NULL)\n		return NULL; // Нет доступа к процессу\n\n    // Массив для сохранения списка модулей\n	HMODULE lphModule[1024];\n    // Результат вызова EnumProcessModules.\n    // Указывает количество байт, необходимых для сохранения всех дескрипторов модулей массива lphModule\n	DWORD lpcbNeeded(NULL);\n\n    // Получение списка модулей\n    // https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules\n	if (!EnumProcessModules(hProcess, lphModule, sizeof(lphModule), &lpcbNeeded))\n		return NULL; // Не удалось прочитать информацию о модулях\n\n    // Получение пути файла для модуля.\n    // В качестве базового модуля используется первый в полученном списке.\n	TCHAR szModName[MAX_PATH];\n    // https://learn.microsoft.com/ru-ru/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa\n	if (!GetModuleFileNameEx(hProcess, lphModule[0], szModName, sizeof(szModName) / sizeof(TCHAR)))\n		return NULL; // Не удалось прочитать информацию о модулях\n\n    // Элемент модуля с индексом 0 практически всегда является самим исполняемым файлом,\n    // то есть базовым модулем процесса\n	return (HMODULE)lphModule[0];\n}\n\nint main()\n{\n    // 1. Находим процесс игры и получаем доступ к процессу\n    // Находим окно игры\n    HWND hwnd = FindWindowA(NULL, "GTA2");    \n    DWORD procID;\n    // Получаем идентификатор процесса\n    GetWindowThreadProcessId(hwnd, &procID);\n    // Получаем доступ к процессу. В результате получим дескриптор процесса.\n    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);\n    if(hwnd == 0x0 || processHandle == 0x0 || procID == 0)\n    {\n        cout << "Не найдено приложение "GTA 2". Процесс завершен.";\n        exit(0);\n    }\n\n    // 2. Находим базовый модуль и его адрес\n    HMODULE baseModule = GetBaseModule(processHandle);\n    ULONG_PTR baseModuleAddress = (ULONG_PTR)baseModule;\n\n    // 3. Рассчитываем адрес указателя с учетом первого смещения\n    // и получаем его значение\n\n    // 4. Рассчитываем адрес указателя на значение игровых денег\n    // с учетом смещения\n\n    // 5. Считываем текущее значение суммы игровых денег.\n\n    // 6. Изменяем значение на 9 999 999.\n\n    // 7. Затем раз в секунду проверяем изменилось ли значение и если есть изменения,\n    // то возвращаем значение к 9 999 999. \n    // Выполняем этот цикл до тех пор, пока не будет нажата клавиша TAB.\n\n    return 0;\n}\n                ',className:"my-5",language:"cpp"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Теперь самое время для вычисления итогового указателя на значение игровой валюты. Ранее мы писали, что будем использовать этот указатель:",(0,r.jsx)(t.Z,{code:'\n"GTA2.EXE" + 002649A8 + 188\n                    ',className:"my-5",language:"text"}),"Адрес базового модуля у нас уже есть в переменной ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"baseModuleAddress"})}),". Реализуем 3 и 4 шаги следующим образом."]}),(0,r.jsx)(t.Z,{code:'\n#include <iostream>\n\nusing namespace std;\n\nHMODULE GetBaseModule(const HANDLE hProcess) {\n	if (hProcess == NULL)\n		return NULL; // Нет доступа к процессу\n\n    // Массив для сохранения списка модулей\n	HMODULE lphModule[1024];\n    // Результат вызова EnumProcessModules.\n    // Указывает количество байт, необходимых для сохранения всех дескрипторов модулей массива lphModule\n	DWORD lpcbNeeded(NULL);\n\n    // Получение списка модулей\n    // https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules\n	if (!EnumProcessModules(hProcess, lphModule, sizeof(lphModule), &lpcbNeeded))\n		return NULL; // Не удалось прочитать информацию о модулях\n\n    // Получение пути файла для модуля.\n    // В качестве базового модуля используется первый в полученном списке.\n	TCHAR szModName[MAX_PATH];\n    // https://learn.microsoft.com/ru-ru/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa\n	if (!GetModuleFileNameEx(hProcess, lphModule[0], szModName, sizeof(szModName) / sizeof(TCHAR)))\n		return NULL; // Не удалось прочитать информацию о модулях\n\n    // Элемент модуля с индексом 0 практически всегда является самим исполняемым файлом,\n    // то есть базовым модулем процесса\n	return (HMODULE)lphModule[0];\n}\n\nint main()\n{\n    // 1. Находим процесс игры и получаем доступ к процессу\n    // Находим окно игры\n    HWND hwnd = FindWindowA(NULL, "GTA2");    \n    DWORD procID;\n    // Получаем идентификатор процесса\n    GetWindowThreadProcessId(hwnd, &procID);\n    // Получаем доступ к процессу. В результате получим дескриптор процесса.\n    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);\n    if(hwnd == 0x0 || processHandle == 0x0 || procID == 0)\n    {\n        cout << "Не найдено приложение "GTA 2". Процесс завершен.";\n        exit(0);\n    }\n\n    // 2. Находим базовый модуль и его адрес\n    HMODULE baseModule = GetBaseModule(processHandle);\n    ULONG_PTR baseModuleAddress = (ULONG_PTR)baseModule;\n\n    // 3. Рассчитываем адрес указателя с учетом первого смещения\n    // и получаем его значение\n    // Это указатель "GTA2.EXE" + 002649A8\n    ULONG_PTR basePointerAddressWithOffset = baseModuleAddress + 0x002649A8;\n    // Считываем значение этого указателя\n    int basePointer; // 165861172\n    ReadProcessMemory(processHandle, (LPVOID)basePointerAddressWithOffset, &basePointer, sizeof(basePointer), 0);\n\n    // 4. Рассчитываем адрес указателя на значение игровых денег\n    // с учетом смещения\n    // Это ЗНАЧЕНИЕ указателя ("GTA2.EXE" + 002649A8), которое мы получили выше\n    // и добавление к нему смещения 188 (0x4E8)\n    ULONG_PTR moneyPointerAddress = (ULONG_PTR)basePointer + 0x4E8;\n    // Считываем значение полученного указателя\n    int moneyPointer;\n    ReadProcessMemory(processHandle, (LPVOID)moneyPointerAddress, &moneyPointer, sizeof(moneyPointer), 0);\n\n    // 5. Считываем текущее значение суммы игровых денег.\n    int currentMoney;\n    ReadProcessMemory(processHandle, (LPVOID)moneyPointer, &currentMoney, sizeof(currentMoney), 0);\n\n    // 6. Изменяем значение на 9 999 999.\n\n    // 7. Затем раз в секунду проверяем изменилось ли значение и если есть изменения,\n    // то возвращаем значение к 9 999 999. \n    // Выполняем этот цикл до тех пор, пока не будет нажата клавиша TAB.\n\n    return 0;\n}\n                ',className:"my-5",language:"cpp"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["В этот раз мы вычислили цепочку указателей и получили финальное значение указателя на значение суммы игровых денег в переменную ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"moneyPointer"})}),". Чтение значения указателей мы выполняли через функцию WinAPI ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ReadProcessMemory"})}),", которую упомянали ранее."]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Также мы сразу добавили 5 шаг, считали текущую сумму денег в игре и вывели ее на консоль. Остались последние два шага по изменению найденного значения."}),(0,r.jsx)(t.Z,{code:'\n#include <iostream>\n\nusing namespace std;\n\nHMODULE GetBaseModule(const HANDLE hProcess) {\n	if (hProcess == NULL)\n		return NULL; // Нет доступа к процессу\n\n    // Массив для сохранения списка модулей\n	HMODULE lphModule[1024];\n    // Результат вызова EnumProcessModules.\n    // Указывает количество байт, необходимых для сохранения всех дескрипторов модулей массива lphModule\n	DWORD lpcbNeeded(NULL);\n\n    // Получение списка модулей\n    // https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules\n	if (!EnumProcessModules(hProcess, lphModule, sizeof(lphModule), &lpcbNeeded))\n		return NULL; // Не удалось прочитать информацию о модулях\n\n    // Получение пути файла для модуля.\n    // В качестве базового модуля используется первый в полученном списке.\n	TCHAR szModName[MAX_PATH];\n    // https://learn.microsoft.com/ru-ru/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa\n	if (!GetModuleFileNameEx(hProcess, lphModule[0], szModName, sizeof(szModName) / sizeof(TCHAR)))\n		return NULL; // Не удалось прочитать информацию о модулях\n\n    // Элемент модуля с индексом 0 практически всегда является самим исполняемым файлом,\n    // то есть базовым модулем процесса\n	return (HMODULE)lphModule[0];\n}\n\nint main()\n{\n    // 1. Находим процесс игры и получаем доступ к процессу\n    // Находим окно игры\n    HWND hwnd = FindWindowA(NULL, "GTA2");    \n    DWORD procID;\n    // Получаем идентификатор процесса\n    GetWindowThreadProcessId(hwnd, &procID);\n    // Получаем доступ к процессу. В результате получим дескриптор процесса.\n    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procID);\n    if(hwnd == 0x0 || processHandle == 0x0 || procID == 0)\n    {\n        cout << "Не найдено приложение "GTA 2". Процесс завершен.";\n        exit(0);\n    }\n\n    // 2. Находим базовый модуль и его адрес\n    HMODULE baseModule = GetBaseModule(processHandle);\n    ULONG_PTR baseModuleAddress = (ULONG_PTR)baseModule;\n\n    // 3. Рассчитываем адрес указателя с учетом первого смещения\n    // и получаем его значение\n    // Это указатель "GTA2.EXE" + 002649A8\n    ULONG_PTR basePointerAddressWithOffset = baseModuleAddress + 0x002649A8;\n    // Считываем значение этого указателя\n    int basePointer; // 165861172\n    ReadProcessMemory(processHandle, (LPVOID)basePointerAddressWithOffset, &basePointer, sizeof(basePointer), 0);\n\n    // 4. Рассчитываем адрес указателя на значение игровых денег\n    // с учетом смещения\n    // Это ЗНАЧЕНИЕ указателя ("GTA2.EXE" + 002649A8), которое мы получили выше\n    // и добавление к нему смещения 188 (0x4E8)\n    ULONG_PTR moneyPointerAddress = (ULONG_PTR)basePointer + 0x4E8;\n    // Считываем значение полученного указателя\n    int moneyPointer;\n    ReadProcessMemory(processHandle, (LPVOID)moneyPointerAddress, &moneyPointer, sizeof(moneyPointer), 0);\n\n    // 5. Считываем текущее значение суммы игровых денег.\n    int currentMoney;\n    ReadProcessMemory(processHandle, (LPVOID)moneyPointer, &currentMoney, sizeof(currentMoney), 0);\n\n    // 6. Изменяем значение на 9 999 999.\n    int fixMoney = 9999999;\n    WriteProcessMemory(processHandle, (LPVOID)moneyPointer, &fixMoney, sizeof(fixMoney), 0);\n\n    // 7. Затем раз в секунду проверяем изменилось ли значение и если есть изменения,\n    // то возвращаем значение к 9 999 999. \n    // Выполняем этот цикл до тех пор, пока не будет нажата клавиша TAB.\n    cout << "Для выхода нажмите TAB..." << endl;\n    // Сохраняем предыдущее значение денег для будущих сравнений.\n    // Через это значение будем определять было ли изменение $$$ в игре.\n    int previousMoney = currentMoney;\n    // Через функцию GetAsyncKeyState определяем была ли нажата указанная клавиша на момент вызова функции.\n    // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate\n    while(!GetAsyncKeyState(VK_TAB))\n    {\n        // Читаем текущее значение $$$ в игре\n        ReadProcessMemory(processHandle, (LPVOID)moneyPointer, &currentMoney, sizeof(currentMoney), 0);\n\n        // Если значение было изменено с момента последнего чтения,\n        // то выводим на экране текущее значение и возвращаем исходное.\n        if(previousMoney != currentMoney)\n        {\n            cout << "Текущая сумма денег: " << currentMoney << endl;\n            previousMoney = currentMoney;\n\n            WriteProcessMemory(processHandle, (LPVOID)moneyPointer, &fixMoney, sizeof(fixMoney), 0);\n            cout << "Сумма денег восстановлена до: " << fixMoney << endl;\n        }\n        // Ожидаем 1000 мс (1 сек).\n        Sleep(1000);\n    }\n\n    return 0;\n}\n                ',className:"my-5",language:"cpp"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["На 6 шаге устанавливаем сумму игровых денег на 9.999.999$, а далее в бесконечном цикле проверяем изменение суммы денег в игре. Если сумма изменилась, то выводим новое значение на экран, а после сбрасываем его к исходному 9.999.999$. Изменение памяти выполняем с помощью функции WinAPI ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WriteProcessMemory"})}),", о которой мы также говорили выше."]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Полный листинг программы как раз выше, можете запустить его самостоятельно! Код оставлен максимально топорным и простым, чтобы с ним можно было проще начать разбираться. Если поставить цель привести его в порядок, то нужно изменить преобразования типов, добавить дополнительные проверки при работе с функциями WinAPI и многое другое. Но преждевременными оптимизациями и улучшениями заниматься не будем, давайте лучше двигаться дальше."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Таким образом, у нас теперь бесконечная сумма денег и мы можем себя чувствовать как короли в Grand Theft Auto 2!"}),(0,r.jsx)(i.Y7,{className:"margin: 5px",url:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/7. C++ в деле.webm"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Эх, в жизни бы так! ",":)"]}),(0,r.jsx)(i.xv,{id:"csharp",title:!0,className:"mt-10 md:text",children:"Шаг к .NET и C#"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Мы сделали трейнер на C++, и он даже работает! Но нам этого недостаточно! Мы должны сделать трейнер на C# (.NET 8, хотя и другие версии в целом тоже подойдут). Давайте рассмотрим как из C# работать с функциями WinAPI и вообще в чем плюс его использования для подобных задач."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Создадим проект консольного приложения. Тут ничего сложного."}),(0,r.jsx)(i.Y7,{className:"margin: 5px",url:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/8. Создаем консольное приложение CSHARP.webm"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["В проекте нужно сделать две важных настройки:",(0,r.jsxs)(i.aV,{children:[(0,r.jsxs)("li",{children:["Целевую ОС установим в Windows, ведь игра и трейнер будут работать только в этой ОС, что логично. Мы ведь нацелены на работу с WinAPI.",(0,r.jsx)(i.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/9. Установка целевой платформы.png",alt:"Установка целевой платформы",size:l.h2.MEDIUM})]}),(0,r.jsxs)("li",{children:["Целевую платформу установим в x86. Игра GTA 2 создана для 32'битной платформы. Для корректной работы с типами наш трейнейр также будет 32'битным. Иначе могут возникнуть проблемы взаимодействия с памятью процесса игры.",(0,r.jsx)(i.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/10. Установка целевой платформы.png",alt:"Установка целевой платформы",size:l.h2.MEDIUM})]}),(0,r.jsxs)("li",{children:["Разрешаем небезопасный код для работы с функциями WinAPI, указателями и памятью.",(0,r.jsx)(i.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/11. Разрешаем небезопасный код.png",alt:"Разрешаем небезопасный код",size:l.h2.MEDIUM})]})]})]}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Затем создадим вспомогательный класс ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WinAPI"})})," для работы с функциями WinAPI ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ReadProcessMemory"})})," и ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WriteProcessMemory"})}),". В самом C# и плтформе .NET нет возможности работать с низкоуровневыми функциями и редактировть память процессов напрямую, т.к. это противоречит самой концепции упрaвляемых приложений. Но если очень хочется, то можно. Для этого в .NET есть такое понятие как небезопасный код. По факту код является небезопасным, если есть применение указателей, что не позволяет среде выполнения .NET автоматически управлять памятью, и эта задача полностью ложится на разработчика. Нас это устраивает при решении такой задачи."]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Содержимое класса WinAPI ниже."}),(0,r.jsx)(t.Z,{code:'\nusing System.Runtime.InteropServices;\n\nnamespace YPermitin.GTA2Trainer\n{\n    public static class WinAPI\n    {\n        /// <summary>\n        /// Чтение памяти процесса\n        /// </summary>\n        [DllImport("Kernel32.dll")]\n        static extern bool ReadProcessMemory(\n            IntPtr hProcess,\n            IntPtr lpBaseAddress,\n            [Out] byte[] lpBuffer,\n            int nSize,\n            IntPtr lpNumberOfBytesRead\n        );\n\n        /// <summary>\n        /// Запись памяти процесса\n        /// </summary>\n        [DllImport("kernel32.dll")]\n        static extern bool WriteProcessMemory(\n            IntPtr hProcess,\n            IntPtr lpBaseAddress,\n            byte[] lpBuffer,\n            int size,\n            IntPtr lpNumberOfBytesWritten\n        );\n\n        /// <summary>\n        /// Чтение указателя из памяти процесса по указанному адресу и смещению\n        /// </summary>\n        public static IntPtr ReadPointer(nint procHandle, IntPtr address, int offset)\n        {\n            byte[] buffer = new byte[4];\n            ReadProcessMemory(procHandle, address + offset, buffer, buffer.Length, IntPtr.Zero);\n            return (IntPtr)BitConverter.ToInt32(buffer);\n        }\n\n        /// <summary>\n        /// Чтение произвольного массива байт из памяти процесса по указанному адресу и смещению\n        /// </summary>\n        public static byte[] ReadBytes(nint procHandle, IntPtr address, int bytes)\n        {\n            byte[] buffer = new byte[bytes];\n            ReadProcessMemory(procHandle, address, buffer, buffer.Length, IntPtr.Zero);\n            return buffer;\n        }\n\n        /// <summary>\n        /// Чтение целочисленного значения (4 байта) из памяти процесса по указанному адресу\n        /// </summary>\n        public static int ReadInt(nint procHandle, IntPtr address)\n        {\n            return BitConverter.ToInt32(ReadBytes(procHandle, address, 4));\n        }\n\n        /// <summary>\n        /// Запись произвольного массива байт в память процесса по указанному адресу и смещению\n        /// </summary>\n        public static bool WriteBytes(nint procHandle, IntPtr address, byte[] newBytes)\n        {\n            return WriteProcessMemory(procHandle, address, newBytes, newBytes.Length, IntPtr.Zero);\n        }\n\n        /// <summary>\n        /// Запись целочисленного значения (4 байта) в память процесса по указанному адресу\n        /// </summary>\n        public static bool WriteInt(nint procHandle, IntPtr address, int value)\n        {\n            return WriteBytes(procHandle, address, BitConverter.GetBytes(value));\n        }\n    }\n}\n                ',className:"my-5",language:"csharp"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Это статический класс с 7 методами:",(0,r.jsxs)(i.aV,{children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ReadProcessMemory"})})," - чтение памяти процесса, фактически оберточный метод над одноименным методом WinAPI. Именно поэтому для него используется директива ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:'[DllImport("Kernel32.dll")]'})}),"."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WriteProcessMemory"})})," - запись памяти процесса, фактически оберточный метод над одноименным методом WinAPI. Именно поэтому для него используется директива ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:'[DllImport("Kernel32.dll")]'})}),"."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ReadPointer"})})," - вспомогательный метод для удобного чтения указателя из памяти процесса по указанному адресу и смещению."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ReadBytes"})})," - вспомогательный метод для удобного чтения произвольного массива байт из памяти процесса по указанному адресу и смещению."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"ReadInt"})})," - вспомогательный метод для удобного чтения целочисленного значения (4 байта) из памяти процесса по указанному адресу."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WriteBytes"})})," - вспомогательный метод для удобной записи произвольного массива байт в память процесса по указанному адресу и смещению."]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:"WriteInt"})})," - вспомогательный метод для удобной записи целочисленного значения (4 байта) в память процесса по указанному адресу."]})]}),"Первые два метода это фактически вызов методов WinAPI, которые мы описывали выше и уже использовали в трейнере на C++. Остальные методы это лишь удобный способ манипулирования данными указателей и целочисленными значениями."]}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Теперь структура нашего приложения выглядит следующим образом.",(0,r.jsx)(i.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/12. Структура проекта.png",alt:"Структура проекта",size:l.h2.MEDIUM}),'У нас есть класс вспомогательных функций "WinAPI", о котором мы говорили чуть выше, а также класс основной программы "Program". Переходим к последнему для финальных действий.']}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Фактически, нам нужно воспроизвести все то, что мы делали в трейнере на С++. С учетом добавленного вспомогательного класса WinAPI, основной код программы по объему будет меньше, чем аналогичный на C++. Но в целом с учетом всех модулей приложения разница не существенная. Ниже Вы можете видеть финальную версию программы с детальными комментариями."}),(0,r.jsx)(t.Z,{code:'\nusing System.Diagnostics;\nusing YPermitin.GTA2Trainer;\n\n// 1. Получаем объект процесса, дескриптор, базовый модуль и его адрес\nstring procName = "GTA2";\nProcess proc = Process.GetProcessesByName(procName).FirstOrDefault();\nif (proc == null)\n{\n    Console.WriteLine($"Не найдено приложение {procName}. Процесс завершен.");\n    return;\n}\nnint procHandle = proc.Handle;\nProcessModule baseModule = proc.MainModule;\nIntPtr baseModuleAddress = baseModule.BaseAddress;\n\n// 2. Рассчитываем адрес указателя с учетом первого смещения\n// и получаем его значение\nIntPtr basePointer = WinAPI.ReadPointer(procHandle, baseModuleAddress, 0x002649A8);\n\n// 3. Рассчитываем адрес указателя на значение игровых денег\n// с учетом смещения\nvar currentMoneyPointer = WinAPI.ReadPointer(procHandle, basePointer, 0x4E8);\n\n// 4. Считываем изначальное значение игровых денег и устанавливаем свое значение\nvar currentMoney = WinAPI.ReadInt(procHandle, currentMoneyPointer);\nConsole.WriteLine($"Исходное значение денег: {currentMoney}$");\nint fixMoney = 9999999;\nWinAPI.WriteInt(procHandle, currentMoneyPointer, fixMoney);\nint previousMoney = currentMoney;\n\n// Запускаем отслеживание игровых денег в отдельной фоновой задаче,\n// которая будет активной до тех пор, пока основной поток приложения не будет закрыт.\n// То есть пока пользователь не нажмет любую клавишу.\nTask task = Task.Run(() =>\n{\n    while (true)\n    {\n        // Читаем текущее значение $$$ в игре\n        currentMoney = WinAPI.ReadInt(procHandle, currentMoneyPointer);\n\n        // Если значение было изменено с момента последнего чтения,\n        // то выводим на экране текущее значение и возвращаем исходное.\n        if (currentMoney != previousMoney)\n        {\n            Console.WriteLine($"Текущая сумма денег: {currentMoney}$");\n            previousMoney = currentMoney;\n\n            WinAPI.WriteInt(procHandle, currentMoneyPointer, fixMoney);\n            Console.WriteLine($"Сумма денег восстановлена дог: {fixMoney}$");\n        }\n\n        // Ожидаем 1000 мс (1 сек).\n        Thread.Sleep(1000);\n    }\n});\n\nConsole.WriteLine("Для выхода нажмите любую клавишу...");\nConsole.ReadKey();\n                ',className:"my-5",language:"csharp"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"При запуске получим тот же результат, что и с вариантом на C++. Но если нет разницы, то зачем использовать C#?"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Плюсами использования платформы .NET (и в т.ч. C#) являются:",(0,r.jsxs)(i.aV,{children:[(0,r.jsx)("li",{children:"Удобное создание графического интерфейса для приложений. В отличии от C++ у .NET с технологиями WinForms, WPF, MAUI и др. намного проще, богаче и эффективнее инструментарий для создания настольных графических интерфейсов. В примерах мы ограничились консольными утилитами, т.к. для демо создавать GUI избыточно. Но чаще всего трейнеры поставляются пользователям в красивом виде, иначе ими просто не будут пользоваться."}),(0,r.jsx)("li",{children:"Возможность создания кроссплатформенных трейнеров. Хоть мы и ориентировались на Windows, в целом можно создать кросплатформенные решения как для *.nix-игр, так и для Mac, или для Android и т.д. В коде придется учитывать специфику, но технических преград к этому нет."}),(0,r.jsx)("li",{children:"C# проще при работе с WinAPI, хоть это может показаться и не так на первый взгляд. Достаточно сделать пару оберток, а затем использовать эти вспомогательные классы. Мы примерно так и сделали. Но, надо признать, при использовании C++ некоторые вещи работают прозрачнее."}),(0,r.jsxs)("li",{children:["В Вашем распоряжении будет вся мощь платформы .NET для удобного создания приложений, с любимым синтаксическим сахаром и отличной документацией ",":)"]}),(0,r.jsx)("li",{children:"И другие плюсы, но зависящие от контекста задачи."})]})]}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Таким образом, создание трейнеров на C# (.NET) отличный вариант."}),(0,r.jsx)(i.xv,{id:"final",title:!0,className:"mt-10 md:text",children:"Радуемся результату"}),(0,r.jsxs)(i.xv,{textAlign:l.PH.JUSTIFY,children:["Потрясающе! Мы создали два трейнера для Grand Theft Auto 2 и стали мультимиллионерами в этой вселенной! ",":)"]}),(0,r.jsx)(i.Ee,{className:"my-4",src:"/public/imp_assets/.NET/2024-05/game-trainer-on-csharp-or-cpp/13. Congratulations.png",alt:"Радуемся результату",size:l.h2.MEDIUM}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Все это лишь самые простые шаги в направлении модерства игр, создания трейнеров, хаков и просто исследования этих потрясающих приложений. Ведь сделать еще можно так много! Почему только деньги? Можно реализовать телепортацию, неуязвимость, изменение поведения NPC и проче, прочее, прочее."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"К тому же это занятие позволяет разобраться в работе операционных систем, процессов. Все, что мы делали сегодня для Windows, можно сделать и в *.nix, как уже говорилось ранее. И это еще интереснее!"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"На сегодня наше время подошло к концу. Спасибо, что дочитали! Надеюсь, что материал был Вам полезен."}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"Желаю Вам приятного времяприпровождения в играх, неугосающего интереса и отличного настроения!"}),(0,r.jsx)(i.xv,{textAlign:l.PH.JUSTIFY,children:"А мне пора проходить The Elder Scrolls: Morrowind..."}),(0,r.jsx)(i.xv,{id:"links",title:!0,className:"mt-10 md:text",children:"Это интересно"}),(0,r.jsxs)(i.aV,{children:[(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{newTab:!0,href:"https://www.cheatengine.org/",children:(0,r.jsx)("b",{children:"Cheat Engine"})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/",children:(0,r.jsxs)("b",{children:["Swed32 для .NET ","(","makes ReadProcessMemory and WriteProcessMemroy easier ",":))"]})})}),(0,r.jsx)("li",{children:(0,r.jsx)(i.e9,{newTab:!0,href:"https://www.youtube.com/playlist?list=PLTFAYsPdUBH2cyBkKiERt0mTHdszG3Ux6",children:(0,r.jsx)("b",{children:"\uD83D\uDD25Learn C# GameHacking \uD83E\uDD75\uD83D\uDD25"})})})]})]})},87855:function(e,n,s){"use strict";var r,i;s.d(n,{b:function(){return r}}),(i=r||(r={})).Min="350px",i.Standard="700px",i.Large="1000x",i.Unlimited=""},74313:function(e,n,s){"use strict";var r=s(37340),i=s(85893),t=s(67294),l=s(14965),d=s(41240),c=s(41686),o=s(87855);function a(){let e=(0,r._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return a=function(){return e},e}function x(){let e=(0,r._)(["\n        max-height: ","\n    "]);return x=function(){return e},e}n.Z=e=>{let{code:n,className:r,language:h,maxHeight:u=o.b.Standard}=e;(void 0!==s.g?s.g:window).Prism=l.p1,s(61354),s(79016),s(35266),s(92927),s(51315),s(57874),s(86862);let p=null!=u?u:o.b.Standard,m=c.ZP.pre(a()),j=(0,c.ZP)(m)(x(),p);return(0,i.jsx)("div",{className:(0,d.GF)("bg-blue-500 md:p-1 p-2",r),children:(0,i.jsx)("div",{className:"shadow-lg",children:(0,i.jsx)(l.y$,{theme:l.np.vsDark,code:n.trim(),language:null!=h?h:h="tsx",children:e=>{let{className:n,style:s,tokens:r,getLineProps:l,getTokenProps:d}=e;return(0,i.jsx)(j,{className:n,style:s,children:r.map((e,n)=>(0,t.createElement)("div",{...l({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,t.createElement)("span",{...d({token:e,key:n}),key:Math.random()}))))})}})})})}},44853:function(e,n,s){"use strict";s.d(n,{Ee:function(){return d},Xg:function(){return t},Y7:function(){return x},aV:function(){return o},e9:function(){return a},o_:function(){return h},tf:function(){return u},ty:function(){return c},xv:function(){return l}});var r=s(5152),i=s.n(r);let t=i()(()=>Promise.all([s.e(9686),s.e(4738),s.e(4838),s.e(1664),s.e(8765)]).then(s.bind(s,28765)),{loadableGenerated:{webpack:()=>[28765]}}),l=i()(()=>Promise.all([s.e(9511),s.e(935)]).then(s.bind(s,30935)),{loadableGenerated:{webpack:()=>[30935]}}),d=i()(()=>Promise.all([s.e(328),s.e(7651)]).then(s.bind(s,47651)),{loadableGenerated:{webpack:()=>[47651]}}),c=i()(()=>Promise.all([s.e(9686),s.e(6979)]).then(s.bind(s,16979)),{loadableGenerated:{webpack:()=>[16979]}}),o=i()(()=>Promise.all([s.e(4159),s.e(7355)]).then(s.bind(s,87355)),{loadableGenerated:{webpack:()=>[87355]}}),a=i()(()=>Promise.all([s.e(1664),s.e(3220)]).then(s.bind(s,53220)),{loadableGenerated:{webpack:()=>[53220]}});i()(()=>s.e(3140).then(s.bind(s,43140)),{loadableGenerated:{webpack:()=>[43140]}});let x=i()(()=>Promise.all([s.e(2004),s.e(736)]).then(s.bind(s,50736)),{loadableGenerated:{webpack:()=>[50736]}}),h=i()(()=>Promise.all([s.e(8331),s.e(8876),s.e(7354),s.e(839),s.e(5394),s.e(5533)]).then(s.bind(s,48641)),{loadableGenerated:{webpack:()=>[48641]}}),u=i()(()=>Promise.all([s.e(8331),s.e(1664),s.e(7354),s.e(839),s.e(8496)]).then(s.bind(s,48496)),{loadableGenerated:{webpack:()=>[48496]}})}},function(e){e.O(0,[6443,2888,9774,179],function(){return e(e.s=15726)}),_N_E=e.O()}]);