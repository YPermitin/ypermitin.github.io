(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1334],{73764:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/CPP/2024-11/cpp-control-child-processes-with-winapi",function(){return s(14146)}])},14146:function(e,n,s){"use strict";s.r(n);var i=s(85893),r=s(97037);s(67294);var t=s(13803),c=s(46416),l=s(12250);n.default=()=>(0,i.jsxs)(r.Xg,{blogcentered:!0,children:[(0,i.jsxs)(r.xv,{textAlign:c.PH.RIGHT,quote:!0,children:["Человек лучше всего следит за собой тогда, когда другие следят за ним тоже.",(0,i.jsx)("br",{}),"(с) Джордж Сэвил Галифакс"]}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Небольшой пример контроля дочерних процессов в Windows с помощью C++ и WinAPI."}),(0,i.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Содержание"}),(0,i.jsxs)(r.aV,{children:[(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#begin",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Начало"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#simple",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Начнем с простого"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#more-complex",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Сложнее, выше, быстрее!"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#i-know-who-you-are",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Я знаю кто ты"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#endgame",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Конец игры"})})})}),(0,i.jsx)("li",{children:(0,i.jsx)(r.e9,{href:"#link",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Полезные материалы"})})})})]}),(0,i.jsxs)("section",{id:"section-begin",children:[(0,i.jsx)(r.xv,{id:"begin",title:!0,className:"mt-10 md:text",children:"Начало"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Задача запуска дочерних процессов из приложений - дело не редкое. В программных продуктах такое встречается довольно часто. Напрмер, различные IDE запускают процессы компилятора, анализа исходных кодов программы, приложения для отладки и многое другое."}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:'Запустить процесс обычно дело нехитрое. Языки программирования и различного рода платформы для разработки обычно имеют удобные средства для решения этих задач. Однако, чем чаще приходится запускать дочерние процессы, тем актуальней становится вопрос их контроля. Ведь могут быть случаи, когда дочерний процесс запустился, а родительский процесс после этого "упал". Получается, что дочерние процессы будут "висеть" вечно. А бывают и более сложные случаи, когда дочерние процессы зависли по каким-либо причинам и этот момент нужно учитывать для надежной работы приложения.'}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Этой задачи мы уже подробно касались в контексте платформы .NET и языка C# в частности. В статье ",(0,i.jsx)(r.e9,{newTab:!0,href:"/pages/blog/.NET/2024-07/processes-under-control.tsx",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Берем процессы под контроль в .NET"})})})," мы уже подробно рассматривали эту тему с помощью простых и сложных примеров реализации различного рода контролей."]}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Сегодня же мы рассмотрим этот вопрос немного с другой стороны. Мы будем запускать процессы в операционной системе Windows из приложения на C++, здесь же добавим контроль дочернего процесса с помощью возможностей WinAPI. Но все по порядку. Приступим!"})]}),(0,i.jsxs)("section",{id:"section-simple",children:[(0,i.jsx)(r.xv,{id:"simple",title:!0,className:"mt-10 md:text",children:"Начнем с простого"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Самый простой способ запуска дочерних процессов средствами C++ является функция **system()** из стандартной библиотеки."}),(0,i.jsx)(t.Z,{code:'\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n	setlocale(LC_ALL, "");\n\n	system("notepad.exe");\n\n	return 0;\n}\n                    ',className:"my-5",language:"cpp"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Мы запускаем приложение **notepad.exe** (Блокнот) и продолжаем выполнение программы. Конечно, приложение запущено, но ни прочитать результат его роботы, ни ожидать его завершения в этом случае мы не можем. Поэтому обратимся перейдем к следующему варианту."})]}),(0,i.jsxs)("section",{id:"section-more-complex",children:[(0,i.jsx)(r.xv,{id:"more-complex",title:!0,className:"mt-10 md:text",children:"Сложнее, выше, быстрее!"}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Следующим шагом для запуска приложения будет метод WinAPI - ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/shell/launch",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ShellExecuteEx"})})}),". Этот метод позволяет выполнить произвольную команду, что также позволит решить нашу задачу с запуском дочернего процесса."]}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:'Запустим также блокнот, но в этот раз будем ожидать его закрытия 10 секунд. Если процесс "Блокнота" не завершится за указанное время, то завершим его принудительно.'}),(0,i.jsx)(t.Z,{code:'\n#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\nint main()\n{\n	setlocale(LC_ALL, "");\n\n	// Инициализируем и запускаем процесс\n	// В примере мы явно используем вариант функции "ShellExecuteExW",\n	// который поддерживает работу с Unicode. Сути примера это не меняет.\n	CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);\n	SHELLEXECUTEINFOW shellExecuteInfo = {};\n	shellExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);\n	shellExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_NO_CONSOLE;\n	shellExecuteInfo.lpFile = L"notepad.exe";\n	shellExecuteInfo.nShow = SW_SHOWNORMAL;\n	BOOL success = ShellExecuteExW(&shellExecuteInfo);\n	assert(success);\n\n	// Ждем завершение дочернего процесса 10 секунд\n	auto wait_result = WaitForSingleObject(shellExecuteInfo.hProcess, 10000);\n	if (wait_result == WAIT_TIMEOUT)\n	{\n		// Завершаем процесс, если он еще не завершился за отведенное время\n		TerminateProcess(shellExecuteInfo.hProcess, 1);\n	}\n\n	// Закрываем дескрипторы\n	CloseHandle(shellExecuteInfo.hProcess);\n\n	return 0;\n}\n                    ',className:"my-5",language:"cpp"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Пример уже содержит контроль выполнения и это просто отлично! Но от совершенства мы все еще далеко. Ведь могут быть случаи, когда дочерний процесс завершится до момента завершения ожидания. Это приведет к тому, что родительский процесс будет завершен, а дочерний останется жить, чего не хотелось бы."}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Значит пришло время пойти к следующему примеру!"})]}),(0,i.jsxs)("section",{id:"section-i-know-who-you-are",children:[(0,i.jsx)(r.xv,{id:"i-know-who-you-are",title:!0,className:"mt-10 md:text",children:"Я знаю кто ты"}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Теперь мы будем использовать метод WinAPI - ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"CreateProcess"})})}),". Данный метод создаем новый процесс по указанным параметрам."]}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:['Для наглядности сначала запустим процесс "Блокнота" как мы делали выше с помощью метода ',(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/shell/launch",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ShellExecuteEx"})})}),". То есть с контролем времени выполнения и автозавершением процесса по таймауту."]}),(0,i.jsx)(t.Z,{code:'\n#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\nint main()\n{\n	setlocale(LC_ALL, "");\n\n	// Команда для запуска приложения\n	WCHAR lpCommandLine[] = L"notepad.exe";\n\n    // Подготовка объектов для запуска процессов\n    STARTUPINFOW startupInfo;\n    ZeroMemory(&startupInfo, sizeof(startupInfo));\n    startupInfo.cb = sizeof(startupInfo);\n    PROCESS_INFORMATION processInfo = {};\n\n    // Инициализация процесса в спящем режиме\n    BOOL bSuccess = CreateProcessW(\n        NULL, // lpApplicationName  <- !!!\n		lpCommandLine, // lpCommandLine      <- !!!\n        NULL, // lpProcessAttributes\n        NULL, // lpThreadAttributes\n        FALSE, // bInheritHandles\n        0, // dwCreationFlags\n        NULL, // lpEnvironment\n        NULL, // lpCurrentDirectory\n		&startupInfo,\n        &processInfo);\n\n    assert(bSuccess);\n	// Ждем завершение дочернего процесса 10 секунд\n    auto wait_result = WaitForSingleObject(processInfo.hProcess, 10000);\n    if (wait_result == WAIT_TIMEOUT)\n    {\n		// Завершаем процесс, если он еще не завершился за отведенное время\n        TerminateProcess(processInfo.hProcess, 1);\n    }\n\n	// Закрываем дескрипторы\n    CloseHandle(processInfo.hThread);\n    CloseHandle(processInfo.hProcess);\n\n	return 0;\n}\n                    ',className:"my-5",language:"cpp",maxHeight:l.b.Unlimited}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Пока мы только перешли на использование метода ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"CreateProcess"})})}),", вместо ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/shell/launch",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ShellExecuteEx"})})}),". Новых механизмов контроля здесь нет, только таймаут ожидания и автозавершение по окончании ожидания, если процесс еще не завершен. Но если нет разницы, то зачем все это?"]}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Все дело в том, что при использовании ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"CreateProcess"})})})," мы можем также задействовать так называемые объекты заданий ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/jobapi2/nf-jobapi2-createjobobjectw",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"CreateJobObject"})})}),"."]}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Объект задания - это объект ядра, который позволяет группировать процессы и помещать их в некоторую песочницу, которая позволяет ограничивать работу процессов различными способами. Настроек и возможностей для управления процессами открывается при этом великое множество!"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Конечно, все возможности мы здесь рассмотреть не сможем. Однако, мы модифицируем код выше таким образом, чтобы добавить ограничение для дочернего процесса - при завершении родительского процесса дочерний должен быть завершен принудительно. И не важно как завершился родительский процесс - дочерний должен завершиться вместе с ним."}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Ниже приведен пример работы с объектом задания для достижения такого поведения."}),(0,i.jsx)(t.Z,{code:'\n#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\nint main()\n{\n	setlocale(LC_ALL, "");\n\n	// Команда для запуска приложения\n	WCHAR lpCommandLine[] = L"notepad.exe";\n	BOOL bSuccess;\n\n	// Создаем объект задания\n	HANDLE hJob;\n	hJob = CreateJobObjectW(NULL, NULL);\n\n	// Определяем ограничение на автозавершение дочерних процессов\n	// после завершения родительского процесса\n	JOBOBJECT_EXTENDED_LIMIT_INFORMATION info = { 0 };\n	info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n	bSuccess = SetInformationJobObject(hJob, JobObjectExtendedLimitInformation, &info, sizeof(info));\n	if (!bSuccess)\n	{\n		wcout << L"Не удалось настроить ограничения для процесса:" << GetLastError() << endl;\n	}\n\n    // Подготовка объектов для запуска процессов\n    STARTUPINFOW startupInfo;\n    ZeroMemory(&startupInfo, sizeof(startupInfo));\n    startupInfo.cb = sizeof(startupInfo);\n    PROCESS_INFORMATION processInfo = {};\n\n    // Инициализация процесса в спящем режиме\n    bSuccess = CreateProcessW(\n        NULL, // lpApplicationName  <- !!!\n		lpCommandLine, // lpCommandLine      <- !!!\n        NULL, // lpProcessAttributes\n        NULL, // lpThreadAttributes\n        FALSE, // bInheritHandles\n		// !!! Процесс создается НЕактивным !!!\n		CREATE_SUSPENDED, // dwCreationFlags\n        NULL, // lpEnvironment\n        NULL, // lpCurrentDirectory\n		&startupInfo,\n        &processInfo);\n	if (!bSuccess)\n	{\n		wcout << L"Не удалось инициализировать процесс:" << GetLastError() << endl;\n	}\n\n	// Присваиваем новый процесс созданному заданию\n	bSuccess = AssignProcessToJobObject(hJob, processInfo.hProcess);\n	if (!bSuccess)\n	{\n		wcout << L"Не удалось применить настройки ограничений процессов:" << GetLastError() << endl;\n	}\n\n	// Разрешаем прилоежнию начать работу\n	bSuccess = ResumeThread(processInfo.hThread);\n	if (!bSuccess)\n	{\n		wcout << L"Не удалось запустить работу в дочернем процессе:" << GetLastError() << endl;\n	}\n\n    assert(bSuccess);\n	// Ждем завершение дочернего процесса 10 секунд\n    auto wait_result = WaitForSingleObject(processInfo.hProcess, 10000);\n    if (wait_result == WAIT_TIMEOUT)\n    {\n		// Завершаем процесс, если он еще не завершился за отведенное время\n        TerminateProcess(processInfo.hProcess, 1);\n    }\n\n	// Закрываем дескрипторы\n    CloseHandle(processInfo.hThread);\n    CloseHandle(processInfo.hProcess);\n\n	return 0;\n}\n                    ',className:"my-5",language:"cpp",maxHeight:l.b.Unlimited}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Мы добавили инициализацию объекта задания и настроили ограничение работы процессов в нем. С помощью флага ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-jobobject_basic_limit_information",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE"})})})," мы указываем, что все связанные с объектом задания процессы должны быть завершены, если главный процесс завершился."]}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Особым моментом здесь является передача в метод ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"CreateProcess"})})})," флага создания процесса ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"CREATE_SUSPENDED"})})}),", который позволяет создать объект процесса в режиме ожидания. То есть процесс создан, но фактически в режиме ожидания. Если бы мы этого не сделали, то процесс начал работу сразу после создания и все последующие настройки ограничений, которые бы мы применяли, он просто бы игнорировал."]}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Ну и дальше остается созданный процесс связать с объектом задания через метод ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/jobapi2/nf-jobapi2-assignprocesstojobobject",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"AssignProcessToJobObject"})})}),", а после непосредственный запуск ранее созданного процесса через метод ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ResumeThread"})})}),"."]}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:'Далее уже будет знакомый Вам код с ожиданием завершения процесса и его принудительным "убийством", если за указанное время дочерний процесс не выполнил свою работу.'}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Но в чем отличие от предыдущих примеров? Все очень просто! Если дочерний процесс завершится по любой причине, то и все дочерние процессы также будут принудительно завершены. Об этом позаботится операционная система. Вот как это выглядит."}),(0,i.jsx)(r.Y7,{className:"margin: 5px",url:"/public/imp_assets/CPP/2024-11/cpp-control-child-processes-with-winapi/Ограничение работает.mp4"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Теперь родительский и дочерний процесс крепко связаны! Если завершить родительский процесс - то завершится и дочерний. Это нам и было нужно!"})]}),(0,i.jsxs)("section",{id:"section-endgame",children:[(0,i.jsx)(r.xv,{id:"endgame",title:!0,className:"mt-10 md:text",children:"Конец игры"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Конечно, мы рассмотрели лишь базовый функционал в части контроля процессов. WinAPI позволяет намного больше!"}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Например. с помощью объектов задания можно ограничить потребление ресурсов центрального процессора, задать приоритет работы процесса и многое другое. Все это можно посмотреть в официальной документации, ссылки на которую были выше для каждого из методов WinAPI."}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["В статье ",(0,i.jsx)(r.e9,{newTab:!0,href:"/pages/blog/.NET/2024-07/processes-under-control.tsx",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"Берем процессы под контроль в .NET"})})})," мы рассматривали возможности контроля процессов при работе из платформы .NET (C#), но упор делали на штатные возможности .NET. Но в целом мы можем и в управляемой среде использовать контроль процессов через объекты задания."]}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["Например, есть .NET-библиотека ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/asmichi/ChildProcess",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"ChildProcess"})})}),", которая позволяет реализовать такой же контроль дочерних процессов, что и мы делали в примере с объектами заданий. На C# это будет выглядеть примерно так:"]}),(0,i.jsx)(t.Z,{code:'\nvar si = new ChildProcessStartInfo("notepad.exe")\n{\n    StdOutputRedirection = OutputRedirection.OutputPipe,\n    // Works like 2>&1\n    StdErrorRedirection = OutputRedirection.OutputPipe,\n    // DisableArgumentQuoting: See ChildProcessExamplesWindows.cs for details\n    Flags = ChildProcessFlags.DisableArgumentQuoting,\n};\n\nusing (var p = ChildProcess.Start(si))\n{\n    using (var sr = new StreamReader(p.StandardOutput))\n    {\n        // "foo"\n        Console.Write(await sr.ReadToEndAsync());\n    }\n    await p.WaitForExitAsync();\n    // ExitCode: 0\n    Console.WriteLine("ExitCode: {0}", p.ExitCode);\n}\n                    ',className:"my-5",language:"csharp",maxHeight:l.b.Unlimited}),(0,i.jsxs)(r.xv,{textAlign:c.PH.JUSTIFY,children:["В части реализации для Windows (а сама библиотека позволяет работать и в других операционных системах) для контроля дочерних процессов как-раз и используется ",(0,i.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/jobapi2/nf-jobapi2-createjobobjectw",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"объекты заданий"})})}),', которые мы "щупали" выше. Вот этот ',(0,i.jsx)(r.e9,{newTab:!0,href:"https://github.com/asmichi/ChildProcess/blob/823a7d5f1ba674013706b2f1d90a916a87be4a49/src/ChildProcess/Interop/Windows/Kernel32.JobObject.cs#L20",children:(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"самый модуль"})})}),"."]}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Итог - что в C++, что в C# для эффективного контроля дочерних процессов задействованы одни и те же объекты операционной системы и методы API, просто разные уровни абстракции."}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"В любом случае, теперь у вас есть пример контроля процессов под C++ и знания для применения этих механизмов и в других языках и платформах."}),(0,i.jsx)(r.xv,{textAlign:c.PH.JUSTIFY,children:"Спасибо за интерес к теме и удачи в делах!"})]}),(0,i.jsxs)("section",{id:"section-link",children:[(0,i.jsx)(r.xv,{id:"link",title:!0,className:"mt-10 md:text",children:"Полезные ссылки"}),(0,i.jsxs)(r.aV,{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw",children:[(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"WinAPI CreateProcess"})})," - метод для создания процессов WinAPI."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/windows/win32/api/winbase/nf-winbase-createjobobjecta",children:[(0,i.jsx)("b",{children:(0,i.jsx)("u",{children:"WinAPI CreateJobObject"})})," - метод для объектов заданий WinAPI для контроля процессов."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(r.e9,{newTab:!0,href:"https://github.com/asmichi/ChildProcess",children:[(0,i.jsx)("u",{children:(0,i.jsx)("b",{children:"ChildProcess"})})," - библиотека .NET для контроля дочерних процессов."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(r.e9,{newTab:!0,href:"https://asawicki.info/news_1767_launching_process_programmatically_system_vs_createprocess_vs_shellexecute",children:[(0,i.jsx)("u",{children:(0,i.jsx)("b",{children:"system vs CreateProcess vs ShellExecute"})})," - сравнение методов WinAPI для запуска процессов и команд операционной системы."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(r.e9,{newTab:!0,href:"https://asawicki.info/news_1768_ways_to_print_and_capture_text_output_of_a_process",children:[(0,i.jsx)("u",{children:(0,i.jsx)("b",{children:"Ways to Print and Capture Text Output of a Process"})})," - способы получения вывода на консоль от запущенных дочерних процессов."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(r.e9,{newTab:!0,href:"https://devblogs.microsoft.com/oldnewthing/20131209-00/?p=2433",children:[(0,i.jsx)("u",{children:(0,i.jsx)("b",{children:"Destroying all child processes (and grandchildren) when the parent exits"})})," - краткий пример по уничтожению дочерних процессов любой вложеннсоит при завершении родительского процесса."]})})]})]})]})},12250:function(e,n,s){"use strict";var i,r;s.d(n,{b:function(){return i}}),(r=i||(i={})).Min="350px",r.Standard="700px",r.Large="1000x",r.Unlimited=""},13803:function(e,n,s){"use strict";var i=s(37340),r=s(85893),t=s(67294),c=s(14965),l=s(54951),o=s(41686),a=s(12250);function d(){let e=(0,i._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return d=function(){return e},e}function h(){let e=(0,i._)(["\n        max-height: ","\n    "]);return h=function(){return e},e}n.Z=e=>{let{code:n,className:i,language:x,maxHeight:u=a.b.Standard}=e;(void 0!==s.g?s.g:window).Prism=c.p1,s(61354),s(79016),s(2731),s(35266),s(92927),s(51315),s(57874),s(86862);let p=null!=u?u:a.b.Standard,j=o.ZP.pre(d()),b=(0,o.ZP)(j)(h(),p);return(0,r.jsx)("div",{className:(0,l.GF)("bg-blue-500 md:p-1 p-2",i),children:(0,r.jsx)("div",{className:"shadow-lg",children:(0,r.jsx)(c.y$,{theme:c.np.vsDark,code:n.trim(),language:null!=x?x:x="tsx",children:e=>{let{className:n,style:s,tokens:i,getLineProps:c,getTokenProps:l}=e;return(0,r.jsx)(b,{className:n,style:s,children:i.map((e,n)=>(0,t.createElement)("div",{...c({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,t.createElement)("span",{...l({token:e,key:n}),key:Math.random()}))))})}})})})}},97037:function(e,n,s){"use strict";s.d(n,{Ee:function(){return l},Xg:function(){return t},Y7:function(){return h},aV:function(){return a},e9:function(){return d},o_:function(){return x},tf:function(){return u},ty:function(){return o},xv:function(){return c}});var i=s(5152),r=s.n(i);let t=r()(()=>Promise.all([s.e(549),s.e(4738),s.e(4838),s.e(1664),s.e(1274)]).then(s.bind(s,91274)),{loadableGenerated:{webpack:()=>[91274]}}),c=r()(()=>Promise.all([s.e(4454),s.e(7897)]).then(s.bind(s,97897)),{loadableGenerated:{webpack:()=>[97897]}}),l=r()(()=>Promise.all([s.e(3536),s.e(2726)]).then(s.bind(s,2726)),{loadableGenerated:{webpack:()=>[2726]}}),o=r()(()=>Promise.all([s.e(549),s.e(378)]).then(s.bind(s,90378)),{loadableGenerated:{webpack:()=>[90378]}}),a=r()(()=>Promise.all([s.e(9300),s.e(7200)]).then(s.bind(s,7200)),{loadableGenerated:{webpack:()=>[7200]}}),d=r()(()=>Promise.all([s.e(1664),s.e(8681)]).then(s.bind(s,28681)),{loadableGenerated:{webpack:()=>[28681]}});r()(()=>s.e(2857).then(s.bind(s,22857)),{loadableGenerated:{webpack:()=>[22857]}});let h=r()(()=>Promise.all([s.e(2004),s.e(3070)]).then(s.bind(s,63070)),{loadableGenerated:{webpack:()=>[63070]}}),x=r()(()=>Promise.all([s.e(162),s.e(4380),s.e(3959),s.e(6050),s.e(239),s.e(8568)]).then(s.bind(s,32215)),{loadableGenerated:{webpack:()=>[32215]}}),u=r()(()=>Promise.all([s.e(162),s.e(1664),s.e(3959),s.e(6050),s.e(4205)]).then(s.bind(s,84205)),{loadableGenerated:{webpack:()=>[84205]}})}},function(e){e.O(0,[4104,2888,9774,179],function(){return e(e.s=73764)}),_N_E=e.O()}]);