(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3419],{7765:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/PostgerSQL/2022-12/simple-maintenance-postgesql",function(){return s(8431)}])},8431:function(e,n,s){"use strict";s.r(n);var l=s(5893),t=s(9305);s(7294);var i=s(6671);n.default=()=>(0,l.jsxs)(t.Xg,{blogcentered:!0,children:[(0,l.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Перед стартом"}),(0,l.jsx)(t.xv,{p:!0,children:"Обслуживание баз данных - это не единственный вопрос, который следует решать администратору СУБД. И при этом не самый первый, если речь идет о сопровождении сервера."}),(0,l.jsx)(t.xv,{p:!0,children:"Мы не будем рассматривать все вопросы обслуживания и сопровождения в этой публикации, слишком много информации бы появилось на этой старнице. Вместо этого мы рассмотрим только самые основные стороны вопроса обслуживания баз данных, при этом подразумевая, что Вы уже сдеали:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:["Настроили под себя оптимальным образом настройки PostgreSQL, например, с помощью сервиса ",(0,l.jsx)("u",{children:(0,l.jsx)("b",{children:(0,l.jsx)(t.e9,{href:"https://pgtune.leopard.in.ua/",newTab:!0,children:"pgtune"})})}),"."]}),(0,l.jsx)("li",{children:"Решены все инфраструктурные вопросы в части работы сети, железа, дисков и так далее."}),(0,l.jsxs)("li",{children:["Вы понимаете как работает PostgreSQL в части модификации строк, ",(0,l.jsx)("u",{children:(0,l.jsx)("b",{children:(0,l.jsx)(t.e9,{href:"https://www.postgresql.org/docs/7.1/mvcc.html",newTab:!0,children:"как работает версионирование"})})}),", что такое “мертвые” строки и так далее."]})]}),(0,l.jsx)(t.xv,{p:!0,children:"Сосредоточимся только на базовых вопросах обслуживания. И так, поехали!"}),(0,l.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Нужно ли обслуживание?"}),(0,l.jsx)(t.xv,{p:!0,children:"Вопрос, на самом деле, важный. PostgreSQL имеет в своем составе штатных механизм автоочистки, который обеспечивает автоматическую очистку таблиц от “мертвых” строк, а также обновляет статистику, которая важна для оптимизатора запросов при построении эффективных планов их выполнения. Но стоит ли полностью полагаться на него?"}),(0,l.jsx)(t.xv,{p:!0,children:"Ответ на этот вопрос: доверяй, но проверяй! По умолчанию autovacoom настроен таким образом, чтобы эффективно обслуживать маленькие и средние таблицы, где количество изменений можно сопоставить с общим объемом информации в них."}),(0,l.jsx)(t.xv,{p:!0,children:"Напомню:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"VACUUM"})," - операция, которая удаляет “мертвые” строки, появившиеся в результате операций ",(0,l.jsx)("b",{children:"UPDATE"})," или ",(0,l.jsx)("b",{children:"DELETE"}),". В результате место внутри файла базы данных освобождается, но не возвращается операционной системе. В этом нет ничего страшного, т.к. в будущем PostgreSQL снова будет его использовать. Для возвращения освобожденного пространства обратно к ОС нужно выполнить ",(0,l.jsx)("b",{children:"VACUUM FULL"}),", что потребует полного пересоздания таблицы, поэтому его выполнение не является регулярным шагом обслуживания и запускается только при крайней необходимости. “Обычный” ",(0,l.jsx)("b",{children:"VACUUM"})," является частью регулярного обслуживания, но это не значит, что его нужно постоянно запускать вручную, т.к. это делает ",(0,l.jsx)("b",{children:"AUTOVACUUM"}),", но об этом ниже."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"ANALYZE"})," - операция обновления статистики, которая используется оптимизатором запросов для построенния эффеткивных планов выполнения. Обычно также не стоит запускать этот шаг вручную, т.к. с этим справляется ",(0,l.jsx)("b",{children:"AUTOVACUUM"}),", но есть нюансы о которых ниже."]})]}),(0,l.jsxs)(t.xv,{p:!0,children:["Ручной запуск операций ",(0,l.jsx)("b",{children:"VACUUM"})," и ",(0,l.jsx)("b",{children:"ANALYZE"})," имеет следующие нюансы:"]}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:["Это может быть избыточной операцией, т.к. механизмы автоочистки ",(0,l.jsx)("b",{children:"AUTOVACUUM"})," и так это выполняют. Состояние таблиц в части “мертвых” строк и актуальности статистики может и так быть идеальным, а ручной запуск лишь съест дополнительные ресурсы IO / CPU."]}),(0,l.jsxs)("li",{children:["Ручной запуск ",(0,l.jsx)("b",{children:"ANALYZE"})," не обновляет статистику (как это делает механизм автоочистки), а полностью ее перестраивает, что может создать излишнюю нагрузку на систему при ручных запусках."]})]}),(0,l.jsxs)(t.xv,{p:!0,children:["Ручной запуск в нашем примере - это не запуск руками администратора, а запуск собственными скриптами через планировщики (cron, pgAgent и так далее). То есть любой запуск вне механизма ",(0,l.jsx)("b",{children:"AUTOVACUUM"}),"."]}),(0,l.jsxs)(t.xv,{p:!0,children:["Вопрос - как настроить ",(0,l.jsx)("b",{children:"AUTOVACUUM"})," для эффективной работы?"]}),(0,l.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Настройка AUTOVACUUM"}),(0,l.jsxs)(t.xv,{p:!0,children:["Первым делом проверим настройки ",(0,l.jsx)("b",{children:"AUTOVACUUM"})," в файле конфигурации сервера ",(0,l.jsx)("b",{children:"postgresql.conf"}),". Описание всех параметров есть ",(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{href:"https://www.postgresql.org/docs/current/runtime-config-autovacuum.html",newTab:!0,children:"в официальной документации."})})})]}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Параметры VACUUM"}),(0,l.jsx)(t.xv,{p:!0,children:"В части очистки от “мертвых” строк есть два параметра:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"autovacuum_vacuum_threshold"})," (значение по умолчанию 50) - мин. количество измененных или удаленных строк, при котором будет выполняться ",(0,l.jsx)("b",{children:"VACUUM"})," для таблицы."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"autovacuum_vacuum_scale_factor"})," (значение по умолчанию 0.2) - процент от размера таблицы, оторый добавляется к ",(0,l.jsx)("b",{children:"autovacuum_vacuum_threshold"})," при вычислении порога срабатывания команды VACUUM."]})]}),(0,l.jsx)(t.xv,{p:!0,children:"Совместно эти параметры и определяют, когда механизм автоочистки запустит команду VACUUM для таблицы. Формула итоговая для определения необходимости автоочистки выглядит так:"}),(0,l.jsx)(i.Z,{code:"\npg_stat_user_tables.n_dead_tup > (pg_class.reltuples x autovacuum_vacuum_scale_factor)  + autovacuum_vacuum_threshold\n                ",className:"my-5",language:"sql"}),(0,l.jsxs)(t.xv,{p:!0,children:["Для мелких и средний таблиц работает хорошо. Например, если в таблице 1000 записей, то порог запуска ",(0,l.jsx)("b",{children:"VACUUM"})," будет:"]}),(0,l.jsx)(i.Z,{code:"\n1000 * 0.2 + 50 = 250\n                ",className:"my-5",language:"sql"}),(0,l.jsx)(t.xv,{p:!0,children:"То есть должно быть изменено 250 записей в таблице, прежде чем запустится очистка. Для такой таблицы это нормально. Но не все таблицы такие маленькие, что есть в таблице миллион записей? Тогда порог срабатывания будет:"}),(0,l.jsx)(i.Z,{code:"\n1000000 * 0.2 + 50 = 200050\n                ",className:"my-5",language:"sql"}),(0,l.jsx)(t.xv,{p:!0,children:"Существенный объем изменений должен произойти, что приведет к росту таблицы на 20% за счет “мертвых” строк, а статистика потеряет актуальность еще задолго до запуска механизма автоочистки. При этом когда автоочистка все же запустится, она будет работать дольше обычного из-за накопившихся изменений, что также приведет к повышенной нагрузке в этот период. В идеале автоочистка должна работать регулярно и распределять нагрузку между небольшими порциями очистки."}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Параметры ANALYZE"}),(0,l.jsx)(t.xv,{p:!0,children:"В части поддержки актуальности статистики также есть два параметра:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"autovacuum_analyze_threshold"})," (значение по умолчанию 50) - мин. количество измененных или удаленных строк, при котором будет выполняться ANALYZE для таблицы."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"autovacuum_analyze_scale_factor"})," (значение по умолчанию 0.1) - процент от размера таблицы, который добавляется к autovacuum_analyze_threshold при вычислении порога срабатывания команды ANALYZE."]})]}),(0,l.jsxs)(t.xv,{p:!0,children:["Работает аналогично параметрам для команды ",(0,l.jsx)("b",{children:"VACUUM"})," и имеет те же самые проблемы для больших таблиц."]}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Как оптимизировать автоочистку"}),(0,l.jsx)(t.xv,{p:!0,children:"Часто видел, как администраторы сразу же отключали механизмы автоочистки и начинали запускать их вручную. Считаю, что это некорректно, т.к. ручной запуск требует больше ответственности и анализа, а потом и мониторинга ситуации в части работы базы данных. Поэтому рекомендую оставлять механизмы автоочистки и заняться оптимизацией их настроек."}),(0,l.jsx)(t.xv,{p:!0,children:"Первым делом нужно понять, что если механизм автоочистки не спрваляется с большими таблицами, то можно отдельно для каждой такой таблицы изменить параметры порога срабатывания. Например, вот так:"}),(0,l.jsx)(i.Z,{code:"\nALTER TABLE <table_name> \nSET (autovacuum_analyze_threshold = <threshold rows>)\n                ",className:"my-5",language:"sql"}),(0,l.jsx)(t.xv,{p:!0,children:"Можно изменить все перечисленные выше параметры для каждой таблицы индивидуально и не менять поведение всего PostgreSQL в этой части. Анализ можно выполнить следующими скриптами:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Indexes/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0%20(%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F%2C%20%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%20%D0%B8%20%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B5).sql",children:"Анализ состояния индексов"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Indexes/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20'%D1%80%D0%B0%D0%B7%D0%B1%D1%83%D1%85%D0%B0%D0%BD%D0%B8%D1%8F'%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2.sql",children:"Анализ разбухания индексов"})})})}),(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Maintenance/%D0%9A%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE%20'%D0%BC%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D1%85'%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%20%D0%BF%D0%BE%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0%D0%BC.sql",children:"Анализ ‘мертвых’ строк по таблицам"})})})})]}),(0,l.jsx)(t.xv,{p:!0,children:"К сожалению, только с помощью анализа можно выявить такие таблицы и исправить их параметры для механизма автоочистки. Тут универсальных скриптов уже дать нельзя."}),(0,l.jsxs)(t.xv,{p:!0,children:["Но зато можно дать рекомендации по дополнительной настройке ",(0,l.jsx)("b",{children:"AUTOVACUUM"}),":"]}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:["Можно ускориить работу автоочистки, увеличив параметр ",(0,l.jsx)("b",{children:"autovacuum_max_workers"})," c 3 до, например, 5. Это даст возможность автоочистке запускать в 5 потоков. Но это еще не все!"]}),(0,l.jsxs)("li",{children:["Также нужно изменить параметр ",(0,l.jsx)("b",{children:"autovacuum_vacuum_cost_limit"}),", который задает ограничения для работы заданий автоочистки, некоторый предел стоимости (по умолчанию 200). При увеличении количества потоков предел стоимости для каждого из них вычисляется по формуле:"]})]}),(0,l.jsx)(i.Z,{code:"\nИндивидуальный порог стоимости для потока = autovacuum_vacuum_cost_limit / autovacuum_max_workers\n                ",className:"my-5",language:"text"}),(0,l.jsxs)(t.xv,{p:!0,children:["То есть при увеличении количества потоков порог для каждого потока снизится. Поэтому с увеличением количества потоков механизма автоочистки рекомендую увеличить параметр ",(0,l.jsx)("b",{children:"autovacuum_vacuum_cost_limit"})," например до 2000."]}),(0,l.jsx)(t.xv,{p:!0,children:"Таким образом, мы повысим параллелизм работы механизма автоочистки, что снизит длительность его работы."}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Как считается стоимость работы"}),(0,l.jsx)(t.xv,{p:!0,children:"На расчет стоимости работы потока автоочистки влияют несколько параметров:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"vacuum_cost_page_hit"})," (по умолчанию 1) - стоимость очистки буфера, оказавшегося в общем кеше."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"vacuum_cost_page_miss"})," (по умолчанию 10) - стоимость очистки буфера, который нужно прочитать с диска."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"vacuum_cost_page_dirty"})," (по умолчанию 20) - стоимость очистки, при которой изменяется блок, не модифицированный ранее."]})]}),(0,l.jsx)(t.xv,{p:!0,children:"Изменять эти параметры глобально обычно смысла не имеет. Нужно стараться обновлять их индивидуально для каждой таблицы:"}),(0,l.jsx)(i.Z,{code:"\nALTER TABLE <table_name> SET (autovacuum_vacuum_cost_limit = <large_value>)\nALTER TABLE <table_name> SET (autovacuum_vacuum_cost_delay = <lower_cost_delay>)\n                ",className:"my-5",language:"sql"}),(0,l.jsx)(t.xv,{p:!0,children:"Опять же, когда меняете Вы должны понимать зачем и почему. Делайте анализ показателей работы баз данных, о чем мы уже выше говорили."}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Что в итоге с автоочисткой"}),(0,l.jsx)(t.xv,{p:!0,children:"Можно подвести такие итоги:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsx)("li",{children:"Отключать механизм автоочистки не стоит."}),(0,l.jsx)("li",{children:"Первым шагом оптимизации его работы можно назвать: увеличение количества потоков автоочистки и повышение порога стоимости."}),(0,l.jsx)("li",{children:"Следующий шаг - индивидуальная настройка порогов автоочистки и обновления статистики, а в некоторых случаях и параметров определения стоимости очистки."})]}),(0,l.jsx)(t.xv,{p:!0,children:"Общие параметры для анализа работы автоочистки:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Databases-Info/%D0%A0%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D1%8B%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86.sql",children:"Количество записей в каждой таблице."})})})}),(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Maintenance/%D0%9A%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE%20'%D0%BC%D0%B5%D1%80%D1%82%D0%B2%D1%8B%D1%85'%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%20%D0%BF%D0%BE%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0%D0%BC.sql",children:"Количество ‘мертвых’ строк в каждой таблице."})})})}),(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Maintenance/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BE%20%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D1%85%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F%D1%85%20VACUUM%20%D0%B8%20AUTOCACUUM.sql",children:"Время последнейго запуска автоочистки."})})})}),(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Maintenance/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BE%20%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D1%85%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F%D1%85%20ANALYZE%20%D0%B8%20AUTOANALYZE.sql",children:"Время последнейго запуска обновления статистики."})})})}),(0,l.jsx)("li",{children:(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Databases-Info/%D0%90%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B2%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B5.sql",children:"Статистика операций INSERT/UPDATE/DELETE для каждой таблицы."})})})}),(0,l.jsx)("li",{children:"Время автоочистки для каждой таблицы (информацию можно посмотреть в логах PostgreSQL или сохранить в таблицу базы для анализа)."}),(0,l.jsx)("li",{children:"Список таблиц, для которых не срабатывает автоочистка."}),(0,l.jsx)("li",{children:"Список проблемных запросов в базе данных, которые можно оптимизировать более частым обновлением статистики и автоочисткой."}),(0,l.jsxs)("li",{children:["Проверить производительность этих запросов при ручном ",(0,l.jsx)("b",{children:"VACUUM"})," и ",(0,l.jsx)("b",{children:"ANALYZE"}),"."]})]}),(0,l.jsx)(t.xv,{p:!0,children:"Но неужели ручного запуска операций обслуживания не нужно?"}),(0,l.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Берем особые случаи под контроль"}),(0,l.jsx)(t.xv,{p:!0,children:"По результатам анализа может оказаться, что не во всех случаях механизм автоочистки может сработать. Например, если есть периоды массовой загрузки данных, при этом параметры срабатывания для таблиц невозможно предугадать заранее."}),(0,l.jsxs)(t.xv,{p:!0,children:["В этих случаях можно организовать ручной запуск операций ",(0,l.jsx)("b",{children:"VACUUM"})," и / или ",(0,l.jsx)("b",{children:"ANALYZE"}),"."]}),(0,l.jsx)(t.xv,{p:!0,children:"Повторюсь: ручной запуск нужно выполнять только в тех случаях, если проблема повторилась после анализа данных механизма автоочистки и точечная оптимизация его работы не дает эффективных результатов!"}),(0,l.jsx)(t.xv,{p:!0,children:"При ручном запуске нужно учитывать следующие моменты:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsx)("li",{children:"Рекомендуется выполнять запуск в периоды минимальной активноси в базе данных, чтоб не помешать основной работе."}),(0,l.jsxs)("li",{children:["Учитывать работу механизма ",(0,l.jsx)("b",{children:"AUTOVACUUM"}),"."]}),(0,l.jsx)("li",{children:"Анализировать эффект от ручного запуска, о чем писали выше."}),(0,l.jsx)("li",{children:"Выполнять мониторинг работы баз данных и в случае изменения окружения или особенностей работы - адаптировать скрипты обслуживания."})]}),(0,l.jsx)(t.xv,{p:!0,children:"В качестве примера скриптов, которые могут помочь в решении этой задачи, укажем несколько."}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Просто ручной VACUUM"}),(0,l.jsx)(t.xv,{p:!0,children:"Просто по расписанию несколько раз в день запускать:"}),(0,l.jsx)(i.Z,{code:"\nVACUUM ANALYZE;\n                ",className:"my-5",language:"sql"}),(0,l.jsxs)(t.xv,{p:!0,children:["Время выбирайте по нагрузке в базе данных. Возможна комбинация с ",(0,l.jsx)("b",{children:"AUTOVACUUM"}),"."]}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Запуск VACUUM для всех таблиц и всех баз"}),(0,l.jsxs)(t.xv,{p:!0,children:["С помощью простого bash-скрипта это достаточно легко организовать.",(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Maintenance/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D0%BE%D0%B5%20'%D0%BB%D0%B5%D0%B3%D0%BA%D0%BE%D0%B5'%20%D0%BE%D0%B1%D1%81%D0%BB%D1%83%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.sh",children:"Оригинал скрипта."})})})]}),(0,l.jsx)(i.Z,{code:'#! /bin/bash\nexport PGHOST=localhost\nexport PGPORT=5432\nexport PGUSER=postgres # Пользователь, от которого запустится обслуживание\nexport PGPASSWORD=postgres # Пароль этого пользователя\n\n# Получаем список баз данных\ndblist=`psql -d postgres -c "copy (select datname from pg_stat_database) to stdout"`\nfor db in $dblist ; do\n\n    # Игнорируем служебные базы данных\n    if [[ $db == template0 ]] ||  [[ $db == template1 ]] || [[ $db == postgres ]] ; then\n        continue\n    fi\n\n    # Проводим сборку мусора и анализ базы данных\n    # Подробнее: https://www.postgresql.org/docs/9.1/sql-vacuum.html\n    psql -d $db -e -a -c "VACUUM;"\ndone                ',className:"my-5",language:"bash"}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Запуск очистки для конктерной базы"}),(0,l.jsx)(t.xv,{p:!0,children:"На этот раз это простой скрипт для запуска через SQL-запрос."}),(0,l.jsx)(i.Z,{code:'/*\nОбслуживание базы данных в части удаления "мертвых" строк в таблицах и обновления статистики для оптимизатора запросов.\n*/\n\n-- Подробнее: https://postgrespro.ru/docs/postgrespro/9.5/sql-vacuum\n\n-- VACUUM высвобождает пространство, занимаемое \xabмёртвыми\xbb кортежами. При обычных операциях кортежи, \n-- удалённые или устаревшие в результате обновления, физически не удаляются из таблицы; они сохраняются в ней, \n-- пока не будет выполнена команда VACUUM. \n\n-- VERBOSE - выводит подробный отчет о результатах работы\n-- ANALYZE - обновляет статистику для оптимальной работы планировщика (эффективного построения планов запросов)\n\nVACUUM (VERBOSE, ANALYZE);\n',className:"my-5",language:"sql"}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Перестроение индексов"}),(0,l.jsx)(t.xv,{p:!0,children:"В некоторых случаях может потребоваться перестроить индекс полностью. Например, после массовых изменений данных исправить ситуацию с его “разбуханием” или исправление высокой дефрагментации."}),(0,l.jsxs)(t.xv,{p:!0,children:["Скрипт ниже анализирует состояние индексов и если фрагментация выше указанного показателя, выполняет перестроение.",(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Maintenance/%D0%9F%D0%B5%D1%80%D0%B5%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2.sql",children:"Оригинал скрипта."})})})]}),(0,l.jsx)(i.Z,{code:"\n/*\nПерестроение индексов с целью борьбы с их \"разбуханием\" и фрагментацией.\nДля работы скрипта в базе необходимо установить расширение pgstatindex командой:\nCREATE EXTENSION pgstattuple;\nМожет использоваться для генерации скриптов или для выполнения непосредственно перестроения индекса с учетом параметров:\n - index_frag_threshold_to_rebuild - минимальный % фрагментации индекса для перестроения.\n - use_index_concurrently_rebuild - использовать перестроение без эксклюзивной блокировки (онлайн-перестроение).\n    Внимаание! При включенной опции возможно только генерация скриптов, т.к. выполнение онлайн-перестроения через 'EXECUTE %SQL%' недоступно.\n - generate_script_only - при установке в true будет сгенерирован скрипт, а его выполнение будет пропущено. \n    При false будет выполнена попытка выполнения скритпа сразу.\n*/\n\ndo $$\ndeclare\n index_frag_threshold_to_rebuild integer := 30;\n use_index_concurrently_rebuild boolean := false;\n generate_script_only boolean := false;\n sql_index_rebuild_result text default '';\n index_info record;\n indexes_cursor cursor for\n  select\n      n.nspname as \"SchemaName\",\n      ti.relname as \"TableName\",\n      i.indexrelid::regclass as \"IndexName\",\n      case when s.leaf_fragmentation = 'NaN' then 0 else s.leaf_fragmentation end as \"LeafFragmentation\"\n  FROM pg_index AS i\n     JOIN pg_class AS t ON i.indexrelid = t.oid\n     JOIN pg_opclass AS opc ON i.indclass[0] = opc.oid\n     JOIN pg_am ON opc.opcmethod = pg_am.oid\n     CROSS JOIN LATERAL pgstatindex(i.indexrelid) AS s\n     join pg_class ti ON ti.oid = i.indrelid\n     LEFT JOIN pg_namespace n ON n.oid = ti.relnamespace\n  WHERE t.relkind = 'i'\n    AND pg_am.amname = 'btree'\n    and ti.relkind = ANY (ARRAY['r', 't'])\n    and case when s.leaf_fragmentation = 'NaN' then 0 else s.leaf_fragmentation end >= index_frag_threshold_to_rebuild\n  order by \"LeafFragmentation\" desc;\nbegin\n open indexes_cursor;\n\n loop\n     fetch indexes_cursor into index_info;\n     exit when not found;\n     \n     sql_index_rebuild_result := sql_index_rebuild_result \n      || chr(10) \n      || case when use_index_concurrently_rebuild then 'REINDEX INDEX CONCURRENTLY ' else 'REINDEX INDEX ' end\n      || index_info.\"IndexName\"::text;\n    \n     if generate_script_only is not true then     \n      EXECUTE format('%s  %s', \n       case when use_index_concurrently_rebuild then 'REINDEX INDEX CONCURRENTLY' else 'REINDEX INDEX' end, \n       index_info.\"IndexName\"::text);\n  end if;\n  end loop;\n\n close indexes_cursor;\n\n RAISE NOTICE '%', sql_index_rebuild_result;\nend\n$$ language 'plpgsql';\n",className:"my-5",language:"sql"}),(0,l.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Тяжелое обслуживание"}),(0,l.jsxs)(t.xv,{p:!0,children:["Может потребоваться для ручного запуска при каких-либо массовых изменениях в базе. Например, если разработчики применили огромные миграции базы данных. Скрипт полностью перестраивает таблицы, удаляет все “мертвые” строки и обновляет статистику.",(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/blob/master/PG-Maintenance/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D0%BE%D0%B5%20'%D1%82%D1%8F%D0%B6%D0%B5%D0%BB%D0%BE%D0%B5'%20%D0%BE%D0%B1%D1%81%D0%BB%D1%83%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.sh",children:"Оригинал скрипта."})})})]}),(0,l.jsx)(i.Z,{code:"\n#! /bin/bash\nexport PGHOST=localhost\nexport PGPORT=5432\nexport PGUSER=postgres # Пользователь, от которого запустится обслуживание\nexport PGPASSWORD=postgres # Пароль этого пользователя\n\n# Получаем список баз данных\ndblist=`psql -d postgres -c \"copy (select datname from pg_stat_database) to stdout\"`\nfor db in $dblist ; do\n\n    # Игнорируем служебные базы данных\n    if [[ $db == template0 ]] ||  [[ $db == template1 ]] || [[ $db == postgres ]] ; then\n        continue\n    fi\n\n    # Выполняем сборку мусора\n    psql -d $db -e -a -c \"VACUUM;\"\n    # Перестраиваем системные индексы\n    psql -d $db -e -a -c \"REINDEX SYSTEM $db;\"\n    # Сохраняем список таблиц во временный файл\n    cp /dev/null tables.txt\n    psql -d $db -c \"copy (select '\"'||tables.schemaname||'\".' || '\"'||tables.tablename||'\"' from (select nspname as schemaname, relname as tablename from pg_catalog.pg_class, pg_catalog.pg_namespace, pg_catalog.pg_roles where pg_class.relnamespace = pg_namespace.oid and pg_namespace.nspowner = pg_roles.oid and pg_class.relkind='r' and (pg_namespace.nspname = 'public' or pg_roles.rolsuper = 'false' ) ) as tables(schemaname, tablename)) to stdout;\" > tables.txt\n    \n    while read line; do\n        \n        # Экранируем в именах таблицы служебный символ $\n        line=`echo $line |sed 's/\\$/\\\\\\$/g'`\n        \n        # Выполняем полную очистку\n        psql -d $db -e -a -c \"VACUUM FULL $line;\"\n        # Перестраиваем индексы таблицы\n        psql -d $db -e -a -c \"REINDEX TABLE $line;\"\n\n    done <tables.txt\ndone\n",className:"my-5",language:"sql"}),(0,l.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Как автоматизировать запуск"}),(0,l.jsx)(t.xv,{p:!0,children:"Для автоматизации запуска скриптов есть несколько путей:"}),(0,l.jsxs)(t.aV,{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("b",{children:"Cron"})," - использовать стандартный планирощик *.nix-систем. (Елси вы на Windows, то можно использовать стандартный планировщик ОС)."]}),(0,l.jsxs)("li",{children:["pgAgent - планировщик задач, созданный специально для PostgreSQL. Позволяет запускать как SQL-скрипты, так и bash/cmd-скрипты (в зависимости от ОС). Этот вариант обычно проще в обслуживании и настройке.",(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools/tree/master/PG-Agent",children:"Подробнее об этом можете прочитать здесь."})})})]})]}),(0,l.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Вместо заключения"}),(0,l.jsx)(t.xv,{p:!0,children:"Это лишь базовая информация в части обслуживания баз данных PostgreSQL. Тему можно развивать и описать множество нюансов обслуживания. Причем, чем “хуже” софт в части работы с базой данных, тем больше этих нюансов возникает."}),(0,l.jsx)(t.xv,{p:!0,children:"При этом эффективную настройку как СУБД, так и облуживания можно сделать только при организации постоянного мониторинга СУБД и инфораструктуры. В противном случае все действия будут выполняться вслепую. А это непрофессионально, ведь метод “тыка” это не для администрирования и разработки, это совсем другая сфера деятельности :)."}),(0,l.jsxs)(t.xv,{p:!0,children:["Информацию по обслуживанию и другие интересности в части работы PostgreSQL",(0,l.jsx)("b",{children:(0,l.jsx)("u",{children:(0,l.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/PGTools",children:"Вы можете найти здесь."})})})]})]})},9963:function(e,n,s){"use strict";var l,t;s.d(n,{b:function(){return l}}),(t=l||(l={})).Min="350px",t.Standard="700px",t.Large="1000x",t.Unlimited=""},6671:function(e,n,s){"use strict";var l=s(7340),t=s(5893),i=s(7294),r=s(4965),a=s(4275),c=s(964),d=s(9963);function x(){let e=(0,l._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return x=function(){return e},e}function D(){let e=(0,l._)(["\n        max-height: ","\n    "]);return D=function(){return e},e}n.Z=e=>{let{code:n,className:l,language:h,maxHeight:o=d.b.Standard}=e;(void 0!==s.g?s.g:window).Prism=r.p1,s(1354),s(9016),s(5266),s(2927),s(1315),s(7874),s(6862);let u=null!=o?o:d.b.Standard,m=c.ZP.pre(x()),B=(0,c.ZP)(m)(D(),u);return(0,t.jsx)("div",{className:(0,a.GF)("bg-blue-500 md:p-1 p-2",l),children:(0,t.jsx)("div",{className:"shadow-lg",children:(0,t.jsx)(r.y$,{theme:r.np.vsDark,code:n.trim(),language:null!=h?h:h="tsx",children:e=>{let{className:n,style:s,tokens:l,getLineProps:r,getTokenProps:a}=e;return(0,t.jsx)(B,{className:n,style:s,children:l.map((e,n)=>(0,i.createElement)("div",{...r({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,i.createElement)("span",{...a({token:e,key:n}),key:Math.random()}))))})}})})})}},9305:function(e,n,s){"use strict";s.d(n,{Ee:function(){return a},Xg:function(){return i},Y7:function(){return D},aV:function(){return d},e9:function(){return x},o_:function(){return h},ty:function(){return c},xv:function(){return r}});var l=s(5152),t=s.n(l);let i=t()(()=>Promise.all([s.e(4838),s.e(4738),s.e(1664),s.e(7167)]).then(s.bind(s,7167)),{loadableGenerated:{webpack:()=>[7167]}}),r=t()(()=>s.e(9179).then(s.bind(s,9179)),{loadableGenerated:{webpack:()=>[9179]}}),a=t()(()=>s.e(1974).then(s.bind(s,1974)),{loadableGenerated:{webpack:()=>[1974]}}),c=t()(()=>s.e(8547).then(s.bind(s,8547)),{loadableGenerated:{webpack:()=>[8547]}}),d=t()(()=>s.e(6806).then(s.bind(s,6806)),{loadableGenerated:{webpack:()=>[6806]}}),x=t()(()=>Promise.all([s.e(1664),s.e(1465)]).then(s.bind(s,1465)),{loadableGenerated:{webpack:()=>[1465]}});t()(()=>s.e(567).then(s.bind(s,567)),{loadableGenerated:{webpack:()=>[567]}});let D=t()(()=>Promise.all([s.e(2004),s.e(4139)]).then(s.bind(s,4139)),{loadableGenerated:{webpack:()=>[4139]}}),h=t()(()=>Promise.all([s.e(3811),s.e(7472),s.e(584),s.e(7870)]).then(s.bind(s,7870)),{loadableGenerated:{webpack:()=>[7870]}})}},function(e){e.O(0,[1102,2888,9774,179],function(){return e(e.s=7765)}),_N_E=e.O()}]);