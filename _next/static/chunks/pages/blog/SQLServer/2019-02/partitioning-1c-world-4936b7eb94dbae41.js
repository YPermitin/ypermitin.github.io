(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6360],{213:function(e,n,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/SQLServer/2019-02/partitioning-1c-world",function(){return i(8071)}])},8071:function(e,n,i){"use strict";i.r(n);var s=i(5893),r=i(4853);i(7294);var l=i(1667),c=i(3218),d=i(4877),x=i(2967),t=i(7168),a=i(8148),h=i(4313),j=i(9209),N=i(7957);n.default=()=>{let{isOpen:e,onOpen:n,onOpenChange:i}=(0,N.q)();return(0,s.jsxs)(r.Xg,{blogcentered:!0,children:[(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Зачем все это"}),(0,s.jsx)(r.xv,{p:!0,children:"Файловые группы! Секционирование таблиц и индексов! Размещение таблицы на нескольких дисках! Собственные индексы для таблиц и другие замечательные возможности СУБД, которые платформа 1С не поддерживает “из коробки”."}),(0,s.jsx)(r.xv,{p:!0,children:"Все это применяется во многих других системах, но не у нас, ведь мы используем более продвинутые технологии:"}),(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Нет смысла разделять базу, таблицы или индексы на отдельные файлы для распределения по дискам, ведь в век SSD это пустая трата времени."}),(0,s.jsx)("li",{children:"База стала большой, неповоротливой и с множеством ошибок в данных? Начнем жизнь с чистого листа (ну или почти с чистого) - свертка базы все решает!"}),(0,s.jsx)("li",{children:"Ускорение бэкапирования за счет отказа от сохранения исторических данных в базе - тоже не про нас. Ведь бэкапировать один файл базы удобнее."}),(0,s.jsx)("li",{children:"Проблемы блокировок и неактуальных статистик вообще к нам не относятся, потому что платформа 1С сама все оптимизирует."})]}),(0,s.jsx)(r.xv,{p:!0,children:"Уже сейчас на просторах нашей Родины все чаще можно встретить внедрения информационных систем на базе 1С с активным количество пользователей более 1000, а размером баз более 1 ТБ. Я думаю (или очень сильно надеюсь), что именно при подобных внедрениях работа с базами 1С меняется, а это привносит новые требования как к самой платформе, так и к необходимым компетенциям администраторов и разработчиков. Одним из таких требований является иной подход к обслуживанию базы данных, который нельзя сделать стандартными средствами платформы 1С. Как вы могли догадаться, речь идет о секционировании таблиц и индексов."}),(0,s.jsx)(r.xv,{p:!0,children:"Одним из самых важных требований к обслуживанию больших, высоконагруженных баз является эффективная структура индексов, которую нельзя полностью создать средствами платформы 1С. Но об этом мы уже говорили в предыдущей статье “Создаем свои индексы для баз 1С. Со своей структурой и настройками!”, поэтому сейчас на этом заострять внимание не будем."}),(0,s.jsx)(r.xv,{p:!0,children:"Ниже поговорим об использовании секционирования таблиц и индексов в базах 1С, плюсах и минусах, подводных камнях и целесообразности."}),(0,s.jsx)(r.xv,{p:!0,children:"Все, что будет ниже, относится к клиент-серверному режиму работы и рассматривается в контексте Microsoft SQL Server. Но, фактически, может быть использовано и на PostgreSQL."}),(0,s.jsxs)(r.xv,{p:!0,children:["В статье нет раскрытия вопроса лицензирования SQL Server и доступности функций в зависимости от редакции СУБД. Подробности Вы ",(0,s.jsx)("b",{children:(0,s.jsx)("u",{children:(0,s.jsx)(r.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/sql-server/editions-and-components-of-sql-server-2019?view=sql-server-ver16",children:"можете узнать здесь"})})}),"."]}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Принцип работы"}),(0,s.jsx)(r.xv,{p:!0,children:"Что же такое секционирование и для чего оно используется? В общих чертах, секционирование - это разбиение таблиц и индексов на некоторые блоки, в качестве которых может выступать файловая группа (логическое разделение) или файл (физическое разбиение). Блоки могут быть разных размеров, находиться на разных дисках и иметь различные специфичные для них настройки. Как обычно, вся самая подробная информация о секционировании SQL Server находится в официальной документации, мы же рассмотрим несколько примеров его использования с описанием плюсов и минусов этого подхода."}),(0,s.jsx)(r.xv,{p:!0,children:"Для SQL Server создание секций выполняется в несколько этапов. Опустим этап проектирования и рассмотрим по шагам простой пример. У нас есть информационная база 1С “Partitioning”, структура метаданных которой состоит из 2 документов, 4 регистров накопления и 4 справочников."}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/1. Структура метаданных.png",alt:"Структура метаданных",size:j.h2.MEDIUM}),(0,s.jsx)(r.xv,{p:!0,children:"Структура метаданных дана просто для информации, все примеры будут на 1 или 2 таблицах. Как можно догадаться, примеры с секционированием будут выполнены на регистрах “Продажи_Секции” и “ТоварыНаСкладах_Секции”. На стороне SQL Server эти объекты представлены несколькими таблицами. Нас интересуют только физические таблицы для упрощения примеров. Таблицы итогов и служебные таблицы секционировать не будем."}),(0,s.jsxs)(l.b,{"aria-label":"Структура таблицы 1С",children:[(0,s.jsxs)(c.J,{children:[(0,s.jsx)(d.j,{children:"Метаданные"},"Metadata"),(0,s.jsx)(d.j,{children:"Имя таблицы"},"TableName"),(0,s.jsx)(d.j,{children:"Поле 1С"},"Field1C"),(0,s.jsx)(d.j,{children:"Поле SQL"},"FieldSQL")]}),(0,s.jsxs)(x.y,{children:[(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"РегистрНакопления.ТоварыНаСкладах_Секции"}),(0,s.jsx)(a.X,{children:"_AccumRg84"}),(0,s.jsx)(a.X,{children:"Период"}),(0,s.jsx)(a.X,{children:"_Period"})]},"1-1"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Регистратор"}),(0,s.jsx)(a.X,{children:"_RecorderTRef"})]},"1-2"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Регистратор"}),(0,s.jsx)(a.X,{children:"_RecorderRRef"})]},"1-3"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"НомерСтроки"}),(0,s.jsx)(a.X,{children:"_LineNo"})]},"1-4"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Активность"}),(0,s.jsx)(a.X,{children:"_Active"})]},"1-5"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"ВидДвижения"}),(0,s.jsx)(a.X,{children:"_RecordKind"})]},"1-6"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Склад"}),(0,s.jsx)(a.X,{children:"_Fld85RRef"})]},"1-7"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Номенклатура"}),(0,s.jsx)(a.X,{children:"_Fld86RRef"})]},"1-8"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Количество"}),(0,s.jsx)(a.X,{children:"_Fld87"})]},"1-9"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"РегистрНакопления.Продажи_Секции"}),(0,s.jsx)(a.X,{children:"_AccumRg69"}),(0,s.jsx)(a.X,{children:"Период"}),(0,s.jsx)(a.X,{children:"_Period"})]},"2-1"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Регистратор"}),(0,s.jsx)(a.X,{children:"_RecorderRRef"})]},"2-2"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"НомерСтроки"}),(0,s.jsx)(a.X,{children:"_LineNo"})]},"2-3"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Активность"}),(0,s.jsx)(a.X,{children:"_Active"})]},"2-4"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Подразделение"}),(0,s.jsx)(a.X,{children:"_Fld70RRef"})]},"2-5"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Контрагент"}),(0,s.jsx)(a.X,{children:"_Fld71RRef"})]},"2-6"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"⬆️"}),(0,s.jsx)(a.X,{children:"Сумма"}),(0,s.jsx)(a.X,{children:"_Fld72"})]},"2-7")]})]}),(0,s.jsx)(r.xv,{p:!0,children:"Все таблицы базы содержат данные с 2010 до 2019 года, чтобы наглядно продемонстрировать действия секционирования."}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Создание файловых групп"}),(0,s.jsx)(r.xv,{p:!0,children:"Для начала создадим логические блоки базы данных - файловые группы. Сделать это можно как с помощью SQL-скрипта, так и с помощью графического интерфейса в SQL Managment Studio (SSMS)."}),(0,s.jsx)(h.Z,{code:"\nUSE [master]\nGO\nALTER DATABASE [Partitioning] ADD FILEGROUP [FG1]\nGO\nALTER DATABASE [Partitioning] ADD FILEGROUP [FG2]\nGO\nALTER DATABASE [Partitioning] ADD FILEGROUP [FG3]\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"В результате, кроме основной файловой группы PRIMARY имеем три дополнительных: FG1, FG2, FG3."}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/2. Настройка файловых групп.png",alt:"Настройка файловых групп",size:j.h2.MEDIUM}),(0,s.jsx)(r.xv,{p:!0,children:"Файловые группы необходимы для распределения данных по ним с помощью секционирования. За файловой группой может стоять как отдельный файл или группа файлов."}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Добавление файлов"}),(0,s.jsx)(r.xv,{p:!0,children:"Файловые группы есть, но они нигде не используются. Добавим отдельные файлы для каждой файловой группы."}),(0,s.jsx)(h.Z,{code:"\nUSE [master]\nGO\nALTER DATABASE [Partitioning] ADD FILE ( \n	-- Настройки размещения и автоувеличение файла\n	NAME = N'Partitioning_FG1', \n	FILENAME = N'D:\\DBs\\Partitioning_FG1.ndf' , \n	SIZE = 1024KB , \n	FILEGROWTH = 10%) \n	-- Принадлежность файла к файловой группе\n	TO FILEGROUP [FG1]\nGO\nALTER DATABASE [Partitioning] ADD FILE ( \n	NAME = N'Partitioning_FG2', \n	FILENAME = N'D:\\DBs\\Partitioning_FG2.ndf', SIZE = 1024KB, FILEGROWTH = 10%) \n	TO FILEGROUP [FG2]\nGO\nALTER DATABASE [Partitioning] ADD FILE ( \n	NAME = N'Partitioning_FG3', \n	FILENAME = N'D:\\DBs\\Partitioning_FG3.ndf', SIZE = 1024KB, FILEGROWTH = 10%) \n	TO FILEGROUP [FG3]\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Теперь каждая файловая группа ассоциирована с отдельным физическим файлом. Эти файлы также сразу же доступны в файловой системе."}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Определение функции и схемы секционирования"}),(0,s.jsx)(r.xv,{p:!0,children:"Тут начинается самое интересное. Нам необходимо определить как данные в таблице или индексах будут распределяться между секциями. Для этого используются функции секционирования. Как упоминалось выше, таблицы содержат данные с 2010 по 2019 год. Допустим, нам нужно распределить данные по годам между секциями по такому принципу:"}),(0,s.jsxs)(l.b,{"aria-label":"Структура таблицы 1С",children:[(0,s.jsxs)(c.J,{children:[(0,s.jsx)(d.j,{children:"Файловая группа"},"FileGroup"),(0,s.jsx)(d.j,{children:"Фильтр данных"},"DataFilter")]}),(0,s.jsxs)(x.y,{children:[(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"FG1"}),(0,s.jsx)(a.X,{children:"до 2010 года включительно"})]},"1"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"FG2"}),(0,s.jsx)(a.X,{children:"с 2011 по 2014 год включительно"})]},"2"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"FG3"}),(0,s.jsx)(a.X,{children:"с 2015 по 2018 год включительно"})]},"3"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"PRIMARY"}),(0,s.jsx)(a.X,{children:"с 2019 года по текущий момент"})]},"4")]})]}),(0,s.jsx)(r.xv,{p:!0,children:"Создать функцию секционирования можно только с помощью SQL-скрипта. В нашем случае он будет выглядеть так."}),(0,s.jsx)(h.Z,{code:"\nUSE [Partitioning]\nGO\n\nCREATE PARTITION FUNCTION [ByDatePartitionFunction] \n	-- Тип колонки исходной таблицы, по которой\n	-- будет выполняться секционирование\n	(datetime2(0))\n-- Указание к какой области интервала значений\n-- принадлежит аргумент в части \"FOR VALUES\"\nAS RANGE LEFT \n-- Платформа 1С хранит даты с некоторым смещением,\n-- которое обычно установлено в 2000 лет, чтобы\n-- иметь возможность хранить пустую дату \"01.01.0001\"\n-- из 1С в виде \"01.01.2001\" на стороне SQL Server.\n-- Поэтому здесь все даты в 4-ом тысячелетии :)\nFOR VALUES (\n	N'4010-12-31T23:59:59.000', \n	N'4014-12-31T23:59:59.000', \n	N'4018-12-31T23:59:59.000'\n)\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Тип колонки секционирования соответствует типы поля “_Period” в таблице регистра. Через SSMS можно увидеть новый объект в разделе “Хранилище”."}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/3. Функция секционирования.png",alt:"Функция секционирования",size:j.h2.SMALL}),(0,s.jsx)(r.xv,{p:!0,children:"Но функции еще недостаточно, чтобы применить секционирование на практике. Нам еще нужна схема секционирования, которая с помощью функции свяжет секции таблицы или индекса с файловыми группами. Выше в таблице было описание как такое сопоставление должно быть сделано, нам осталось лишь написать скрипт."}),(0,s.jsx)(h.Z,{code:"\nUSE [Partitioning]\nGO\n\nCREATE PARTITION SCHEME [ByDatePartitionScheme] \n-- Используемая функция секционирования\nAS PARTITION [ByDatePartitionFunction] \n-- Файловые группы указаны в том порядке,\n-- в котором указаны значения фильтров\n-- при создании функции секционирования\nTO ([FG1], [FG2], [FG3], [PRIMARY])\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"В списке объектов базы созданную схему можно также заменить в разделе “Хранилище”."}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/4. Схема секционирования.png",alt:"Схема секционирования",size:j.h2.SMALL}),(0,s.jsx)(r.xv,{p:!0,children:"И так, функция и схема секционирования готовы, осталось применить их на таблицах / индексах."}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Применяем секционирование"}),(0,s.jsx)(r.xv,{p:!0,children:"Выше уже было сказано, что пример секционирования будет выполняться на таблицах двух регистров накопления:"}),(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"“ТоварыНаСкладах_Секции” (таблица “_AccumRg84”)"}),(0,s.jsx)("li",{children:"“Продажи_Секции” (таблица “_AccumRg69”)"})]}),(0,s.jsx)(r.xv,{p:!0,children:"Обе таблицы имеют кластерный индекс, поэтому будет достаточно применить схему секционирования к нему и всем некластеризованным индексам (которых у каждой таблицы по 1 для полей “Регистратор” + “НомерСтроки”). Для этого необходимо пересоздать индексы с явным указанием схемы секционирования. Вот полный скрипт для таблицы “_AccumRg84”. Для “_AccumRg69” скрипт будет аналогичным, только имя таблицы и индексов нужно поменять."}),(0,s.jsx)(h.Z,{code:"\nUSE [Partitioning]\nGO\n\nCREATE UNIQUE CLUSTERED INDEX [_AccumRg84_1] ON [dbo].[_AccumRg84]\n(\n	[_Period] ASC,\n	[_RecorderTRef] ASC,\n	[_RecorderRRef] ASC,\n	[_LineNo] ASC\n)WITH (\n	-- Пересоздать индекс заново, если существует\n	DROP_EXISTING = ON, \n	-- Включить инкрементальную статистику\n	-- Об этом в статье далее\n	STATISTICS_INCREMENTAL = ON)\n-- Указываем схему секционирования и колонку таблицы,\n-- к которой эта схема применяется\nON [ByDatePartitionScheme](_Period)\nGO\n\nCREATE UNIQUE NONCLUSTERED INDEX [_AccumRg84_2] ON [dbo].[_AccumRg84]\n(\n	[_RecorderTRef] ASC,\n	[_RecorderRRef] ASC,\n	[_LineNo] ASC\n	-- Для секционирования в индексе должен присутствовать столбец секционирования\n	-- поэтому стандартный платформенный индекс приходится изменять\n	[_Period] ASC\n)WITH (\n	DROP_EXISTING = ON, \n	STATISTICS_INCREMENTAL = ON)\nON [ByDatePartitionScheme](_Period)\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Для упрощения составления скрипта можно использовать возможности SSMS по генерации DDL-команд для существующих объектов (таблицы и индексы). Сформированные автоматически скрипты можно использовать как шаблоны. Результатом скрипта будет разбиение таблиц и ее индексов на секции. Проверим результат для таблицы “_AccumRg84” и ее кластерного индекса с помощью этого скрипта."}),(0,s.jsxs)(l.b,{"aria-label":"Информация о секциях",children:[(0,s.jsxs)(c.J,{children:[(0,s.jsx)(d.j,{children:"Номер секции"},"PartitionNumber"),(0,s.jsx)(d.j,{children:"Количество строк в секции"},"RowsCount")]}),(0,s.jsxs)(x.y,{children:[(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"1 (FG1)"}),(0,s.jsx)(a.X,{children:"4111890"})]},"1"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"2 (FG2)"}),(0,s.jsx)(a.X,{children:"1059512"})]},"2"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"3 (FG3)"}),(0,s.jsx)(a.X,{children:"82034"})]},"3"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"4 (PRIMARY)  "}),(0,s.jsx)(a.X,{children:"536"})]},"4")]})]}),(0,s.jsx)(r.xv,{p:!0,children:"Итог: основные таблицы регистров разбиты на секции с учетом файловых групп базы данных. Но для чего мы все это делали и что делать дальше?"}),(0,s.jsxs)(r.o_,{title:"Какое бывает секционирование и что такое сегментировани",children:[(0,s.jsx)(r.xv,{p:!0,children:"Необходимо дать некоторое пояснение по поводу секционирования, а также связанного понятия - сегментирование."}),(0,s.jsx)(r.xv,{p:!0,children:"Выделяют три основных вида секционирования:"}),(0,s.jsxs)(r.aV,{type:j.RH.number,children:[(0,s.jsx)("li",{children:"Горизонтальное (обычно его и называют сегментированием) - разбиение таблиц и индексов на части по выбранному ключу (полю)."}),(0,s.jsx)("li",{children:"Вертикальное - применяется для сокращения операций ввода-вывода за счет переноса редко используемых столбцов таблицы в отдельную сущность (так, например, делают при сохранении файлов в отдельный регистр сведений в конфигурациях 1С). "}),(0,s.jsx)("li",{children:"Функциональное - в этом случае данные разделяются по контексту, бизнес-области. Например, данные клиентов отделены от складских данных с помощью схем (платформа 1С такое не применяет). "})]}),(0,s.jsx)(r.xv,{p:!0,children:"В нашем случае мы будем говорить именно про сегментирование, но далее будем называть его как секционирование для упрощения. Также стоит заметить, что в разной литературе дают разные определения этим понятиям, разную классификацию, но смысл остается практически таким же."})]}),(0,s.jsx)(r.xv,{p:!0,children:"Итак, поехали!"}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Какие проблемы решает"}),(0,s.jsx)(r.xv,{p:!0,children:"Выше мы настроили секционирование и даже проверили работает ли оно. Данные таблиц и индексов были распределены между файловыми группами (в нашем случае фактически между отдельными файлами), но какая от этого польза? Далее мы рассмотрим несколько простых кейсов, когда секционирование Вам может помочь."}),(0,s.jsx)(r.xv,{subtitle:!0,className:"mt-10 md:text",children:"Гибкое управление данными"}),(0,s.jsx)(r.xv,{p:!0,children:"В нашем примере есть три секции + одна стандартная. Предположим, что первая секция, хранящая данные регистров до 2011 года, должна сохраняться в системе в качестве архивных данных, при этом нужно снизить затраты дискового пространства для нее."}),(0,s.jsx)(r.xv,{p:!0,children:"Поскольку к этим данным выполняется редкое обращение, то можно использовать сжатие PAGE для таблицы и индексов на этой секции. Сэкономим место на архивных данных, при этом сохраним уровень производительности при работе с остальными секциями (использование сжатия требует доп. ресурсов CPU)."}),(0,s.jsx)(h.Z,{code:"\nALTER INDEX _AccumRg84_1 \n-- При указании секции для сжатия обязательно\n-- указывать перестроение всех секций (REBUILD PARTITION=ALL )\nON _AccumRg84 REBUILD PARTITION=ALL \n-- При сжатии указываем номер секции\nWITH (DATA_COMPRESSION = PAGE ON PARTITIONS(1)) \n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Проверим результат с помощью этого скрипта."}),(0,s.jsxs)(l.b,{"aria-label":"Информация о секциях",children:[(0,s.jsxs)(c.J,{children:[(0,s.jsx)(d.j,{children:"Таблица"},"PartitionNumber"),(0,s.jsx)(d.j,{children:"Объект"},"RowsCount"),(0,s.jsx)(d.j,{children:"Номер секции"},"RowsCount"),(0,s.jsx)(d.j,{children:"Сжатие"},"RowsCount")]}),(0,s.jsxs)(x.y,{children:[(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"_AccumRg84"}),(0,s.jsx)(a.X,{children:"_AccumRg84_1"}),(0,s.jsx)(a.X,{children:"1"}),(0,s.jsx)(a.X,{children:"PAGE"})]},"1"),(0,s.jsxs)(t.g,{children:[(0,s.jsx)(a.X,{children:"_AccumRg69"}),(0,s.jsx)(a.X,{children:"_AccumRg69_1"}),(0,s.jsx)(a.X,{children:"1"}),(0,s.jsx)(a.X,{children:"PAGE"})]},"2")]})]}),(0,s.jsx)(r.xv,{p:!0,children:"Кроме сжатия, для отдельных секций доступны:"}),(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Перенос данных, что может быть актуальным при переносе данных из OLTP в OLAP"}),(0,s.jsx)("li",{children:"Операции обслуживания"}),(0,s.jsx)("li",{children:"Операции бэкапирования"}),(0,s.jsx)("li",{children:"И др."})]}),(0,s.jsx)(r.xv,{p:!0,children:"Тема обширная и рассмотреть ее в одной публикации невозможно, поэтому если Вам это интересно, то рекомендую почитать MSDN."}),(0,s.jsx)(r.xv,{subtitle:!0,className:"mt-10 md:text",children:"Повышение эффективности дисковой подсистемы"}),(0,s.jsx)(r.xv,{p:!0,children:"Секции могут храниться на отдельных дисках, что позволит увеличить пропускную способность дисковой подсистемы при работе с ними, ускорит получение и запись данных."}),(0,s.jsx)(r.xv,{p:!0,children:"Например, есть две файловые группы FG1 и FG2, которые используют два отдельных файла. У нас простой пример и все файлы находятся в одном каталоге, на одном диске. Но никто не мешает распределить файлы по разным дискам, тем самым ускорив операции ввода-вывода с ними. Подобный подход разбиения базы по дисковой подсистеме может дать значительный прирост производительности в зависимости от назначения системы и выполняемых в ней SQL-запросов."}),(0,s.jsx)(r.xv,{p:!0,children:"Часто даются рекомендации по переносу базы tempdb на отдельный диск для улучшения производительности, т.к. это позволяет снизить конкуренцию за дисковые ресурсы между основной базой данных и tempdb. Представьте какие возможности у Вас появятся для оптимизации операций ввода-вывода, если основную базу можно будет расположить на нескольких дисках."}),(0,s.jsx)(r.xv,{subtitle:!0,className:"mt-10 md:text",children:"Оптимизация стратегии бэкапирования"}),(0,s.jsx)(r.xv,{p:!0,children:"В этом случае все сводится к простому правилу - бэкапировать нужно лишь то, что меняется. Если файловая группа FG1 не меняется уже 6 лет, то зачем делать ее регулярный бэкап?"}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/4. Всем нужны бэкапы!.jpg",alt:"Всем нужны бэкапы!",size:j.h2.SMALL}),(0,s.jsx)(r.xv,{p:!0,children:"Вместо этого можно оптимизировать стратегию бэкапирования, делая резервную копию только “свежих” данных. В нашем случае для файловой группы FG1 можно установить режим “Только для чтения”, чтобы в ней никто не смог поменять данные, в т.ч. и через 1С."}),(0,s.jsx)(h.Z,{code:"\nUSE [Partitioning]\nGO\ndeclare @readonly bit\nSELECT @readonly=convert(bit, (status & 0x08)) \nFROM sysfilegroups WHERE groupname=N'FG1'\nif(@readonly=0)\n	ALTER DATABASE [Partitioning] MODIFY FILEGROUP [FG1] READONLY\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Теперь при попытке изменить данные в старом периоде через 1С появится ошибка на уровне СУБД. Это необходимо учитывать и делать проверки на уровне решения 1С."}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/5. Файловая группа только для чтения.png",alt:"Файловая группа только для чтения",size:j.h2.MEDIUM}),(0,s.jsx)(r.xv,{p:!0,children:"Вернемся к формированию бэкапа. Допустим, изначально для базы использовалась полная модель бэкапирования, ежедневно ночью был настроен бэкап полный и лога транзакции каждые 30 минут. Появилась проблема, что из-за большого объема базы полный бэкап выполняется длительное время и мешает работе пользователей и регламентных заданий. Примерный скрипт для формирования полного бэкапа может быть таким."}),(0,s.jsx)(h.Z,{code:"\nBACKUP DATABASE [Partitioning] \nTO  DISK = N'D:\\DBs\\Backup\\Partitioning.bak' \nWITH NOFORMAT, NOINIT,  \nNAME = N'Partitioning-Полная База данных Резервное копирование', \nSKIP, NOREWIND, NOUNLOAD, COMPRESSION,  STATS = 10, CHECKSUM\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Вместо этого сделаем резервное копирование только тех данных, что могут меняться, а файловую группу FG1 в режиме “Только для чтения” исключим из резервной копии. Предполагается, что резервная копия файловой группы FG1 уже есть и ее повторное создание не имеет смысла."}),(0,s.jsx)(h.Z,{code:"\nBACKUP DATABASE [Partitioning] \n	-- Перечисляем файловые группы для создания резервной копии\n	FILEGROUP = N'PRIMARY',  \n	FILEGROUP = N'FG2',  \n	FILEGROUP = N'FG3' \nTO  DISK = N'D:\\DBs\\Backup\\Partitioning.bak' WITH NOFORMAT, \nNOINIT,  \nNAME = N'Partitioning-Полная База данных Резервное копирование', \nSKIP, NOREWIND, NOUNLOAD, COMPRESSION,  STATS = 10, CHECKSUM\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Конечно, работать с такими бэкапами нужно немного иначе, но особых проблем с восстановлением данных не будет. Например, если была повреждена архивная файловая группа FG1, то ее восстановить проще всего, т.к. установлен режим только для чтения."}),(0,s.jsx)(h.Z,{code:"\nRESTORE DATABASE [Partitioning] \nFILE = N'Partitioning_FG1' \nFROM  DISK = N'D:\\DBs\\Backup\\FG1.bak' \nWITH  FILE = 1,  NOUNLOAD,  STATS = 10\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"В случае необходимости восстановления данных из остальных файловых групп и логов транзакций скрипт может быть таким."}),(0,s.jsx)(h.Z,{code:"\nUSE [master]\n\n-- Создаем резервную копию заключительного фрагмента журнала транзакции\n-- и устанавливаем состояние базы в \"NORECOVERY\"\nBACKUP LOG [Partitioning] TO  DISK = N'D:\\DBs\\Backup\\Last_LogBackup.bak' \n	WITH NOFORMAT, NOINIT, NAME = N'Last_LogBackup', \n	NOSKIP, NOREWIND, NOUNLOAD,  NORECOVERY ,  STATS = 5\n\n-- Восстанавливаем состояние базы на указанный момент времени (параметр STOPAT)\nRESTORE DATABASE [Partitioning] FROM  DISK = N'D:\\DBs\\Backup\\WeeklyBackup.bak' \n	WITH  FILE = 1,  NORECOVERY,  NOUNLOAD,  STATS = 5\nRESTORE LOG [Partitioning] FROM  DISK = N'D:\\DBs\\Backup\\LogBackup1.trn' \n	WITH  FILE = 1,  NORECOVERY,  NOUNLOAD,  STATS = 5\nRESTORE LOG [Partitioning] FROM  DISK = N'D:\\DBs\\Backup\\LogBackup2.trn' \n	WITH  FILE = 1,  NOUNLOAD,  STATS = 5,  \nSTOPAT = N'2019-02-08T16:15:13' -- Момент времени для восстановления\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Тема стратегии бэкапирования достаточно обширна, всю ее рассматривать здесь не будем."}),(0,s.jsxs)(r.xv,{p:!0,children:["Что может быть лучше, чем быстрый бэкап ",":)"]}),(0,s.jsx)(r.xv,{subtitle:!0,className:"mt-10 md:text",children:"Улучшение процедур обслуживания"}),(0,s.jsx)(r.xv,{p:!0,children:"Для ускорения процедур обслуживания индексов и статистик можно выполнять операции на отдельных секциях."}),(0,s.jsx)(r.xv,{p:!0,children:"Например, у нас есть 4 секции, причем одна из них вообще в режиме “Только для чтения”. Чтобы уменьшить время обслуживания можно применить скрипт только к последней, “горячей” секции."}),(0,s.jsx)(h.Z,{code:'\nUSE [Partitioning]\nGO\nALTER INDEX [_AccumRg69_1] ON [dbo].[_AccumRg69]\n-- Указание конкретной секции для перестроения\n-- В обычных ситуациях выполняется перестроение всех\n-- секций, что аналогично указанию "REBUILD PARTITION = ALL"\nREBUILD PARTITION = 4\nGO\n                ',className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Окей, с индексами все понятно, но как же статистика? Иногда обслуживание всех статистик может занимать даже больше времени, чем обслуживание индексов. При этом гистограмма распределения значений по таблице / индексу, чем в принципе и является статистика, не рассчитывается для каждой отдельной секции. Но решение все же есть. Начиная с версии SQL Server 2014 появилась так называемая инкрементальная статистика, которая может пересчитываться по секциям."}),(0,s.jsx)(r.xv,{p:!0,children:"По умолчанию объекты базы данных не поддерживают инкрементальную статистику, потому что платформа 1С не включает их явно. Включить данный вид статистики для индекса можно при создании / перестроении."}),(0,s.jsx)(h.Z,{code:"\nCREATE UNIQUE CLUSTERED INDEX [_AccumRg69_1] ON [dbo].[_AccumRg69]\n(\n	[_Period] ASC,\n	[_RecorderRRef] ASC,\n	[_LineNo] ASC\n-- Включение инкрементальной статистики для индекса\n-- Кстати, мы это уже делали в одном из предыдущих скриптов :)\n)WITH (DROP_EXISTING = ON, STATISTICS_INCREMENTAL = ON)\nON [ByDatePartitionScheme](_Period)\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"Для того, чтобы выполнить пересчет для конкретной секции нужно воспользоваться следующим приемом."}),(0,s.jsx)(h.Z,{code:"\nUPDATE STATISTICS [dbo].[_AccumRg69]([_AccumRg69_1])\n-- Указываем конкретную секцию для обновления статистики\nWITH RESAMPLE ON PARTITIONS(4);\n                ",className:"my-5",language:"sql"}),(0,s.jsxs)(r.xv,{p:!0,children:["Для подробной информации о работе инкрементальной статистики и ее “внутренней кухне” рекомендую изучить статью ",(0,s.jsx)("b",{children:(0,s.jsx)("u",{children:(0,s.jsx)(r.e9,{newTab:!0,href:"https://www.mssqltips.com/sqlservertip/4855/sql-server-2014-incremental-update-statistics-per-partition/",children:"“SQL Server 2014 : New incremental statistics”"})})}),", а также на MSDN. В них есть подробное описание как работает инкрементальная статистика, в каких случаях ее стоит использовать, ограничения и др. Если у Вас в базе огромные таблицы, то инкрементальная статистика может быть настоящим спасением при оптимизации обслуживания."]}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/6. За актуальность статистики.jpg",alt:"За актуальность статистики",size:j.h2.MEDIUM}),(0,s.jsx)(r.xv,{p:!0,children:"Подобные подходы актуальны для очень больших таблиц. На сколько это ускорит обслуживание? Ответ на этот вопрос можете дать только Вы, проанализировав объем данных и возможности своей инфраструктуры. К сожалению, инкрементальная статистика не решает проблему снижения эффективности статистики при росте таблиц, но это уже другая история (если интересно, то можно написать в других статьях)."}),(0,s.jsx)(r.xv,{subtitle:!0,className:"mt-10 md:text",children:"Проблемы блокировок"}),(0,s.jsx)(r.xv,{p:!0,children:"С тех пор, как платформа использует свой “костыль” в виде менеджера управляемых блокировок и режим изоляции транзакций Read Commited Snapshot Isolation (RCSI), то проблемы блокировок на уровне SQL Server стало значительно меньше. Однако проблема эскалации блокировок все еще актуальна, т.к. она не решается использованием управляемых блокировок."}),(0,s.jsx)(r.xv,{p:!0,children:"Проблема заключается в том, что при модификации большого объема данных таблицы в рамках одной транзакции SQL Server для оптимизации использования памяти может укрупнить область блокировки до уровня секции таблицы или всей таблицы."}),(0,s.jsx)(r.xv,{p:!0,children:"Подробно этот пункт рассматривать не будем. Скажу лишь кратко, что с помощью секций можно снизить влияние эскалации блокировок. Вместо блокировки на всю таблицу может быть заблокирована одна секций, но это грубое описание."}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Плюсы и минусы"}),(0,s.jsx)(r.xv,{p:!0,children:"Все имеет свои плюсы и минусы, и секционирование тут не исключение."}),(0,s.jsx)(r.xv,{p:!0,children:"Плюсы:"}),(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Гибкое управление данными, за счет действий над отдельными секциями (сжатие, перенос на отдельный диск, перенос данных на другие инстансы, бэкапирование и др.)"}),(0,s.jsx)("li",{children:"Ускорение операций обслуживания (перестроение индексов и обновление статистик по секциям)."}),(0,s.jsxs)("li",{children:["Повышение производительности запросов для некоторых ситуаций. Эту ситуацию мы не рассматривали, но происходит это за счет:",(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Исключение обращений к секциям, которые не соответствую фильтрам запроса."}),(0,s.jsx)("li",{children:"За счет разнесения секций на отдельные диски."})]})]})]}),(0,s.jsx)(r.xv,{p:!0,children:"Минусы:"}),(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Сложность администрирования и поддержки, т.к. требуются дополнительные компетенции."}),(0,s.jsx)("li",{children:"Cложность при разработке баз данных, т.к. секционирование должно учитываться при модификации базы."}),(0,s.jsx)("li",{children:"Как ни странно, секционирование может вызвать проблемы производительности в некоторых запросах. Например, из-за дополнительной операции соединения наборов данных из разных секций. Это стоит учитывать при планировании инфраструктуры и написания SQL-запросов."})]}),(0,s.jsxs)(r.xv,{p:!0,children:["Мы не будем отдельно останавливаться на каждом пункте, т.к. тогда статья станет очень большой и превратиться в книгу.. Более подробную информацию Вы всегда можете узнать на MSDN. Главное что нужно понять, что секционирование не является простым решением, поэтому перед его использованием нужно взвесить все плюсы и минусы. Особенно это важно в контексте платформы 1С, где нет полной власти над базой данных (она как бы есть, но ее как бы нет ",":)",")."]}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Проблемы в мире 1С"}),(0,s.jsx)(r.xv,{p:!0,children:"В контексте платформы 1С секционирование имеет свои особенности и подводные камни, а именно:"}),(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Лицензионное соглашение фирмы “1С” запрещает использовать недокументированные возможности. Только Вы ответственны за то, что делаете. Сам факт нарушения соглашения может как минимум вылиться в отказ в технической поддержки."}),(0,s.jsxs)("li",{children:["Проблемы при обновлении конфигурации, а именно реструктуризации таблиц.",(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Поскольку платформа 1С ничего не знает о секциях, то при реструктуризации все настройки таблиц и индексов будут сброшены на стандартные и секции будут “затерты”."}),(0,s.jsx)("li",{children:"При обновлении платформы 1С на новую версию или отказ от совместимости в конфигурации может привести к значительным изменениям на уровне базы, что может противоречить сделанными Вами изменениям. Например, ранее платформа хранила тип “Хранилище значений” с помощью SQL-типа “IMAGE”. В одной из версий платформы этот тип был заменен на “VARBINARY”. Если такие ситуации не обнаружить, то в лучшем случае реструктуризация прервется с ошибкой, а в худшем случится потеря данных."})]})]}),(0,s.jsxs)("li",{children:["Архитектура таблиц метаданных в большинстве решений противоречит основным требованиям секционирования.",(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Типовые конфигурации в большинстве таблиц имеют разделитель данных с типом “numeric”, который включен во все индексы. Если Вы используете разделитель, то может понадобиться секционировать не просто по периоду, а по периоду с учетом разделителя. Проблема в том, что SQL Server поддерживает только указание одного поля секционирования. Решение тут - создавать виртуальное поле, о котором 1С ничего знать не будет, но этот подход мы сейчас не будем описывать. Если кому-то интересно - пишите в комментариях."}),(0,s.jsx)("li",{children:"Не все типовые индексы можно просто так взять и секционировать, потому что не все они содержат поле секционирования, а это обязательное условие. Выше был пример, когда для включения секционирования пришлось добавлять поле “Период” в индекс по регистратору."}),(0,s.jsx)("li",{children:"И многие другие специфические проблемы, с которыми можно столкнуться."})]})]}),(0,s.jsxs)("li",{children:["Топорное построение SQL-запросов платформой “1С” сводит на нет выигрыш в производительности для запросов по большим таблицам. Например, выше выполнено секционирование таблицы “_AccumRg84”. Обслуживание ускорили, архивные данные сжимаем и поставили только для чтения, а бэкапы теперь выполняются гораздо быстрее. Но вот исключение обращений к архивным секциям в запросах не работает. Выполняя такой запрос из 1С мы ожидали, что будет прочитана только секция в файловой группе “PRIMARY”. Вот текст запроса и план его выполнения.",(0,s.jsx)(h.Z,{code:"\nexec sp_executesql N'\nSELECT\nCAST(COUNT_BIG(T1._RecorderRRef) AS NUMERIC(12))\nFROM dbo._AccumRg84 T1\nWHERE ((T1._Period >= @P1) AND (T1._Period <= @P2))\n'\n-- Все даты преобразуются к типу datetime2(3),\n-- фактически период хранится с типом datetime2(0)\n,N'@P1 datetime2(3),@P2 datetime2(3)'\n,'4019-01-01 00:00:00','4019-01-31 23:59:59'\n                        ",className:"my-5",language:"sql"}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/7. Пример плана 1.png",alt:"План запроса",size:j.h2.MEDIUM}),(0,s.jsx)(r.xv,{p:!0,children:"Обратите внимание, что запрос секционированный и фактически обработано 4 секции, что не правильно. Все дело в том, что платформа по неведомой причине преобразовывает все параметры дат в SQL-запросах к типу “datetime(3)”, хотя в таблицах даты хранятся с типом “datetime(0)”. Для SQL Server это важно, т.к. происходит неявное преобразование типов и СУБД не может использовать секции. Если убрать преобразование дат и сразу поставить нужный тип “datetime(0)”, то ситуация кардинально изменяется."}),(0,s.jsx)(h.Z,{code:"\nexec sp_executesql N'\nSELECT\nCAST(COUNT_BIG(T1._RecorderRRef) AS NUMERIC(12))\nFROM dbo._AccumRg84 T1\nWHERE ((T1._Period >= @P1) AND (T1._Period <= @P2))\n'\n-- Убираем преобразование типов к datetime2(3)\n,N'@P1 datetime2(0),@P2 datetime2(0)'\n,'4019-01-01 00:00:00','4019-01-31 23:59:59'\n                        ",className:"my-5",language:"sql"}),(0,s.jsx)(r.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-02/partitioning-1c-world/8. Пример плана 2.png",alt:"План запроса",size:j.h2.MEDIUM})]})]}),(0,s.jsx)(r.xv,{p:!0,children:"Как можно заметить, запрос остается секционированным, но прочитана всего 1 секция. Это может быть критическим для больших операций чтения, например для Table Scan. Ведь прочитать одну секцию вместо 4 все же лучше."}),(0,s.jsxs)(r.o_,{title:"Крик души",children:[(0,s.jsxs)(r.xv,{p:!0,children:["Вообще, платформа 1С имеет множество таких проблем, которые всплывают на стороне СУБД и не видны на небольших базах. Кроме случая с излишним преобразованием типов в запросах есть множество других проблем: Неоптимальные запросы при наличии разделителя данных. Тяжелые запросы в динамических списках, если в качестве основного источника используется регистр сведений. Недостаточные индексы для метаданных. Медленная запись больших наборов записей, даже с учетом оптимизаций в 8.3.12. Решение с индексами для регистров бухгалтерии при наличии более 3 субконто или большого количества измерений. И многое другое. Безвыходных ситуаций не бывает, но иногда это очень мешает. ",":)"]}),(0,s.jsx)(r.xv,{p:!0})]}),(0,s.jsx)(r.xv,{p:!0,children:"Первую проблему с лицензионным соглашением мы решить не в силах, можно с ней только жить и принять. Проблему с архитектурой таблиц метаданных и особенными запросами платформы решить можно, но это уже выходит за рамки статьи. Ниже лишь кратко продемонстрируем решение проблемы с реструктуризациями, чтобы в один прекрасный момент не потерять секции. Если Вам интересно как исправить запросы платформы 1С или архитектуру таблиц метаданных на стороне БД пишите в комментариях, может это будет стимул для новой статьи."}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Костыли и палки"}),(0,s.jsxs)(r.xv,{p:!0,children:["В статье ",(0,s.jsx)("b",{children:(0,s.jsx)("u",{children:(0,s.jsx)(r.e9,{newTab:!0,href:"/pages/blog/DevOps/2018-11/custom-index-for-1C.tsx",children:"“Создаем свои индексы для баз 1С. Со своей структурой и настройками!”"})})})," мы говори про создание и поддержку неплатформенных индексов для баз 1С. Для решения проблем удаления собственных индексов при реструктуризации использовались глобальные триггеры, перехватывающие события создания таблиц и индексов платформой и добавляющие свои нужные действия (создание индексов, изменение параметров индексов и таблиц и др.)."]}),(0,s.jsx)(r.xv,{p:!0,children:"Этот же подход подойдет и для сохранения настроек секционирования, но с некоторыми особенностями."}),(0,s.jsx)(h.Z,{code:"\nCREATE TRIGGER [CustomSettingsMaintenance_OnIndexCreate]\nON ALL SERVER \nAFTER CREATE_INDEX\nAS\n\nBEGIN\n	SET NOCOUNT ON;\n\n	-- В случае возникновения ошибок продолжаем работу\n	SET XACT_ABORT OFF;\n\n	DECLARE @SchemaName SYSNAME,\n		@TableName SYSNAME,\n		@DatabaseName SYSNAME,\n		@IndexName SYSNAME;\n\n    SELECT @TableName = EVENTDATA().value('(/EVENT_INSTANCE/TargetObjectName)[1]','SYSNAME')\n    SELECT @SchemaName = EVENTDATA().value('(/EVENT_INSTANCE/SchemaName)[1]','SYSNAME')\n	SELECT @IndexName = EVENTDATA().value('(/EVENT_INSTANCE/ObjectName)[1]','SYSNAME')\n	SELECT @DatabaseName = EVENTDATA().value('(/EVENT_INSTANCE/DatabaseName)[1]','SYSNAME');\n\n	-- Здесь запускаем скрипт перестроения индекса с учетом схемы секционирования \n	-- Для индексов, которые не содержат поле секционирования, также выполняем\n	-- их перестроение с добавлением этого поля. Если необходимо, то\n	-- включаем инкрементальную статистику.\n	-- Дополнительно можно учитывать файловые группы только для чтения и отключать\n	-- эту настройку на время реструктуризации.\n\n	-- Возвращаем значение по умолчанию для ситуаций с ошибками в транзакции\n  	SET XACT_ABORT ON;\n\nEND\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(r.xv,{p:!0,children:"С помощью глобального триггера отлавливаем события изменения индексов и перестраиваем их с учетом параметров секционирования. Подробнее об этом подходе можно прочитать на GitHub."}),(0,s.jsx)(r.xv,{title:!0,className:"mt-10 md:text",children:"Это конец"}),(0,s.jsx)(r.xv,{p:!0,children:"Вот и все. На самом деле ничего сложного, если понимать для чего это нужно."}),(0,s.jsx)(r.xv,{p:!0,children:"Нужно ли это использовать на практике? Решать только Вам, но если хоть один из пунктов к Вам относится, то секционирование точно не для Вас:"}),(0,s.jsxs)(r.aV,{children:[(0,s.jsx)("li",{children:"Используется файловый режим работы информационной базы"}),(0,s.jsx)("li",{children:"Нет никаких проблем производительности и стабильности информационной системы"}),(0,s.jsx)("li",{children:"Считаете большой ошибкой выход за пределы экосистемы платформы 1С"}),(0,s.jsx)("li",{children:"Вы сотрудник фирмы “1С”"})]}),(0,s.jsx)(r.xv,{p:!0,children:"В случае если у Вас высоконагруженная база, то рассмотреть возможность секционирования стоит, но делать это должен либо эксперт, либо архитектор 1С вместе с DBA."})]})}},7855:function(e,n,i){"use strict";var s,r;i.d(n,{b:function(){return s}}),(r=s||(s={})).Min="350px",r.Standard="700px",r.Large="1000x",r.Unlimited=""},4313:function(e,n,i){"use strict";var s=i(7340),r=i(5893),l=i(7294),c=i(4965),d=i(1240),x=i(1686),t=i(7855);function a(){let e=(0,s._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return a=function(){return e},e}function h(){let e=(0,s._)(["\n        max-height: ","\n    "]);return h=function(){return e},e}n.Z=e=>{let{code:n,className:s,language:j,maxHeight:N=t.b.Standard}=e;(void 0!==i.g?i.g:window).Prism=c.p1,i(1354),i(9016),i(5266),i(2927),i(1315),i(7874),i(6862);let o=null!=N?N:t.b.Standard,E=x.ZP.pre(a()),S=(0,x.ZP)(E)(h(),o);return(0,r.jsx)("div",{className:(0,d.GF)("bg-blue-500 md:p-1 p-2",s),children:(0,r.jsx)("div",{className:"shadow-lg",children:(0,r.jsx)(c.y$,{theme:c.np.vsDark,code:n.trim(),language:null!=j?j:j="tsx",children:e=>{let{className:n,style:i,tokens:s,getLineProps:c,getTokenProps:d}=e;return(0,r.jsx)(S,{className:n,style:i,children:s.map((e,n)=>(0,l.createElement)("div",{...c({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,l.createElement)("span",{...d({token:e,key:n}),key:Math.random()}))))})}})})})}},4853:function(e,n,i){"use strict";i.d(n,{Ee:function(){return d},Xg:function(){return l},Y7:function(){return h},aV:function(){return t},e9:function(){return a},o_:function(){return j},tf:function(){return N},ty:function(){return x},xv:function(){return c}});var s=i(5152),r=i.n(s);let l=r()(()=>Promise.all([i.e(9686),i.e(4738),i.e(4838),i.e(1664),i.e(8765)]).then(i.bind(i,8765)),{loadableGenerated:{webpack:()=>[8765]}}),c=r()(()=>Promise.all([i.e(9511),i.e(935)]).then(i.bind(i,935)),{loadableGenerated:{webpack:()=>[935]}}),d=r()(()=>Promise.all([i.e(328),i.e(7651)]).then(i.bind(i,7651)),{loadableGenerated:{webpack:()=>[7651]}}),x=r()(()=>Promise.all([i.e(9686),i.e(6979)]).then(i.bind(i,6979)),{loadableGenerated:{webpack:()=>[6979]}}),t=r()(()=>Promise.all([i.e(4159),i.e(7355)]).then(i.bind(i,7355)),{loadableGenerated:{webpack:()=>[7355]}}),a=r()(()=>Promise.all([i.e(1664),i.e(3220)]).then(i.bind(i,3220)),{loadableGenerated:{webpack:()=>[3220]}});r()(()=>i.e(3140).then(i.bind(i,3140)),{loadableGenerated:{webpack:()=>[3140]}});let h=r()(()=>Promise.all([i.e(2004),i.e(736)]).then(i.bind(i,736)),{loadableGenerated:{webpack:()=>[736]}}),j=r()(()=>Promise.all([i.e(8331),i.e(2877),i.e(2660),i.e(9718),i.e(5090),i.e(9606)]).then(i.bind(i,9606)),{loadableGenerated:{webpack:()=>[9606]}}),N=r()(()=>Promise.all([i.e(8331),i.e(1664),i.e(2660),i.e(9718),i.e(8496)]).then(i.bind(i,8496)),{loadableGenerated:{webpack:()=>[8496]}})},7957:function(e,n,i){"use strict";i.d(n,{q:function(){return d}});var s=i(1086),r=i(9373),l=i(7794),c=i(7294);function d(e={}){let{id:n,defaultOpen:i,isOpen:d,onClose:x,onOpen:t,onChange:a=()=>{}}=e,h=(0,l.W)(t),j=(0,l.W)(x),[N,o]=(0,r.z)(d,i||!1,a),E=(0,c.useId)(),S=n||E,m=void 0!==d,A=(0,c.useCallback)(()=>{m||o(!1),null==j||j()},[m,j]),R=(0,c.useCallback)(()=>{m||o(!0),null==h||h()},[m,h]),T=(0,c.useCallback)(()=>{(N?A:R)()},[N,R,A]);return{isOpen:!!N,onOpen:R,onClose:A,onOpenChange:T,isControlled:m,getButtonProps:(e={})=>({...e,"aria-expanded":N,"aria-controls":S,onClick:(0,s.t)(e.onClick,T)}),getDisclosureProps:(e={})=>({...e,hidden:!N,id:S})}}}},function(e){e.O(0,[6443,8331,552,2877,5187,2888,9774,179],function(){return e(e.s=213)}),_N_E=e.O()}]);