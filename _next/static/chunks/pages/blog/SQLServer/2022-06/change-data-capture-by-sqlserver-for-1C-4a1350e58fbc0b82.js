(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2728],{3914:function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C",function(){return a(8880)}])},8880:function(e,n,a){"use strict";a.r(n);var s=a(5893),t=a(9305);a(7294);var c=a(850),i=a(7105);n.default=()=>(0,s.jsxs)(t.Xg,{blogcentered:!0,children:[(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Следи за рукой"}),(0,s.jsx)(t.xv,{p:!0,children:"Знание - сила! А знание, подкрепленное фактами, достоверными данными и высокой актуальностью - это сила, ответственность и безграничные возможности в части анализа информации."}),(0,s.jsx)(t.xv,{p:!0,children:"Не такая уж и редкая задача - получить историю изменения данных, узнать кто, что и когда изменил в том или ином объекте. Пореже нужно отправлять изменения в другие информационные системы или даже хранилища данных, для чего создаются различные способы регистрации изменений. Но хоть эти задачи и звучат просто, но чем больше система и чем сложнее архитектура потоков данных, тем больше проблем с этим возникает:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"Проблемы производительности при регистрации изменений в высоконагруженных системах"}),(0,s.jsx)("li",{children:"Критичность ошибок регистрации данных, если часть изменений не будет зарегистрирована или потеряна"}),(0,s.jsx)("li",{children:"Высокая детализация изменений приводит к значительному росту базы данных и таблиц регистрации, в частности, а также существенно может замедлять процессы в информационной системе"}),(0,s.jsx)("li",{children:"Отправка изменений системам-подписчикам требует большой надежности и скорости работы"}),(0,s.jsx)("li",{children:"И много других вопросов, с которыми придется столкнуться."})]}),(0,s.jsx)(t.xv,{p:!0,children:"И это нормально! Не нормально - это пытаться использовать один “универсальный” инструмент для решения всех этих задач, проблем."}),(0,s.jsxs)(t.xv,{p:!0,children:["Так давайте пойдем дальше и посмотрим на один из путей решения. Один из множества. А именно на механизм ",(0,s.jsx)("b",{children:(0,s.jsx)("u",{children:(0,s.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/SQL-Server-Track-Data-Changes",children:"Change Data Capture из SQL Server"})})}),". И путь его использования с платформой 1С."]}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Обычный ход"}),(0,s.jsx)(t.xv,{p:!0,children:"Прежде чем начать нужно сказать пару слов о том как это обычно делается в мире 1С. Примерно это выглядит так:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Планы обмена"})," - объекты конфигурации 1С, задача которых предоставить инфраструктуру для регистрации изменений, формирования и обработки сообщений и возможность использования распределенной информационной базы (что не обязательно). При этом сам механизм имеет как плюсы, так и минусы. Подробно на этом останавливаться не будем, но в высоконагруженных системах использовать планы обмена дело последнее из-за узких мест в его работе."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Собственная таблица регистрации"})," - обычно реализуется на регистрах сведений, но бывают и более извращенные случаи. Фактически создается отдельная таблица, где разработчик может более гибким образом управлять статусами объекта. В основном так решаются задачи регистрации изменений только для обмена со сторонними системами. Истории изменений самих данных как таковых нет."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Версионирование объектов"})," - штатный механизм из БСП и его вариации в виде регистра сведений, в котором сохраняется сериализованная версия объекта на момент изменения. Относительно популярный подход хранения изменений объекта с детализацией до конкретных полей, но влияющий как на скорость записи в базу (обычно незначительно, относительно основного времени записи), так и на размер самой базы (а этот фактор уже очень сильный, иногда половину размера базы может занять история версий объектов, особенно если их не чистить).",(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"Сам подход хранения версий был настолько популярен, что в итоге подобный же механизм включили на уровне самой платформы 1С в виде “Истории данных”, который проще в использовании, но имеет меньше контроля над своей работой. И больше ошибок, хотя с ними сталкивался достаточно давно и в новых версиях может все работает намного лучше."}),(0,s.jsx)("li",{children:"Механизм решает задачу хранения истории изменений, но работает относительно медленно при чтении данных версий, т.к. каждую из них нужно предварительно распаковать или нормализовать."})]})]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Журнал регистрации"})," - еще один штатных механизм для логирования изменений, но на верхнем уровне. Больше подходит для задач аудита и то не всегда. Содержит информацию кто, что и когда изменил, а также большое количество других событий для анализа. В части отслеживания изменений может помочь увидеть только сам факт изменения и его инициатора, но на вопросы кто изменил и что точный ответ дать не сможет. Хотя есть умельцы, которые версии объектов в виде текста сохраняют в журнал регистрации. Без комментариев. В целом механизм медленный и не поддающийся нормальной интеграции с другими инструментами и системами, только через различные костыли."]})]}),(0,s.jsx)(t.xv,{p:!0,children:"Это основное, что касается задач регистрации изменений и хранения истории версий объектов. Есть и другие пути, которые в мире 1С часто используют, немного выходя за границы платформы. Но об этом смысла рассказывать нет. Перейдем к теме статьи."}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Берем под контроль"}),(0,s.jsxs)(t.xv,{p:!0,children:["Отбросим штатные средства и попытаемся использовать механизм регистрации изменений",(0,s.jsx)("b",{children:(0,s.jsx)("u",{children:(0,s.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/SQL-Server-Track-Data-Changes",children:"Change Data Capture из SQL Server. "})})}),"Главная причина, почему будем использовать именно его - доступность (SQL Server до сих пор самая популярная СУБД для систем на базе 1С), высокая производительность и детализация истории изменений. Хотя и для ",(0,s.jsx)("b",{children:(0,s.jsx)("u",{children:(0,s.jsx)(t.e9,{newTab:!0,href:"https://datacater.io/blog/2021-09-02/postgresql-cdc-complete-guide.html",children:"PostgreSQL подобные возможности есть"})})}),", но мы их рассматривать не будем. Поехали!"]}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Общая архитектура"}),(0,s.jsx)(t.xv,{p:!0,children:"В чем суть механизма CDC? Вы включаете для базы данных поддержку использования CDC, затем включаете отслеживание изменений для конкретных таблиц базы данных. При внесении изменений в таблицы, информация об этом появляется в журнале транзакций, вне зависимости от модели восстановления базы данных (простой или полной) и вот именно эти данные из журнала транзакций и служат источником информации о вносимых изменениях."}),(0,s.jsx)(t.xv,{p:!0,children:"Фоновый процесс сканирует записи в журнале транзакций и загружает их в таблицы регистрации изменений, которые механизм CDC создает автоматически на каждую отслеживаемую таблицу. Таким образом, регистрация изменений происходит асинхронно и не влияет явно на операции в базе данных."}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/1. Схема CDC.png",alt:"Схема CDC",size:i.h2.XS}),(0,s.jsx)(t.xv,{p:!0,children:"При включении поддержки CDC для всей базы сначала создаются служебные таблицы в схеме “cdc”, информацию о которых Вы можете узнать в официальной документации (в SSMS их можно найти в списке системных таблиц):"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"[cdc].[change_tables]"}),(0,s.jsx)("li",{children:"[cdc].[ddl_history]"}),(0,s.jsx)("li",{children:"[cdc].[lsn_time_mapping]"}),(0,s.jsx)("li",{children:"[cdc].[captured_columns]"}),(0,s.jsx)("li",{children:"[cdc].[index_columns]"})]}),(0,s.jsx)(t.xv,{p:!0,children:"Как только Вы включаете регистрацию изменений для конкретной таблицы, например, для таблицы [dbo].[v8users], то сразу добавляется таблица для сохранения изменений [cdc].[dbo_v8users_CT] со структурой, аналогичной исходной таблице, но при этом с дополнительными служебными полями:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"[__$start_lsn]"})," - Регистрационный номер транзакции в журнале (LSN), связанный с фиксацией транзакции изменения."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"[__$end_lsn]"})," - Указано только в ознакомительных целях. Не поддерживается. Совместимость с будущими версиями не гарантируется."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"[__$seqval]"})," - Значение последовательности, используемое для упорядочивания изменений строк в пределах транзакции."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"[__$operation]"})," - Определяет операцию языка обработки данных (DML). 1 - удаление, 2 - вставка, 3 - обновление (старые значения), 4 - обновление (новые значения)."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"[__$command_id]"})," - Отслеживает порядок операций в транзакции."]})]}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/2. Хранимые процедуры CDC.png",alt:"Хранимые процедуры CDC",size:i.h2.SMALL}),(0,s.jsx)(t.xv,{p:!0,children:"Таким образом, механизм CDC позволяет собрать историю изменения данных в таблицах на физическом уровне, что предоставляет максимальную детализацию истории изменений. Но это также создает некоторые особенности в части обработки этих данных, т.к. некоторые операции могут формировать несколько операций в истории изменения данных. Например, операция обновления может быть представлена операцией удаления и операцией добавления, но с одним идентификатором транзакции. Это нужно учитывать."}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/3. Функции CDC.png",alt:"Функции CDC",size:i.h2.SMALL}),(0,s.jsx)(t.xv,{p:!0,children:"Кроме служебных таблиц в базе появляются также объекты:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"Множество служебных хранимых процедур в схеме “cdc”."}),(0,s.jsx)("li",{children:"И функции для удобного получения истории изменений по таблицам."}),(0,s.jsx)("li",{children:"Задания для загрузки изменений из журнала транзакций и очистки исторических данных."}),(0,s.jsx)("li",{children:"И некоторые другие объекты."})]}),(0,s.jsx)(t.xv,{p:!0,children:"И все было бы хорошо, но просто так CDC подружить с 1С не получится, т.к. появятся следующие проблемы:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"При проведении реструктуризации базы данных механизм CDC для обновляемой таблицы будет отключен и нужно будет его вручную включить обратно."}),(0,s.jsx)("li",{children:"В момент отключения механизма CDC из-за реструктуризации может появиться потеря информации об изменениях."}),(0,s.jsx)("li",{children:"И, конечно, будет проблема в части использования информации об изменении данных из CDC, ведь официальной поддержки у платформы 1С для этого механизма нет."})]}),(0,s.jsx)(t.xv,{p:!0,children:"Но не стоит отчаиваться, так как все эти проблемы можно решить. Этим мы и займемся дальше. В одной статье полноценно все рассказать нельзя, но направление работ определить точно можно."}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Делаем настройку"}),(0,s.jsxs)(t.xv,{p:!0,children:["Данный подход по настройке CDC подходит для любых приложений, которые используют SQL Server в качестве СУБД.",(0,s.jsx)("b",{children:(0,s.jsx)("u",{children:(0,s.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/SQL-Server-Track-Data-Changes/CDC-Under-Control",children:"Подробные шаги по настройке описаны здесь. "})})}),"Мы будем адаптировать подход к информационной базе 1С."]}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Подготовка"}),(0,s.jsx)(t.xv,{p:!0,children:"На первом шаге создадим в базе новую схему данных “yy”, чтобы все новые объекты хранить там и не смешивать их с объектами платформы 1С."}),(0,s.jsx)(c.Z,{code:"\nCREATE SCHEMA [yy] AUTHORIZATION [dbo]\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"Первым объектом в новой схеме станет таблица настроек. В ней мы будем хранить следующую информацию:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"Имя исходной таблицы в базе данных, для которой мы хотим поддерживать настройки CDC."}),(0,s.jsx)("li",{children:"Флаг использования CDC."}),(0,s.jsx)("li",{children:"Имя таблицы CDC, которая была создана системой автоматически. Вручную не заполняем (!!!)."}),(0,s.jsx)("li",{children:"Текущее имя таблицы, куда переадресуется сохранение регистрируемых данных. То есть данные в основной таблице CDC мы хранить не будем, они будут переадресованы в нашу собственную таблицу. Этот параметр вручную заполнять не нужно (!!!), все будет сделано автоматически."}),(0,s.jsx)("li",{children:"И данные, по которым мы можем определить изменяли ли таблицу DDL-командами: идентификатор объекта и дата последнего изменения объекта."})]}),(0,s.jsx)(c.Z,{code:"\n-- Таблица настроек CDC\nCREATE TABLE [yy].[MaintenanceSettingsCDC](\n	[ID] [int] IDENTITY(1,1) NOT NULL,\n	[SchemaName] [nvarchar](255) NOT NULL,\n	[TableName] [nvarchar](255) NOT NULL,\n	[UseCDC] [bit] NOT NULL,\n	[SchemaNameCDC] [nvarchar](255) NULL,\n	[TableNameCDC] [nvarchar](255) NULL,\n	[TableNameCDCHistory] [nvarchar](255) NULL,\n	[CaptureInstanceCDC] [nvarchar](255) NULL,\n	[TableObjectId] [int] NULL,\n	[TableSchemaLastChangeDate] [datetime2](7) NULL,\n	CONSTRAINT [PK_MaintenanceSettingsCDC] PRIMARY KEY CLUSTERED \n	(\n		[ID] ASC\n	) ON [PRIMARY]\n) ON [PRIMARY]\nGO\n\n-- Индекс для защиты уникальности настроек. На одну таблицу в схеме данных\n-- может быть только одна настройка.\nCREATE UNIQUE NONCLUSTERED INDEX [UX_MaintenanceSettingsCDC_BySchemaAndTableName] \nON [yy].[MaintenanceSettingsCDC]\n(\n	[SchemaName] ASC,\n	[TableName] ASC\n) ON [PRIMARY]\nGO\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"Фактически, интерактивно нужно заполнять лишь поля SchemaName, TableName и UseCDC, а остлаьное будет заполнено автоматически."}),(0,s.jsx)(t.xv,{p:!0,children:"Дополнительно создадим две функции, которые будут возвращать имена схем. Это просто для удобства."}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Небольшие служебные объекты"}),(0,s.jsx)(c.Z,{code:"\n-- Функция возвращает имя схемы данных CDC по умолчанию.\n-- Маловероятно, что Вам придется как-то эту часть изменять.\nCREATE FUNCTION [yy].[GetCDCSchemeName]()\nRETURNS nvarchar(255)\nAS\nBEGIN\n	RETURN N'cdc';\nEND\nGO\n\n-- Функция возвращает имя схемы данных, где будут находиться служебные объекты.\n-- Вы можете изменить ее под свои нужды. Только не забудьте исправить имя схемы\n-- в DDL-скриптах создания объектов базы данных.\nCREATE FUNCTION [yy].[GetMainSchemeName]()\nRETURNS nvarchar(255)\nAS\nBEGIN\n	RETURN N'yy';\nEND\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"И самое главное в части настроек - это добавить процедуру для автоматического заполнения служебных полей, ведь вручную мы указываем только:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"Имя схемы исходной таблицы"}),(0,s.jsx)("li",{children:"Имя исходной таблицы"}),(0,s.jsx)("li",{children:"И флаг использования CDC"})]}),(0,s.jsx)(t.xv,{p:!0,children:"Вот как будет выглядеть эта процедура."}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Процедура обновления служебных полей в настройке"}),(0,s.jsx)(c.Z,{code:"\n-- Процедура для обновления служебных полей настроек CDC\nCREATE PROCEDURE [yy].[UpdateServiceMaintenanceSettingsCDC]\n	@settingId int,\n	@schemaNameCDC nvarchar(255) = null output,\n	@tableNameCDC nvarchar(255) = null output,\n	@tableNameCDCHistory nvarchar(255) = null output,\n	@captureInstanceCDC nvarchar(255) = null output,\n	@tableObjectId int = null output,\n	@tableSchemaLastChangeDate datetime2(0) = null output\nAS\nBEGIN\n	DECLARE\n		@schameName nvarchar(255),\n		@tableName nvarchar(255);\n\n	SET NOCOUNT ON;\n\n	BEGIN TRAN;\n\n	SELECT\n		@schameName = SchemaName,\n		@tableName = TableName\n	FROM [yy].[MaintenanceSettingsCDC]\n	WHERE ID = @settingId\n\n	-- Получаем идентификатор исходной таблицы,\n	-- а также дату последнего изменения таблицы DDL-командами\n	DECLARE @currentCDCEnabled bit = 0;\n	SELECT \n		@tableObjectId = object_id,\n		@tableSchemaLastChangeDate = \n			CASE WHEN create_date > modify_date THEN create_date\n				ELSE modify_date\n			END\n	FROM sys.tables tb\n		INNER JOIN sys.schemas s \n		on s.schema_id = tb.schema_id\n	WHERE s.name = @schameName AND tb.name = @tableName\n\n	-- Сохраняем информацию о CDC:\n	--	* Имя схемы CDC\n	--	* Имя таблицы CDC\n	--	* Имя переопределенной таблицы CDC. Внимание! Имя формируется заново\n	--		при каждом вызове. Это нужно учитывать при использовании процедуры\n	--	* Имя экземпляра объекта сбора данных\n	SELECT \n		  @schemaNameCDC = [yy].[GetCDCSchemeName](),\n		  @tableNameCDC = OBJECT_NAME([object_id]),\n		  @tableNameCDCHistory = OBJECT_NAME([object_id]) + '_' \n			+ replace(convert(varchar, getdate(),101),'/','') + '_' \n			+ replace(convert(varchar, getdate(),108),':',''),\n		  @captureInstanceCDC = capture_instance\n	FROM [cdc].[change_tables]\n	WHERE source_object_id = @tableObjectId\n\n	-- Обновляем настройку\n	UPDATE [yy].[MaintenanceSettingsCDC]\n	SET\n		[SchemaNameCDC] = @schemaNameCDC,\n		[TableNameCDC] = @tableNameCDC,\n		[TableNameCDCHistory] = @tableNameCDCHistory,\n		[CaptureInstanceCDC] = @captureInstanceCDC,\n		[TableObjectId] = @tableObjectId,\n		[TableSchemaLastChangeDate] = @tableSchemaLastChangeDate\n	WHERE ID = @settingId\n\n	COMMIT TRAN;\n\n	RETURN 0;\nEND\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"Все основные моменты описаны на листинге выше."}),(0,s.jsx)(t.xv,{p:!0,children:"Теперь мы готовы перейти к следующему этапу."}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Переопределяем поведение"}),(0,s.jsx)(t.xv,{p:!0,children:"Платформа 1С во время реструктуризации пересоздает таблицы, что может быть большой проблемой при использовании CDC. После пересоздания таблицы механизм CDC уже по факту отключен и новые изменения не регистрируются. Пока кто-то вручную его не включит, все сделанные изменения с этот момента будут потеряны. Это самая частая проблема в таких сценариях использования."}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/4. Таблица регистрации CDC.png",alt:"Таблица регистрации CDC",size:i.h2.SMALL}),(0,s.jsx)(t.xv,{p:!0,children:"Для решения этой проблемы предлагается такой вариант:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"Изменить поток данных об изменениях, который формируется из файла логов транзакций, таким образом, чтобы изменения записывались не в служебную таблицу CDC (которая как-раз и удаляется при реструктуризации), а в нашу собственную таблицу. Тогда при реструктуризации никаких потерянных изменений не будет."}),(0,s.jsx)("li",{children:"Ну а для включения CDC после реструктуризации сделаем некоторое задание (job), которое асинхронно обновит настройки CDC для новых таблиц максимально оперативно."})]}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/5. Собственные таблицы регистрации CDC.png",alt:"Собственные таблицы регистрации CDC",size:i.h2.SMALL}),(0,s.jsx)(t.xv,{p:!0,children:"Первым пунктом и займемся. Схема будет такой:"}),(0,s.jsxs)(t.aV,{type:i.RH.number,children:[(0,s.jsx)("li",{children:"Есть штатная таблица CDC, куда SQL Server в реляционном формате сохраняет данные об изменениях. О них мы уже говорили выше. На скриншоте пример такой таблицы. Все они находятся в схеме “cdc”."}),(0,s.jsx)("li",{children:'Мы автоматически по таблице настроек CDC “MaintenanceSettingsCDC” будем создавать в схеме “yy” служебную таблицу с именем формата "[ИмяТаблицыCDC]_[ДатаСозданияСоВременем]". При каждой реструктуризации будет создаваться такая таблица, что позволит сохранить работоспособность CDC при любых изменениях структуры таблицы. Фактически у нас будет история изменений таблицы DDL-командами. На скриншоте как-раз есть история из трех реструктуризаций.'}),(0,s.jsx)("li",{children:"Чтобы новая, переопределенная таблица CDC была задействована, нужно для штатной таблицы CDC создать триггер вида “INSTEAD OF INSERT”, чтобы все вставки перенаправлялись в нашу собственную таблицу."}),(0,s.jsx)("li",{children:"В момент переключения также переместим все накопившиеся изменения из штатной таблицы CDC в нашу собственную таблицу. Так никакие изменения не потеряются."})]}),(0,s.jsx)(t.xv,{p:!0,children:"Такой подход исключит потерю данных в таблицах CDC при изменении структуры основных таблиц, т.к. штатные таблицы CDC практически всегда будут пустыми. Переключение с таблицы CDC на нашу собственную таблицу будем выполнять следующей процедурой."}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Перенаправление потока данных CDC в собственные таблицы"}),(0,s.jsx)(c.Z,{code:"\n-- Процедура переопределения потока данных в таблицу CDC на наши собственные\n-- таблицы. Переопределение выполняется для конкретной настройки в таблице MaintenanceSettingsCDC\nCREATE PROCEDURE [yy].[OverrideDataFlowForCDC]\n	@settingId int\nAS\nBEGIN\n	SET NOCOUNT ON;\n\n	DECLARE @originalTableName sysname;\n	DECLARE @destinationTableName sysname;\n\n	-- Читаем данные переданной настройки CDC\n	SELECT\n		@destinationTableName = [TableNameCDCHistory],\n		@originalTableName = [TableNameCDC]\n	FROM [yy].[MaintenanceSettingsCDC]\n	WHERE ID = @settingId\n\n	DECLARE @originalSchemaName sysname = [yy].[GetCDCSchemeName]();\n	DECLARE @destinationSchemaName sysname = [yy].[GetMainSchemeName]();\n	DECLARE @destinationObjectFullName nvarchar(max) = @destinationSchemaName + '.' + @destinationTableName;\n\n	-- Формируем список таблиц для генерации скриптов создания копий таблиц и индексов,\n	-- триггеров и их пересоздание\n	DECLARE @tableName sysname;\n	DECLARE tables_cursor CURSOR  \n	FOR SELECT\n		s.[name]\n	FROM SYSOBJECTS s LEFT JOIN sys.objects objs on s.id = objs.object_id\n	WHERE s.xtype = 'U'\n		and SCHEMA_NAME(objs.schema_id) = @originalSchemaName\n		AND s.[name] IN (\n			@originalTableName\n		);\n	OPEN tables_cursor;\n\n	FETCH NEXT FROM tables_cursor INTO @tableName;\n\n	WHILE @@FETCH_STATUS = 0  \n	BEGIN\n		DECLARE @tableNameFull SYSNAME\n		SELECT @tableNameFull = @originalSchemaName + '.' + @tableName\n\n		DECLARE \n			  @object_name SYSNAME\n			, @object_id INT\n\n		-- Подготовка к формированию скриптов по таблицам и индексам\n		SELECT \n			  @object_name = '[' + s.name + '].[' + o.name + ']'\n			, @object_id = o.[object_id]\n		FROM sys.objects o WITH (NOWAIT)\n		JOIN sys.schemas s WITH (NOWAIT) ON o.[schema_id] = s.[schema_id]\n		WHERE s.name + '.' + o.name = @tableNameFull\n			AND o.[type] = 'U'\n\n		DECLARE @SQL NVARCHAR(MAX) = '';	\n		DECLARE @SQLTRANSFER NVARCHAR(MAX) = '';	\n		DECLARE @SQLTRANSFERTRIGGER NVARCHAR(MAX) = '';\n		DECLARE @SQLTRANSFERTRIGGERDROP NVARCHAR(MAX) = '';\n\n		WITH index_column AS \n		(\n			SELECT \n				  ic.[object_id]\n				, ic.index_id\n				, ic.is_descending_key\n				, ic.is_included_column\n				, c.name\n			FROM sys.index_columns ic WITH (NOWAIT)\n			JOIN sys.columns c WITH (NOWAIT) ON ic.[object_id] = c.[object_id] AND ic.column_id = c.column_id\n			WHERE ic.[object_id] = @object_id\n		),\n		fk_columns AS \n		(\n			 SELECT \n				  k.constraint_object_id\n				, cname = c.name\n				, rcname = rc.name\n			FROM sys.foreign_key_columns k WITH (NOWAIT)\n			JOIN sys.columns rc WITH (NOWAIT) ON rc.[object_id] = k.referenced_object_id AND rc.column_id = k.referenced_column_id \n			JOIN sys.columns c WITH (NOWAIT) ON c.[object_id] = k.parent_object_id AND c.column_id = k.parent_column_id\n			WHERE k.parent_object_id = @object_id\n		)\n\n		-- Скрипт создания новой таблицы\n		SELECT @SQL = '\n		IF EXISTS (SELECT * FROM SYSOBJECTS s LEFT JOIN sys.objects objs on s.id = objs.object_id\n				   WHERE s.name=''' + CAST(@destinationTableName as nvarchar(max)) + ''' \n						AND xtype=''U'' \n						AND SCHEMA_NAME(objs.schema_id) = ''' + CAST(@destinationSchemaName as nvarchar(max)) + ''')\n		BEGIN\n			DROP TABLE ' + CAST(@destinationObjectFullName as nvarchar(max)) + ';\n		END\n			CREATE TABLE ' + @destinationObjectFullName + CHAR(13) + '(' + CHAR(13) + STUFF((\n			SELECT CHAR(9) + ', [' + c.name + '] ' + \n				CASE WHEN c.is_computed = 1\n					THEN 'AS ' + cc.[definition] \n					ELSE UPPER(tp.name) + \n						CASE WHEN tp.name IN ('varchar', 'char', 'varbinary', 'binary', 'text')\n							   THEN '(' + CASE WHEN c.max_length = -1 THEN 'MAX' ELSE CAST(c.max_length AS VARCHAR(5)) END + ')'\n							 WHEN tp.name IN ('nvarchar', 'nchar', 'ntext')\n							   THEN '(' + CASE WHEN c.max_length = -1 THEN 'MAX' ELSE CAST(c.max_length / 2 AS VARCHAR(5)) END + ')'\n							 WHEN tp.name IN ('datetime2', 'time2', 'datetimeoffset') \n							   THEN '(' + CAST(c.scale AS VARCHAR(5)) + ')'\n							 WHEN tp.name = 'decimal' \n							   THEN '(' + CAST(c.[precision] AS VARCHAR(5)) + ',' + CAST(c.scale AS VARCHAR(5)) + ')'\n							ELSE ''\n						END +\n						CASE WHEN c.collation_name IS NOT NULL THEN ' COLLATE ' + c.collation_name ELSE '' END +\n						CASE WHEN c.is_nullable = 1 THEN ' NULL' ELSE ' NOT NULL' END +\n						CASE WHEN dc.[definition] IS NOT NULL THEN ' DEFAULT' + dc.[definition] ELSE '' END + \n						CASE WHEN ic.is_identity = 1 THEN ' IDENTITY(' + CAST(ISNULL(ic.seed_value, '0') AS CHAR(1)) + ',' + CAST(ISNULL(ic.increment_value, '1') AS CHAR(1)) + ')' ELSE '' END \n				END + CHAR(13)\n			FROM sys.columns c WITH (NOWAIT)\n			JOIN sys.types tp WITH (NOWAIT) ON c.user_type_id = tp.user_type_id\n			LEFT JOIN sys.computed_columns cc WITH (NOWAIT) ON c.[object_id] = cc.[object_id] AND c.column_id = cc.column_id\n			LEFT JOIN sys.default_constraints dc WITH (NOWAIT) ON c.default_object_id != 0 AND c.[object_id] = dc.parent_object_id AND c.column_id = dc.parent_column_id\n			LEFT JOIN sys.identity_columns ic WITH (NOWAIT) ON c.is_identity = 1 AND c.[object_id] = ic.[object_id] AND c.column_id = ic.column_id\n			WHERE c.[object_id] = @object_id\n			ORDER BY c.column_id\n			FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, CHAR(9) + ' ')\n			+ ISNULL((SELECT CHAR(9) + ', CONSTRAINT [' + k.name + '] PRIMARY KEY (' + \n							(SELECT STUFF((\n								 SELECT ', [' + c.name + '] ' + CASE WHEN ic.is_descending_key = 1 THEN 'DESC' ELSE 'ASC' END\n								 FROM sys.index_columns ic WITH (NOWAIT)\n								 JOIN sys.columns c WITH (NOWAIT) ON c.[object_id] = ic.[object_id] AND c.column_id = ic.column_id\n								 WHERE ic.is_included_column = 0\n									 AND ic.[object_id] = k.parent_object_id \n									 AND ic.index_id = k.unique_index_id     \n								 FOR XML PATH(N''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, ''))\n					+ ')' + CHAR(13)\n					FROM sys.key_constraints k WITH (NOWAIT)\n					WHERE k.parent_object_id = @object_id \n						AND k.[type] = 'PK'), '') + ')'  + CHAR(13)\n			+ ISNULL((SELECT (\n				SELECT CHAR(13) +\n					 'ALTER TABLE ' + @object_name + ' WITH' \n					+ CASE WHEN fk.is_not_trusted = 1 \n						THEN ' NOCHECK' \n						ELSE ' CHECK' \n					  END + \n					  ' ADD CONSTRAINT [' + fk.name  + '] FOREIGN KEY(' \n					  + STUFF((\n						SELECT ', [' + k.cname + ']'\n						FROM fk_columns k\n						WHERE k.constraint_object_id = fk.[object_id]\n						FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')\n					   + ')' +\n					  ' REFERENCES [' + SCHEMA_NAME(ro.[schema_id]) + '].[' + ro.name + '] ('\n					  + STUFF((\n						SELECT ', [' + k.rcname + ']'\n						FROM fk_columns k\n						WHERE k.constraint_object_id = fk.[object_id]\n						FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')\n					   + ')'\n					+ CASE \n						WHEN fk.delete_referential_action = 1 THEN ' ON DELETE CASCADE' \n						WHEN fk.delete_referential_action = 2 THEN ' ON DELETE SET NULL'\n						WHEN fk.delete_referential_action = 3 THEN ' ON DELETE SET DEFAULT' \n						ELSE '' \n					  END\n					+ CASE \n						WHEN fk.update_referential_action = 1 THEN ' ON UPDATE CASCADE'\n						WHEN fk.update_referential_action = 2 THEN ' ON UPDATE SET NULL'\n						WHEN fk.update_referential_action = 3 THEN ' ON UPDATE SET DEFAULT'  \n						ELSE '' \n					  END \n					+ CHAR(13) + 'ALTER TABLE ' + @object_name + ' CHECK CONSTRAINT [' + fk.name  + ']' + CHAR(13)\n				FROM sys.foreign_keys fk WITH (NOWAIT)\n				JOIN sys.objects ro WITH (NOWAIT) ON ro.[object_id] = fk.referenced_object_id\n				WHERE fk.parent_object_id = @object_id\n				FOR XML PATH(N''), TYPE).value('.', 'NVARCHAR(MAX)')), '')\n			+ ISNULL(((SELECT\n				 CHAR(13) + 'CREATE' + CASE WHEN i.is_unique = 1 THEN ' UNIQUE' ELSE '' END \n						+ ' NONCLUSTERED INDEX [' + i.name + '] ON ' + @destinationObjectFullName + ' (' +\n						STUFF((\n						SELECT ', [' + c.name + ']' + CASE WHEN c.is_descending_key = 1 THEN ' DESC' ELSE ' ASC' END\n						FROM index_column c\n						WHERE c.is_included_column = 0\n							AND c.index_id = i.index_id\n						FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '') + ')'  \n						+ ISNULL(CHAR(13) + 'INCLUDE (' + \n							STUFF((\n							SELECT ', [' + c.name + ']'\n							FROM index_column c\n							WHERE c.is_included_column = 1\n								AND c.index_id = i.index_id\n							FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '') + ')', '')  + CHAR(13)\n				FROM sys.indexes i WITH (NOWAIT)\n				WHERE i.[object_id] = @object_id\n					--AND i.is_primary_key = 0\n					--AND i.[type] = 2\n				FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)')\n			), '')\n\n		-- Скрипт для переноса накопившихся данных в новую таблицу\n		SELECT\n			@SQLTRANSFER = \n		N'\n		INSERT INTO [' + CAST(@destinationSchemaName as nvarchar(max)) + '].[' + CAST(@destinationTableName as nvarchar(max)) + '] \n		(' + \n		STUFF(\n		(SELECT N',' + c.name\n		FROM\n			sys.columns AS c\n			INNER JOIN sys.types tp ON tp.system_type_id = c.system_type_id AND tp.user_type_id = c.user_type_id\n		WHERE \n			c.OBJECT_ID = OBJECT_ID(@tableNameFull)\n			AND NOT tp.name = 'timestamp'\n		ORDER BY\n			column_id\n		FOR XML PATH(''), TYPE).value('.',N'nvarchar(max)')\n		,1,1,N'')\n		+ N') \n		SELECT \n		' + \n		STUFF(\n		(SELECT N',' + c.name\n		FROM\n			sys.columns AS c\n			INNER JOIN sys.types tp ON tp.system_type_id = c.system_type_id AND tp.user_type_id = c.user_type_id\n		WHERE \n			c.OBJECT_ID = OBJECT_ID(@tableNameFull)\n			AND NOT tp.name = 'timestamp'\n		ORDER BY\n			column_id\n		FOR XML PATH(''), TYPE).value('.',N'nvarchar(max)')\n		,1,1,N'')\n		+ N'\n		FROM [' + CAST(@originalSchemaName as nvarchar(max)) + '].[' + CAST(@tablename as nvarchar(max)) + '];\n\n		';\n\n		-- Скрипт создания триггера для перенаправления потока данных в новую таблицу\n		SELECT\n			@SQLTRANSFERTRIGGER = \n		N'\n	CREATE TRIGGER [' + CAST(@originalSchemaName as nvarchar(max)) + '].[tr_AfterInsert_MoveToTable_' + CAST(@destinationTableName as nvarchar(max)) + ']\n	   ON [' + CAST(@originalSchemaName as nvarchar(max)) + '].[' + CAST(@tablename as nvarchar(max)) + ']\n	   INSTEAD OF INSERT\n	AS \n	BEGIN\n		SET NOCOUNT ON;\n\n		INSERT INTO [' + CAST(@destinationSchemaName as nvarchar(max)) + '].[' + CAST(@destinationTableName as nvarchar(max)) + '] \n		(' + \n		STUFF(\n		(SELECT N',' + c.name\n		FROM\n			sys.columns AS c\n			INNER JOIN sys.types tp ON tp.system_type_id = c.system_type_id AND tp.user_type_id = c.user_type_id\n		WHERE \n			c.OBJECT_ID = OBJECT_ID(@tableNameFull)\n			AND NOT tp.name = 'timestamp'\n		ORDER BY\n			column_id\n		FOR XML PATH(''), TYPE).value('.',N'nvarchar(max)')\n		,1,1,N'')\n		+ N') \n		SELECT \n		' + \n		STUFF(\n		(SELECT N',' + c.name\n		FROM\n			sys.columns AS c\n			INNER JOIN sys.types tp ON tp.system_type_id = c.system_type_id AND tp.user_type_id = c.user_type_id\n		WHERE \n			c.OBJECT_ID = OBJECT_ID(@tableNameFull)\n			AND NOT tp.name = 'timestamp'\n		ORDER BY\n			column_id\n		FOR XML PATH(''), TYPE).value('.',N'nvarchar(max)')\n		,1,1,N'')\n		+ N'\n		FROM INSERTED;\n	END\n		';\n\n		-- Скрипт удаления триггера, если он существует перед созданием\n		SELECT\n			@SQLTRANSFERTRIGGERDROP = '\n	IF EXISTS (SELECT * FROM sys.objects \n				WHERE [name] = ''tr_AfterInsert_MoveToTable_' + CAST(@destinationTableName as nvarchar(max)) + '''\n				AND [type] = ''TR''\n				AND SCHEMA_NAME(schema_id) = ''' + CAST(@originalSchemaName as nvarchar(max)) + ''')\n	BEGIN\n		  DROP TRIGGER [' + CAST(@originalSchemaName as nvarchar(max)) + '].[tr_AfterInsert_MoveToTable_' + CAST(@destinationTableName as nvarchar(max)) + '];\n	END;\n	';\n\n		-- Выполняем команды создания собственного объекта\n		EXECUTE sp_executesql @SQL\n\n		-- Создаем триггер для перенаправления изменений в собственную таблицу\n		EXECUTE sp_executesql @SQLTRANSFERTRIGGERDROP\n		EXECUTE sp_executesql @SQLTRANSFERTRIGGER\n\n		-- Затем переносим данные из исходной таблицы в созданную\n		EXECUTE sp_executesql @SQLTRANSFER\n\n		FETCH NEXT FROM tables_cursor INTO @tableName;\n	END\n	CLOSE tables_cursor;  \n	DEALLOCATE tables_cursor;\nEND\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"Процедура задокументирована в листинге. Основные шаги такие:"}),(0,s.jsxs)(t.aV,{type:i.RH.number,children:[(0,s.jsx)("li",{children:"Создается собственная таблица для хранения изменений."}),(0,s.jsx)("li",{children:"На штатную таблицу CDC создается триггер для перенаправления операций INSERT в нашу собственную, переопределенную таблицу."}),(0,s.jsx)("li",{children:"Из штатной таблицы переносятся накопившиеся изменения в переопределенную таблицу."})]}),(0,s.jsx)(t.xv,{p:!0,children:"То есть на этом этапе у нас уже есть настройки и механизм переопределения потока данных об изменениях CDC. Осталось это как-то применить."}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Применяем настройки"}),(0,s.jsx)(t.xv,{p:!0,children:"Сначала нужно определиться в какие моменты настройки CDC мы можем применять, а в какие нет. Реализуем самое простое условие - если идет обновление конфигурации информационной базы, то обновлять настройки CDC мы не должны. Почему? Потому что не хотелось бы во время рестурктуризации и “перезаливке” данных из старой таблицы в новую все эти данные в CDC зарегистрировать. Зачем?"}),(0,s.jsx)(t.xv,{p:!0,children:"Для проверки доступности обновления настроек сделаем процедуру."}),(0,s.jsx)(c.Z,{code:"\n-- Процедура позволяет определить доступность применения настроек CDC в данный момент\nCREATE PROCEDURE [yy].[ApplySettingsCDCAvailable]\n	@availableResult int OUTPUT\nAS\nBEGIN\n	SET NOCOUNT ON;\n	-- Если в таблице сохраненной конфигуарции есть хоть одна запись,\n	-- то считаем, что идет обновление и никаких настроек CDC применять не нужно\n	SELECT\n		@availableResult = CASE WHEN COUNT(1) > 0 THEN 0 ELSE 1 END\n	FROM [dbo].[ConfigSave]\nEND\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"Теперь при начале обновления информационной базы мы будем уверены, что CDC не будет включен для таблицы, пока реструктуризация перезаливает данные из старой версии таблицы."}),(0,s.jsx)(t.xv,{p:!0,children:"Сама процедура применения настроек CDC будет выглядеть так."}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Применение настроек CDC"}),(0,s.jsx)(c.Z,{code:"\n-- Применение настроек CDC по настройкам из таблицы MaintenanceSettingsCDC\nCREATE PROCEDURE [yy].[ApplySettingsCDC]\nAS\nBEGIN\n	SET NOCOUNT ON;\n\n	DECLARE\n		@settingId int,\n		@schemaName nvarchar(255),\n		@tableName nvarchar(255),\n		@useCDC bit,\n		@schemaNameCDC nvarchar(255),\n		@tableNameCDC nvarchar(255),\n		@tableNameCDCHistory nvarchar(255),\n		@captureInstanceCDC nvarchar(255),\n		@tableObjectId int,\n		@tableSchemaLastChangeDate datetime2(0),\n		@availableResult int;\n\n	-- Проверяем, доступно ли применение настроек CDC в данный момент\n	EXECUTE [yy].[ApplySettingsCDCAvailable] \n		@availableResult OUTPUT\n	IF(@availableResult = 0)\n	BEGIN\n		RETURN 0;\n	END\n\n	-- Получаем все активные настройки\n	DECLARE settingsCursor CURSOR  \n	FOR SELECT \n		   [ID]\n		  ,[SchemaName]\n		  ,[TableName]\n		  ,[UseCDC]\n		  ,[SchemaNameCDC]\n		  ,[TableNameCDC]\n		  ,[TableNameCDCHistory]\n		  ,[CaptureInstanceCDC]\n		  ,[TableObjectId]\n		  ,[TableSchemaLastChangeDate]\n	FROM [yy].[MaintenanceSettingsCDC]\n	WHERE [UseCDC] = 1;\n	OPEN settingsCursor;\n\n	FETCH NEXT FROM settingsCursor \n	INTO @settingId, @schemaName, @tableName, @useCDC, \n		@schemaNameCDC, @tableNameCDC, @tableNameCDCHistory, \n		@captureInstanceCDC, @tableObjectId, @tableSchemaLastChangeDate;\n\n	WHILE @@FETCH_STATUS = 0  \n	BEGIN\n		-- Проверяем, доступно ли применение настроек CDC в данный момент\n		EXECUTE [yy].[ApplySettingsCDCAvailable] \n			@availableResult OUTPUT\n		IF(@availableResult = 0)\n		BEGIN\n			RETURN 0;\n		END\n\n		-- Получаем текущие данные о таблице:\n		--	* Используется для нее CDC\n		--	* Идентификатор объекта\n		--	* Дата последнего изменения объекта\n		DECLARE \n			@currentCDCEnabled bit = 0,\n			@currentTableObjectId int,\n			@currentTableSchemaLastChangeDate datetime2(0);\n		SELECT \n			@currentCDCEnabled = tb.is_tracked_by_cdc,\n			@currentTableObjectId = tb.object_id,\n			@currentTableSchemaLastChangeDate = 			\n				CASE WHEN create_date > modify_date THEN create_date\n					ELSE modify_date\n				END\n		FROM sys.tables tb\n			INNER JOIN sys.schemas s \n			on s.schema_id = tb.schema_id\n		WHERE s.name = @schemaName AND tb.name = @tableName\n		\n		-- Вариант действий если CDC для объекта уже включен\n		IF(@currentCDCEnabled = 1)\n		BEGIN\n			PRINT 'Для таблицы уже используется CDC: ' + @tableName\n\n			-- Есть изменения в структуре таблицы или объект был пересоздан,\n			-- то нужно пересоздать объекты CDC\n			IF(-- Структура таблицы изменилась\n			   (NOT ISNULL(@tableSchemaLastChangeDate, CAST('2000-01-01 00:00:00' AS datetime2(0))) = @currentTableSchemaLastChangeDate)\n			   OR \n			   -- Идентификатор базы данных изменился\n			   (NOT ISNULL(@tableObjectId,0) = @currentTableObjectId))\n			BEGIN\n				PRINT 'Зафиксировано изменение таблицы. Пересоздаем настройки CDC: ' + @tableName\n\n				-- Отключение CDC для таблицы\n				EXEC [sys].[sp_cdc_disable_table]\n					@source_schema = @schemaName\n					,@source_name = @tableName\n					,@capture_instance = @captureInstanceCDC\n\n				-- Включаем CDC заново\n				EXEC sys.sp_cdc_enable_table\n					-- Схема исходной таблицы\n					@source_schema = @schemaName,\n					-- Имя исходной таблицы\n					@source_name   = @tableName,\n					-- Имя роли для доступа к данным изменений оставляем по умолчанию\n					@role_name     = NULL,\n					-- Поддержку запросов для суммарных изменений не используем,\n					-- чтобы снизить размеры таблиц CDC и иметь возможность его использования,\n					-- даже если у таблицы нет уникального ключа\n					@supports_net_changes = 0;\n					-- Остальные параметры не используются, т.к. не нужны явно\n					-- Имя уникального индекса для идентификации строк (не обязателен)\n					--@index_name    = N'<index_name,sysname,index_name>',\n					-- Файловая группа для хранения таблиц изменений (не обязателен)\n					--@filegroup_name = N'<filegroup_name,sysname,filegroup_name>'\n\n				-- Обновляем служебные поля настроек CDC\n				EXECUTE [yy].[UpdateServiceMaintenanceSettingsCDC] \n					@settingId,\n					@schemaNameCDC OUTPUT,\n					@tableNameCDC OUTPUT,\n					@tableNameCDCHistory OUTPUT,\n					@captureInstanceCDC OUTPUT;\n\n				-- Переопределяем поток изменений из стандартной таблицы CDC в собственную\n				EXECUTE [yy].[OverrideDataFlowForCDC] \n					@settingId\n\n				PRINT 'Для таблицы включен CDC: ' + @tableName\n			END\n		END ELSE -- Вариант действий, если CDC для объекта еще не был включен\n		BEGIN\n			-- Включаем CDC для таблицы, т.к. ранее он не был включен\n			EXEC sys.sp_cdc_enable_table\n				-- Схема исходной таблицы\n				@source_schema = @schemaName,\n				-- Имя исходной таблицы\n				@source_name   = @tableName,\n				-- Имя роли для доступа к данным изменений оставляем по умолчанию\n				@role_name     = NULL,\n				-- Поддержку запросов для суммарных изменений не используем,\n				-- чтобы снизить размеры таблиц CDC и иметь возможность его использования,\n				-- даже если у таблицы нет уникального ключа\n				@supports_net_changes = 0;\n				-- Остальные параметры не используются, т.к. не нужны явно\n				-- Имя уникального индекса для идентификации строк (не обязателен)\n				--@index_name    = N'<index_name,sysname,index_name>',\n				-- Файловая группа для хранения таблиц изменений (не обязателен)\n				--@filegroup_name = N'<filegroup_name,sysname,filegroup_name>'\n\n			-- Обновляем служебные поля настроек CDC\n			EXECUTE [yy].[UpdateServiceMaintenanceSettingsCDC] \n				@settingId,\n				@schemaNameCDC OUTPUT,\n				@tableNameCDC OUTPUT,\n				@tableNameCDCHistory OUTPUT,\n				@captureInstanceCDC OUTPUT;\n\n			-- Переопределяем поток изменений из стандартной таблицы CDC в собственную\n			EXECUTE [yy].[OverrideDataFlowForCDC] \n				@settingId\n\n			PRINT 'Для таблицы включен CDC: ' + @tableName\n		END\n\n		FETCH NEXT FROM settingsCursor \n		INTO @settingId, @schemaName, @tableName, @useCDC, \n			@schemaNameCDC, @tableNameCDC, @tableNameCDCHistory, \n			@captureInstanceCDC, @tableObjectId, @tableSchemaLastChangeDate;\n	END\n	CLOSE settingsCursor;  \n	DEALLOCATE settingsCursor;\n\n	-- Обрабатываем настройки, для которых настройка CDC выключена или отсутствует (при этом CDC включен для объекта).\n	-- CDC для них должен быть выключен\n	DECLARE\n		@deleteSchamaName nvarchar(255),\n		@deleteTableName nvarchar(255),\n		@deleteCaptureInstance nvarchar(255);\n\n	-- Список объектов, для которых CDC включен, но при этом\n	-- настройки в таблице MaintenanceSettingsCDC нет\n	DECLARE disableCDCObjectsCursor CURSOR  \n	FOR\n	SELECT\n		  SCHEMA_NAME(o.schema_id) AS [SchemaName]\n		  ,OBJECT_NAME(ct.[source_object_id]) AS [TableName]\n		  ,[capture_instance]\n	FROM [cdc].[change_tables] ct\n		LEFT JOIN sys.objects o\n			ON ct.source_object_id = o.object_id\n		LEFT JOIN [yy].MaintenanceSettingsCDC st\n			ON SCHEMA_NAME(o.schema_id) = st.SchemaName\n				AND OBJECT_NAME(ct.[source_object_id]) = st.TableName\n				AND st.UseCDC = 1\n	WHERE st.ID IS NULL\n	OPEN disableCDCObjectsCursor;\n\n	FETCH NEXT FROM disableCDCObjectsCursor \n	INTO @deleteSchamaName, @deleteTableName, @deleteCaptureInstance;\n\n	WHILE @@FETCH_STATUS = 0  \n	BEGIN\n		-- Проверяем, доступно ли применение настроек CDC в данный момент\n		-- Этот момент описан ниже\n		EXECUTE [yy].[ApplySettingsCDCAvailable] \n			@availableResult OUTPUT\n		IF(@availableResult = 0)\n		BEGIN\n			RETURN 0;\n		END\n\n		PRINT 'Отключение CDC для таблицы, т.к. настройка уже не актуальна: ' + @deleteTableName\n\n		-- Отключение CDC для таблицы\n		EXEC [sys].[sp_cdc_disable_table]\n			@source_schema = @deleteSchamaName\n			,@source_name = @deleteTableName\n			,@capture_instance = @deleteCaptureInstance\n\n		FETCH NEXT FROM disableCDCObjectsCursor \n		INTO @deleteSchamaName, @deleteTableName, @deleteCaptureInstance;\n	END\n\n	CLOSE disableCDCObjectsCursor;  \n	DEALLOCATE disableCDCObjectsCursor;\nEND\n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"Общий алгоритм такой:"}),(0,s.jsxs)(t.aV,{type:i.RH.number,children:[(0,s.jsx)("li",{children:"Получаем настройки CDC из таблицы MaintenanceSettingsCDC и обходим каждую."}),(0,s.jsx)("li",{children:"Проверяем включен ли CDC для объекта."}),(0,s.jsxs)("li",{children:["Если включен, то:",(0,s.jsxs)(t.aV,{type:i.RH.number,children:[(0,s.jsx)("li",{children:"Проверяем изменилась ли схема объекта или объект был полностью пересоздан"}),(0,s.jsx)("li",{children:"Включаем CDC"}),(0,s.jsx)("li",{children:"Обновляем служебные настройки"}),(0,s.jsx)("li",{children:"Переопределяем поток данных"})]})]}),(0,s.jsxs)("li",{children:["Если выключен, то просто включаем:",(0,s.jsxs)(t.aV,{type:i.RH.number,children:[(0,s.jsx)("li",{children:"Включаем CDC"}),(0,s.jsx)("li",{children:"Обновляем служебные настройки"}),(0,s.jsx)("li",{children:"Переопределяем поток данных"})]})]}),(0,s.jsx)("li",{children:"Отключаем настройку CDC у объектов, для которых нет активной записи в таблице MaintenanceSettingsCDC."})]}),(0,s.jsx)(t.xv,{p:!0,children:"Для применения настроек достаточно вызвать:"}),(0,s.jsx)(c.Z,{code:"\nEXECUTE [yy].[ApplySettingsCDC] \n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"И дело сделано!"}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Сопровождать и остаться в живых"}),(0,s.jsx)(t.xv,{p:!0,children:"Инфраструктура готова, но не запускать же это каждый раз вручную? Правильно!"}),(0,s.jsx)(t.xv,{p:!0,children:"Проще всего создать задание (Job) и запускать актуализацию настроек CDC раз в 15 секунд, например. Это решит большинство кейсов в части включения CDC во время изменения структуры базы данных после обновления."}),(0,s.jsx)(t.xv,{p:!0,children:"Скрипт создания задания смысла приводить нет. Главное сделайте расписание раз в 15 секунд и вызывайте процедуру:"}),(0,s.jsx)(c.Z,{code:"\nEXECUTE [yy].[ApplySettingsCDC] \n                ",className:"my-5",language:"sql"}),(0,s.jsx)(t.xv,{p:!0,children:"Вот и все сопровождение. Или не все?"}),(0,s.jsx)(t.xv,{p:!0,children:"Для мониторинга работы CDC можно использовать стандартный журнал логов SQL Server и историю работы заданий в SQL Server Agent. В остальном ничего особого не нужно."}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Используем в своих целях"}),(0,s.jsx)(t.xv,{p:!0,children:"Мы все настроили, все работает. Но что это нам дает и как это использовать?"}),(0,s.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Шаг за шагом"}),(0,s.jsx)(t.xv,{p:!0,children:"Проведем небольшой тест. Например, у нас есть документ “Реализация товаров” из демобазы БСП. На стороне базы данных он представлен таблицами:"}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/6. Объекты 1С.png",alt:"Объекты 1С",size:i.h2.MEDIUM}),(0,s.jsx)(t.xv,{p:!0,children:"Включим для этих таблиц CDC через настройки."}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/7. Настройки CDC.png",alt:"Настройки CDC",size:i.h2.MEDIUM}),(0,s.jsx)(t.xv,{p:!0,children:"Как видно, заполнили только 3 поля. Как только задание применения настроек CDC отработает, то картина изменится на следующую."}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/8. Настройки CDC.png",alt:"Настройки CDC",size:i.h2.MEDIUM}),(0,s.jsx)(t.xv,{p:!0,children:"При этом в схеме “yy” добавлены переопределенные таблицы."}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/10. Переопределенные таблицы CDC.png",alt:"Переопределенные таблицы CDC",size:i.h2.SMALL}),(0,s.jsx)(t.xv,{p:!0,children:"Теперь зайдем на сторону клиента 1С и добавим новый документ через копирование, а после сразу же внесем в него небольшое изменение."}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/12. Пример работы в 1С.gif",alt:"Пример работы в 1С",size:i.h2.SMALL}),(0,s.jsx)(t.xv,{p:!0,children:"Как Вы думаете, сколько транзакций базы данных мы увидим? Ответ простой: 3:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsxs)("li",{children:["Первая транзакция (идентификатор 0x000000AF0000AAA80008) - это добавление новых записей в таблицы. Документ в этот момент был записан без проведения. Данные в документе были только в шапке и в таб. части “Товары”, поэтому таблица для счетов на оплату пустая. Вот такие записи в таблице логов изменений.",(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/13. Изменения - 1.png",alt:"Изменения",size:i.h2.MEDIUM}),(0,s.jsx)(t.xv,{p:!0,children:"Изменения в первой транзакции. Сверху таблица шапки, снизу таб. часть товаров."})]}),(0,s.jsxs)("li",{children:["Вторая транзакция (идентификатор 0x000000AF0000AB38000A) - это проведение документа. Фактически было изменено только поле “Проведен” (_Posted).",(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/14. Изменения - 2.png",alt:"Изменения",size:i.h2.MEDIUM})]}),(0,s.jsxs)("li",{children:["Третья транзакция (идентификатор 0x000000AF0000AD500074) - обновление поля “Комментарий”. В таблице изменений представлена также двумя записями UPDATE и с единственным измененным полем.",(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/15. Изменения - 3.png",alt:"Изменения",size:i.h2.MEDIUM}),(0,s.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2022-06/change-data-capture-by-sqlserver-for-1C/16. Изменения - 4.png",alt:"Изменения",size:i.h2.MEDIUM})]})]}),(0,s.jsx)(t.xv,{p:!0,children:"Таким образом, мы имеем детальную информацию об изменениях документа на каждом шаге, по каждому полю."}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Кратко: где используется"}),(0,s.jsx)(t.xv,{p:!0,children:"В самом начале статьи мы уже говорили, где это может пригодиться. После наглядного примера регистрации изменений должно было стать понятней:"}),(0,s.jsxs)(t.aV,{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Версионирование"})," - у нас хранятся версии всех изменений в базе и при этом в разрезе транзакций. Если одна транзакция изменяет множество документов или других объектов, то связь между этими изменениями не трудно найти."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Аудит"})," - информация об изменениях у нас есть, но кто их изменил. Т.к. история изменений сохраняется на уровне базы данных, то у нас нет контекста приложения. То есть нет пользователя приложения. Тут есть два варианта:",(0,s.jsxs)(t.aV,{children:[(0,s.jsx)("li",{children:"По времени изменения легко найти записи о действиях пользователя в журнале регистрации."}),(0,s.jsx)("li",{children:"Или можно в объектах 1С сохранять поля “Создал”, “Дату создания”, “Изменил” и “Дату изменения”, где у нас будет дата события и ссылка на пользователя. Тогда контекст приложения будет доступен и на стороне базы данных."}),(0,s.jsx)("li",{children:"Или другие подобные варианты."})]})]}),(0,s.jsx)("li",{children:"Отправка изменений при интеграции. Если в базе у нас есть таблицы с историей изменений, то можно эту информацию использовать для отправки измененных объектов в другие системы. Сценариев много, один из низ - это присоединить Kafka, которая будет забирать себе данные об изменениях и отправлять подписчикам. Надежный и понятный способ интеграции. Но это только один небольшой пример."})]}),(0,s.jsx)(t.xv,{p:!0,children:"Статья - слишком маленький формат, чтобы сразу здесь описать как присоединять Kafka или как удобно из 1С читать таблицы изменений CDC. Но основной посыл должен быть ясен."}),(0,s.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Зачем, если можно не использовать"}),(0,s.jsxs)(t.xv,{p:!0,children:["Незачем! Если Вы не видите плюсов в применении механизма регистрации данных, то скорее всего вам это и не нужно. Аналогичный подход можно использовать и для баз PostgreSQL, но со своими нюансами.",(0,s.jsx)("u",{children:(0,s.jsx)("b",{children:(0,s.jsx)(t.e9,{newTab:!0,href:"https://datacater.io/blog/2021-09-02/postgresql-cdc-complete-guide.html",children:"По этому поводу можно прочитать интересную статью."})})})]}),(0,s.jsx)(t.xv,{p:!0,children:"Если же штатные инструменты регистрации и обмена Вас не устраивают, а построить DWH в связке с 1С - для Вас большая боль, то CDC может стать отличным стартом. Далее можно развивать использование этого механизма, добавить новые инструменты очередей и аналитики и вот появится новый уровень развития информационных систем."}),(0,s.jsx)(t.xv,{p:!0,children:"P.S. Спасибо, что дочитали! Всем добра!"})]})},850:function(e,n,a){"use strict";a.d(n,{Z:function(){return E}});var s=a(5893),t=a(7294),c=a(4965),i=a(4275),l=a(7340);function r(){let e=(0,l._)(["\n  text-align: left;\n  overflow: hidden;\n  font-size: 14px;\n  border-radius: 6px;\n  overflow: auto;\n  max-height: 350px;\n\n  & .token-line {\n    line-height: 1.3em;\n    height: 1.3em;\n  }\n"]);return r=function(){return e},e}let C=a(964).ZP.pre(r());var E=e=>{let{code:n,className:l,language:r}=e;return(void 0!==a.g?a.g:window).Prism=c.p1,a(1354),a(9016),a(5266),a(2927),a(1315),a(7874),a(6862),(0,s.jsx)("div",{className:(0,i.GF)("bg-blue-500 md:p-5 p-2",l),children:(0,s.jsx)("div",{className:"shadow-lg",children:(0,s.jsx)(c.y$,{theme:c.np.vsDark,code:n,language:null!=r?r:r="tsx",children:e=>{let{className:n,style:a,tokens:c,getLineProps:i,getTokenProps:l}=e;return(0,s.jsx)(C,{className:n,style:a,children:c.map((e,n)=>(0,t.createElement)("div",{...i({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,t.createElement)("span",{...l({token:e,key:n}),key:Math.random()}))))})}})})})}},9305:function(e,n,a){"use strict";a.d(n,{Ee:function(){return l},Xg:function(){return c},aV:function(){return C},e9:function(){return E},o_:function(){return d},ty:function(){return r},xv:function(){return i}});var s=a(5152),t=a.n(s);let c=t()(()=>Promise.all([a.e(4838),a.e(4738),a.e(1664),a.e(7167)]).then(a.bind(a,7167)),{loadableGenerated:{webpack:()=>[7167]}}),i=t()(()=>a.e(9179).then(a.bind(a,9179)),{loadableGenerated:{webpack:()=>[9179]}}),l=t()(()=>a.e(1974).then(a.bind(a,1974)),{loadableGenerated:{webpack:()=>[1974]}}),r=t()(()=>a.e(8547).then(a.bind(a,8547)),{loadableGenerated:{webpack:()=>[8547]}}),C=t()(()=>a.e(6806).then(a.bind(a,6806)),{loadableGenerated:{webpack:()=>[6806]}}),E=t()(()=>Promise.all([a.e(1664),a.e(1465)]).then(a.bind(a,1465)),{loadableGenerated:{webpack:()=>[1465]}});t()(()=>a.e(567).then(a.bind(a,567)),{loadableGenerated:{webpack:()=>[567]}}),t()(()=>Promise.all([a.e(2004),a.e(4139)]).then(a.bind(a,4139)),{loadableGenerated:{webpack:()=>[4139]}});let d=t()(()=>Promise.all([a.e(3811),a.e(7472),a.e(584),a.e(7870)]).then(a.bind(a,7870)),{loadableGenerated:{webpack:()=>[7870]}})}},function(e){e.O(0,[1102,2888,9774,179],function(){return e(e.s=3914)}),_N_E=e.O()}]);