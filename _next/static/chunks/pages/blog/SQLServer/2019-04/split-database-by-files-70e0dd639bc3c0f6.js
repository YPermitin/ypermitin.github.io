(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6386],{7609:function(n,e,l){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/SQLServer/2019-04/split-database-by-files",function(){return l(9669)}])},9669:function(n,e,l){"use strict";l.r(e);var N=l(5893),s=l(9305);l(7294);var d=l(1639),i=l(8754),_=l(5632),E=l(3906),a=l(6789),c=l(1652),r=l(850),x=l(7105);e.default=()=>(0,N.jsxs)(s.Xg,{blogcentered:!0,children:[(0,N.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Суть вопроса"}),(0,N.jsxs)(s.xv,{p:!0,children:["В прошлых статьях мы уже говорили о подходах к разработке и обслуживанию базы данных, которые позволяют ",(0,N.jsx)("b",{children:(0,N.jsx)("u",{children:(0,N.jsx)(s.e9,{newTab:!0,href:"/pages/blog/DevOps/2018-11/custom-index-for-1C.tsx",children:"использовать индексы произвольной структуры"})})})," и ",(0,N.jsx)("b",{children:(0,N.jsx)("u",{children:(0,N.jsx)(s.e9,{newTab:!0,href:"/pages/blog/DevOps/2019-02/partitioning-1c-world.tsx",children:"даже секционирование для баз 1С"})})}),". Казалось бы, тема исчерпана и для высоконагруженных баз может наступить светлое будущее, не смотря на то, что платформа 1С пока так и не поддерживает эти возможности из “коробки”."]}),(0,N.jsx)(s.xv,{p:!0,children:"Однако, хотелось бы остановиться подробнее на такой теме как разбиение базы данных на отдельные файлы с помощью файловых групп. В статье про секционирование файловые группы уже использовались для секций, но там про них был сказано вскользь."}),(0,N.jsx)(s.xv,{p:!0,children:"Сегодня мы более детально рассмотрим их использование, а также нюансы, с которыми нужно считаться при обслуживании базы данных, реструктуризациях и других моментах."}),(0,N.jsx)(s.xv,{p:!0,children:"Для чего вообще может понадобиться разбивать базу данных на отдельные файлы? Самые распространенные кейсы:"}),(0,N.jsxs)(s.aV,{type:x.RH.number,children:[(0,N.jsx)("li",{children:"Есть регистр сведений, в котором хранятся двоичные данные файлов. Необходимо вынести хранение файлов на отдельный диск / хранилище, чтобы освободить место на быстрых дисках."}),(0,N.jsx)("li",{children:"Есть старые архивные таблицы, которые уже редко используются, но удалять данные нельзя. Почему бы такие таблицы также не перенести на отдельные диски, которые для этого и предназначены. Тем более такие файловые группы можно сделать только для чтения."}),(0,N.jsx)("li",{children:"Ускорить бэкапирование базы, т.к. архивные файловые группы можно не бэкапировать каждый раз. Они ведь не меняются!"}),(0,N.jsx)("li",{children:"Улучшение производительности, за счет распределения файлов базы данных на отдельные носители."})]}),(0,N.jsx)(s.xv,{p:!0,children:"Тему ускорения бэкапирования и производительности сейчас мы рассматривать не будем, но Вы можете прочитать об этом в публикации про секционирование. Сосредоточимся на описании настроек для файловых групп и их сопровождении. Все примеры ниже будут сделаны для SQL Server, но и для PostgreSQL это будет работать с некоторыми модификациями."}),(0,N.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Стандартный подход"}),(0,N.jsx)(s.xv,{p:!0,children:"Любая база, будь то для 1С или любого другого приложения, поддерживает разбиение базы на несколько файлов (конечно, если это поддерживает СУБД). В контексте SQL Server это реализуется с помощью файловых групп."}),(0,N.jsx)(s.xv,{p:!0,children:"По умолчанию база содержит лишь одну файловую группу “PRIMARY”, которую 1С и использует для своих целей. Кроме таблиц и индексов в этой предопределенной группе хранится служебная информация о базе, различные заголовки и др., поэтому полностью заменить эту группу на другую нельзя, она всегда будет присутствовать."}),(0,N.jsx)(s.xv,{p:!0,children:"Однако, мы можем добавить собственные файловые группы и использовать их для 1С\\’ных таблиц, причем сама платформа об этом не узнает."}),(0,N.jsx)(s.xv,{p:!0,children:"Возьмем для примеров демобазу БСП и создадим в ней две новых файловых группы."}),(0,N.jsx)(r.Z,{code:'\n-- В примере имя базы данных на сервере СУБД имеет название "bsl"\nUSE [master]\nGO\nALTER DATABASE [bsl] ADD FILEGROUP [FILEGROUP_2]\nGO\nALTER DATABASE [bsl] ADD FILEGROUP [FILEGROUP_3]\nGO\n                ',className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"Но просто добавить файловые группы недостаточно. Еще нужно добавить файлы данных, для которых эти файловые группы будут задействованы."}),(0,N.jsx)(r.Z,{code:"\n-- Оставляем стандартные параметры инициализации файлов, для нашего примера это не критично.\n-- Все файлы базы данных находятся в каталоге \"D:\\DBs\"\n\n-- Добавляем файлы для файловых групп\nALTER DATABASE [bsl] \n    ADD FILE ( NAME = N'bsl_fg_2', FILENAME = N'D:\\DBs\\bsl_fg_2.mdf' , SIZE = 8192KB , FILEGROWTH = 65536KB ) \n    TO FILEGROUP [FILEGROUP_2]\nGO\nALTER DATABASE [bsl] \n    ADD FILE ( NAME = N'bsl_fg_3', FILENAME = N'D:\\DBs\\bsl_fg_3.mdf' , SIZE = 8192KB , FILEGROWTH = 65536KB ) \n    TO FILEGROUP [FILEGROUP_3]\nGO\n                ",className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"Отлично, у нас есть две файловые группы “FILEGROUP_2” и “FILEGROUP_3”, осталось их задействовать. Есть несколько основных вариантов:"}),(0,N.jsxs)(s.aV,{type:x.RH.number,children:[(0,N.jsx)("li",{children:"Мы можем вручную изменить основную файловую группу базы и сделать реструктуризацию средствами 1С."}),(0,N.jsx)("li",{children:"Мы можем пересоздать кластерный или другие индексы средствами T-SQL, указав для использования нужную файловую группу."}),(0,N.jsx)("li",{children:"Ничего не делать."})]}),(0,N.jsx)(s.xv,{p:!0,children:"По третьему варианту написано довольно много примеров в сети, поэтому рассмотрим только первые два пункта. Все примеры будем делать на регистре сведений “История адресных объектов”, который на стороне базы представлен таблицей “_InfoRg4683” с несколькими индексами."}),(0,N.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Вперед через реструктуризацию"}),(0,N.jsx)(s.xv,{p:!0,children:"И так, для начала установим основную файловой группой - одну из тех, что добавили выше."}),(0,N.jsx)(s.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-04/split-database-by-files/1. Файловые группы.png",alt:"Файловые группы",size:x.h2.MEDIUM}),(0,N.jsx)(s.xv,{p:!0,children:"То же самое можно сделать через T-SQL. Кому как больше нравится."}),(0,N.jsx)(r.Z,{code:"\nUSE [bsl]\nGO\nIF NOT EXISTS (SELECT name FROM sys.filegroups WHERE is_default=1 AND name = N'FILEGROUP_2') \n	ALTER DATABASE [bsl] MODIFY FILEGROUP [FILEGROUP_2] DEFAULT\nGO\n                ",className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"Теперь нужно сделать реструктуризацию средствами платформы. Нормального способа вызвать ее для нашего случая нет, но мы можем:"}),(0,N.jsxs)(s.aV,{type:x.RH.number,children:[(0,N.jsx)("li",{children:"Добавить временно реквизит в таблицу, а потом запустить реструктуризацию."}),(0,N.jsx)("li",{children:"Полностью реструктуризировать базу через “Тестирование и исправление”."})]}),(0,N.jsx)(s.xv,{p:!0,children:"Оба варианта выглядят “не очень”, и Вам повезет, если необходимость реструктуризации появится как-раз в этот момент для других задач. При использовании инструмента “Тестирование и исправление” Вы вообще переведете все таблицы и индексы в установленную файловую группу, поэтому этот случай мы вообще рассматривать не будем. А вот пример с добавлением временного реквизита - пожалуйста."}),(0,N.jsx)(s.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-04/split-database-by-files/2. Реструктуризация.png",alt:"Реструктуризация",size:x.h2.MEDIUM}),(0,N.jsx)(s.xv,{p:!0,children:"С помощью этих скриптов можно узнать как изменилась структура базы в части использования файловых групп. Вот какие изменения мы получили."}),(0,N.jsxs)(d.b,{"aria-label":"Файлы базы",children:[(0,N.jsxs)(i.J,{children:[(0,N.jsx)(_.j,{children:"Таблица"},"Table"),(0,N.jsx)(_.j,{children:"Индекс"},"Index"),(0,N.jsx)(_.j,{children:"Файловая группа"},"FileGroup"),(0,N.jsx)(_.j,{children:"Файл"},"File")]}),(0,N.jsxs)(E.y,{children:[(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByDims_NNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_2"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_2.mdf"})]},"1"),(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByResource4705_SNNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_2"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_2.mdf"})]},"2"),(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByDims_NNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_2"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_2.mdf"})]},"3"),(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByDims_NNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_2"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_2.mdf"})]},"4")]})]}),(0,N.jsx)(s.xv,{p:!0,children:"Таким образом, мы перевели таблицу регистра сведений “История адресных объектов” и все ее индексы в файловую группу “FILEGROUP_2”."}),(0,N.jsx)(s.xv,{p:!0,children:"Подведем итог по данному способу."}),(0,N.jsx)(s.xv,{p:!0,children:"Плюсы:"}),(0,N.jsx)(s.aV,{children:(0,N.jsx)("li",{children:"Простота в настройке"})}),(0,N.jsx)(s.xv,{p:!0,children:"Минусы:"}),(0,N.jsxs)(s.aV,{children:[(0,N.jsx)("li",{children:"Нужен вызов платформенной реструктуризации, что не всегда оптимально. После реструктуризации надо обратно настраивать основную файловую группу."}),(0,N.jsx)("li",{children:"Необходимость проводить реструктуризацию таблиц в разных файловых группах отдельно друг от друга, что не всегда возможно."})]}),(0,N.jsx)(s.xv,{p:!0,children:"Вообщем, способ неэффективный, но требует минимальных действий на стороне СУБД."}),(0,N.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Скриптуем"}),(0,N.jsx)(s.xv,{p:!0,children:"Более эффективный и гибкий подход - это перенос таблиц и индексов в другую файловую группу с помощью скриптов. Вот так будет выглядеть скрипт для переноса всех индексов регистра сведений “История адресных объектов” в третью файловую группу."}),(0,N.jsx)(s.xv,{p:!0,children:"Фактически, нам нужно пересоздать индексы с указанием новой файловой группы. При этом, когда мы пересоздаем кластерный индекс таблицы, то все данные в ней переносятся в новую файловую группу."}),(0,N.jsx)(r.Z,{code:"\nUSE [bsl]\nGO\n\nCREATE UNIQUE CLUSTERED INDEX [_InfoRg4683_ByDims_NNNNNNNNNNBN] ON [dbo].[_InfoRg4683]\n(\n	[_Fld4684] ASC,\n	[_Fld4685] ASC,\n	[_Fld4686] ASC,\n	[_Fld4687] ASC,\n	[_Fld4688] ASC,\n	[_Fld4689] ASC,\n	[_Fld4690] ASC,\n	[_Fld4691] ASC,\n	[_Fld4692] ASC,\n	[_Fld4693] ASC,\n	[_Fld4694] ASC,\n	[_Fld4695] ASC\n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = ON, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) \nON [FILEGROUP_3] -- Задаем имя новой файловой группы\nGO\n\nCREATE NONCLUSTERED INDEX [_InfoRg4683_ByMainFilter_NNNNNNNNNNNB] ON [dbo].[_InfoRg4683]\n(\n	[_Fld4684] ASC,\n	[_Fld4685] ASC,\n	[_Fld4686] ASC,\n	[_Fld4687] ASC,\n	[_Fld4688] ASC,\n	[_Fld4689] ASC,\n	[_Fld4690] ASC,\n	[_Fld4691] ASC,\n	[_Fld4692] ASC,\n	[_Fld4693] ASC,\n	[_Fld4695] ASC,\n	[_Fld4694] ASC\n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = ON, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) \nON [FILEGROUP_3] -- Задаем имя новой файловой группы\nGO\n\nCREATE UNIQUE NONCLUSTERED INDEX [_InfoRg4683_ByResource4705_SNNNNNNNNNNBN] ON [dbo].[_InfoRg4683]\n(\n	[_Fld4697] ASC,\n	[_Fld4684] ASC,\n	[_Fld4685] ASC,\n	[_Fld4686] ASC,\n	[_Fld4687] ASC,\n	[_Fld4688] ASC,\n	[_Fld4689] ASC,\n	[_Fld4690] ASC,\n	[_Fld4691] ASC,\n	[_Fld4692] ASC,\n	[_Fld4693] ASC,\n	[_Fld4694] ASC,\n	[_Fld4695] ASC\n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = ON, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) \nON [FILEGROUP_3] -- Задаем имя новой файловой группы\nGO\n\nCREATE UNIQUE NONCLUSTERED INDEX [_InfoRg4683_ByResource4706_SNNNNNNNNNNBN] ON [dbo].[_InfoRg4683]\n(\n	[_Fld4698] ASC,\n	[_Fld4684] ASC,\n	[_Fld4685] ASC,\n	[_Fld4686] ASC,\n	[_Fld4687] ASC,\n	[_Fld4688] ASC,\n	[_Fld4689] ASC,\n	[_Fld4690] ASC,\n	[_Fld4691] ASC,\n	[_Fld4692] ASC,\n	[_Fld4693] ASC,\n	[_Fld4694] ASC,\n	[_Fld4695] ASC\n)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = ON, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) \nON [FILEGROUP_3] -- Задаем имя новой файловой группы\n                ",className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"Для того, чтобы сгенерировать скрипты создания индексов, можно воспользоваться стандартными возможностями SQL Managment Studio по созданию скриптов для базы данных."}),(0,N.jsxs)(s.xv,{p:!0,children:["Все, теперь мы счастливые обладатели регистра сведений, который находится в дополнительной файловой группе. Смотрим итог с ",(0,N.jsx)("b",{children:(0,N.jsx)("u",{children:(0,N.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-File-Groups/%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8%20%D0%BE%20%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85%20%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B0%D1%85.sql",children:"помощью этих скриптов"})})}),"."]}),(0,N.jsxs)(d.b,{"aria-label":"Файлы базы",children:[(0,N.jsxs)(i.J,{children:[(0,N.jsx)(_.j,{children:"Таблица"},"Table"),(0,N.jsx)(_.j,{children:"Индекс"},"Index"),(0,N.jsx)(_.j,{children:"Файловая группа"},"FileGroup"),(0,N.jsx)(_.j,{children:"Файл"},"File")]}),(0,N.jsxs)(E.y,{children:[(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByDims_NNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_3"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_3.mdf"})]},"1"),(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByResource4705_SNNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_3"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_3.mdf"})]},"2"),(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByDims_NNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_3"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_3.mdf"})]},"3"),(0,N.jsxs)(a.g,{children:[(0,N.jsx)(c.X,{children:"_InfoRg4683"}),(0,N.jsx)(c.X,{children:"_InfoRg4683_ByDims_NNNNNNNNNNBN"}),(0,N.jsx)(c.X,{children:"FILEGROUP_3"}),(0,N.jsx)(c.X,{children:"D:\\DBs\\bsl_fg_3.mdf"})]},"4")]})]}),(0,N.jsx)(s.xv,{p:!0,children:"Как итог, определим плюсы и минусы."}),(0,N.jsx)(s.xv,{p:!0,children:"Плюсы:"}),(0,N.jsxs)(s.aV,{children:[(0,N.jsx)("li",{children:"Быстрый и эффективный способ работы с файловыми группами."}),(0,N.jsx)("li",{children:"Нет необходимости каких-либо действий на стороне 1С."})]}),(0,N.jsx)(s.xv,{p:!0,children:"Минусы:"}),(0,N.jsx)(s.aV,{children:(0,N.jsx)("li",{children:"Нет связи с платформой 1С, даже призрачной как в прошлом примере."})}),(0,N.jsx)(s.xv,{p:!0,children:"Конечно, предпочтительнее использовать этот способ, если Вы бережете время, нервы и деньги."}),(0,N.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Сложности для 1С"}),(0,N.jsx)(s.xv,{p:!0,children:"Все выглядит просто, но есть нюансы."}),(0,N.jsx)(s.xv,{p:!0,children:"Во-первых, лицензионное соглашение 1С запрещает так работать с СУБД, т.к. эти возможности недокументированы. Начиная использовать файловые группы, Вы должны осознавать риски нарушения этого соглашения. Минимальные последствия - это отказ в технической поддержке решений на платформе 1С."}),(0,N.jsx)(s.xv,{p:!0,children:"В пункте 65 лицензионного соглашения сказано следующее:"}),(0,N.jsx)(r.Z,{code:'\nЛицензионное соглашение не позволяет использовать недокументированные фирмой "1С" средства для построения решений на платформе "1С:Предприятие". Это означает, что средства СУБД (или любые другие внесистемные средства) можно использовать только в том случае, если документация по продуктам линейки "1С:Предприятие" (включая 1С:ИТС) содержит явную рекомендацию использовать данное средство для решения данной задачи.\n\nВо всех остальных случаях лицензионное соглашение позволяет использовать для построения решений только штатные средства платформы. В частности, можно обращаться к данным информационной базы только при помощи объектов "1С:Предприятия", специально предназначенных для работы с данными (запросы, справочники, документы и т. д.). Нельзя обращаться к данным информационной базы напрямую, минуя уровень объектов работы с данными "1С:Предприятия", например при помощи средств СУБД или при помощи внешних компонент, которые реализуют прямой доступ к СУБД. Это ограничение распространяется на любые действия с данными, в том числе на изменение их структуры, а так же на чтение или изменение самих данных информационной базы или служебных данных "1С:Предприятия".\n\nДанное ограничение необходимо для обеспечения стабильности работы механизмов системы, осуществления поддержки и возможности перехода на новые версии "1С:Предприятия".\n\n                ',className:"my-5",language:"text"}),(0,N.jsx)(s.xv,{p:!0,children:"Вы должны четко понимать плюсы и минусы данного шага. Все, что Вы сделаете будет на Вашей совести!"}),(0,N.jsx)(s.xv,{p:!0,children:"Во-вторых, это усложнение сопровождения, т.к. при обновлении базы данных необходимо учитывать тот факт, что некоторые таблицы находятся в других файловых группах или дисковых носителях."}),(0,N.jsx)(s.xv,{p:!0,children:"Зачем это учитывать? Например, у Вас в базе есть регистр сведений “Присоединенные файлы” (в базе представлен таблицей “_InfoRg2133”), в котором хранятся двоичные данные разнотипных документов. Для экономии места в основном хранилище данных был выполнен перенос этих документов в отдельную файловую группу. Файл данных для нее находится на отдельном диске."}),(0,N.jsx)(s.xv,{p:!0,children:"Платформа 1С хранит двоичные данные документов в LOB-типах данных (image или varbinary(max) в зависимости от версии платформы). Для переноса LOB-данных в отдельную файловую группу не обязательно переносить всю таблицу и индексы. Достаточно перенести только сами LOB-данные, указав основную файловую группу для таких типов. Именно так мы и сделаем в примере ниже."}),(0,N.jsx)(r.Z,{code:"\n-- Создаем таблицу с новыми настройками хранения LOB-данных,\n-- при этом структура таблица полностью поторяет структуру исходной\n-- таблицы регистра сведений \"Присоединенные файлы\"\nCREATE TABLE dbo.Tmp__InfoRg2133\n	(\n	_Fld2134_TYPE binary(1) NOT NULL,\n	_Fld2134_RTRef binary(4) NOT NULL,\n	_Fld2134_RRRef binary(16) NOT NULL,\n	_Fld2135 image NOT NULL,\n	_Fld2683 numeric(7, 0) NOT NULL\n	)  ON [PRIMARY]\n    -- !!! Именно здесь необходимо указать файловую группу,\n    -- !!! в которой будут храниться двоичные данные документов\n	 TEXTIMAGE_ON FILEGROUP_3\nGO\n\n-- Для оптимизации устанавливаем уровень эскалации блокировок = Таблица\nALTER TABLE dbo.Tmp__InfoRg2133 SET (LOCK_ESCALATION = TABLE)\nGO\n\n-- Переносим данные из старой таблицы в новую\nIF EXISTS(SELECT * FROM dbo._InfoRg2133)\n	 EXEC('INSERT INTO dbo.Tmp__InfoRg2133 (_Fld2134_TYPE, _Fld2134_RTRef, _Fld2134_RRRef, _Fld2135, _Fld2683)\n		SELECT _Fld2134_TYPE, _Fld2134_RTRef, _Fld2134_RRRef, _Fld2135, _Fld2683 FROM dbo._InfoRg2133 WITH (HOLDLOCK TABLOCKX)')\nGO\n\n-- Удаляем старую таблицу\nDROP TABLE dbo._InfoRg2133\nGO\n\n-- Новой таблице присваиваем то же самое имя, что было у исходной\nEXECUTE sp_rename N'dbo.Tmp__InfoRg2133', N'_InfoRg2133', 'OBJECT' \nGO\n\n-- Далее создаем недостающие индексы. Все аналогично исходной таблице\nCREATE UNIQUE CLUSTERED INDEX _InfoRg2133_ByDims_R ON dbo._InfoRg2133\n	(\n	_Fld2683,\n	_Fld2134_TYPE,\n	_Fld2134_RTRef,\n	_Fld2134_RRRef\n	) WITH( STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]\nGO\n                ",className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"Теперь все LOB-данные перенесены в файловую группу “FILEGROUP_3”. При необходимости основной файл данных, где ранее хранились перемещенные документы, можно уменьшить операцией Shrink. В нашем случае мы это рассматривать не будем."}),(0,N.jsx)(s.xv,{p:!0,children:"Не забудьте сделать бэкап перед такими операциями. Этот скрипт не является готовым решением. Его можно улучшить за счет различных проверок, транзакций и т.д."}),(0,N.jsx)(s.xv,{p:!0,children:"Все отлично сработало, мы освободили 1 ТБ данных в основном хранилище. НО! В один прекрасный день разработчики 1С внесли изменения в систему, добавив новый ресурс к регистру сведений “Присоединенные файлы”. В тестовых базах все проверено, ведь там никто не держит полную копию рабочей базы. Изменение ушло в релиз, но при развертывании возникли следующие проблемы:"}),(0,N.jsxs)(s.aV,{children:[(0,N.jsx)("li",{children:"в хранилище, где находится основной файл базы данных, не хватило места при выполнении реструктуризации. Ведь в процессе платформа создает таблицу заново в основной файловой группе базы, то есть в “PRIMARY”. Получается, что платформа создала таблицу и “перегоняла” в нее данные из файловой группы “FILEGROUP_3”, пока не заполнила диск."}),(0,N.jsx)("li",{children:"Из-за прерванной с ошибкой реструктуризации в базе данных (в файловой группе “PRIMARY”) останется таблица “_InfoRg2133NG”, в которую платформа и “переливала” данные. Чтобы исправить ситуацию и освободить место ее нужно будет удалить вручную. Не будем останавливаться на описании процесса реструктуризации, лишь отметим, что платформа добавляет к пересоздаваемым таблицам постфикс “NG”. Так Вы можете в базе найти таблицы, которые появились при “битой” реструктуризации базы данных."}),(0,N.jsx)("li",{children:"Исправить последствия попытки реструктуризации может быть не просто, ведь для этого нужно выполнить шринк основного файла данных, а это может быть очень длительной и ресурсоемкой операцией. Да, в прошлом пункте мы удалили таблицу, но файл данных от этого не уменьшился в размере. Мы лишь освободили место в самом файле данных."})]}),(0,N.jsx)(s.xv,{p:!0,children:"В итоге, если такая ситуация произойдет и добрые администраторы не смогут выделить дополнительное место да дисках, то может произойти остановка работы системы. Но это не точно и полностью зависит от Вашей инфраструктуры!"}),(0,N.jsx)(s.xv,{p:!0,children:"Но есть ли способ избавиться от такой проблемы? Да, есть! Вот несколько рекомендаций:"}),(0,N.jsxs)(s.aV,{type:x.RH.number,children:[(0,N.jsx)("li",{children:"Проверять перечень таблиц для реструктуризации перед каждым релизом."}),(0,N.jsxs)("li",{children:["В случае, если изменения затронули тяжелые таблицы, для которых применены нестандартные файловые группы, то один из вариантов:",(0,N.jsxs)(s.aV,{children:[(0,N.jsx)("li",{children:"Отказаться от изменения на этой таблице. Вместо этого использовать внешние таблицы. Например, вместо добавления реквизита в справочник можно добавить его как доп. свойство или в дополнительный регистр сведений. Включите воображение!"}),(0,N.jsx)("li",{children:"Если изменения все же очень нужны, то необходимо делать реструктуризацию в “ручном режиме”. Подробнее останавливаться на этом сейчас не будем, но на ИС уже об этом писали. Причем, чем больше изменений, тем и сложнее будет сделать это вручную."})]})]}),(0,N.jsx)("li",{children:"Максимально автоматизировать настройку файловых групп для таблиц и индексов базы, а также сделать заглушки для тех таблиц, где реструктуризация автоматически проходить не должна. Об этом будет ниже."})]}),(0,N.jsx)(s.xv,{p:!0,children:"В этом и кроются основные причины усложнения сопровождения. Поэтому стоит 7 раз подумать, прежде чем начать такое у себя использовать."}),(0,N.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Автоматизируй это!"}),(0,N.jsxs)(s.xv,{p:!0,children:["Выше мы упомянули про автоматизацию настроек файловых групп для таблиц и индексов. На самом деле здесь ничего нового нет и используется тот же самый подход по созданию произвольных индексов и применению настроек сжатия, что был в статье ",(0,N.jsx)("b",{children:(0,N.jsx)("u",{children:(0,N.jsx)(s.e9,{newTab:!0,href:"/pages/blog/DevOps/2018-11/custom-index-for-1C.tsx",children:"“Создаем свои индексы для баз 1С. Со своей структурой и настройками!”"})})}),". Он заключается в создании глобальных триггеров, в которых мы отлавливаем события создания таблицы или индекса и встраиваем свою логику для настройки базы данных."]}),(0,N.jsx)(r.Z,{code:"\nCREATE TRIGGER [CustomSettingsMaintenance_OnIndexCreate]\nON ALL SERVER\nAFTER CREATE_INDEX\nAS\nBEGIN\n	SET NOCOUNT ON\n\n	DECLARE @SchemaName SYSNAME,\n		@TableName SYSNAME,\n		@DatabaseName SYSNAME,\n		@IndexName SYSNAME;\n\n    SELECT @TableName = EVENTDATA().value('(/EVENT_INSTANCE/TargetObjectName)[1]','SYSNAME')\n    SELECT @SchemaName = EVENTDATA().value('(/EVENT_INSTANCE/SchemaName)[1]','SYSNAME')\n	SELECT @IndexName = EVENTDATA().value('(/EVENT_INSTANCE/ObjectName)[1]','SYSNAME')\n	SELECT @DatabaseName = EVENTDATA().value('(/EVENT_INSTANCE/DatabaseName)[1]','SYSNAME');\n\n	-- Здесь выполняем необходимые действия. \n    --  Например, возможные варианты:\n    --      1. Пересоздаем индекс с учетом новой файловой группы\n    --      2. Вызываем ошибку, если реструктуризация на этой таблице\n    --      не должна проходить автоматически. В этом случае\n    --      обновление базы будет доступно после отключения глобальных триггеров,\n    --      зато не будет непредвиденных падений информационной системы.\n    --      3. Ничего не делаем, если платформенная реструктуризация работает как надо.\n\nEND\n                ",className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"Как пересоздать индекс с учетом новой файловой группы? Например, у нас есть таблица “_InfoRg4683” и индекс “_InfoRg4683_ByDims_NNNNNNNNNNBN” (это из примера с регистром сведений “История адресных объектов”), при этом основная файловая группа в базе это “PRIMARY”. Имея уже такие данные мы можем написать такой скрипт."}),(0,N.jsx)(s.xv,{p:!0,children:"Скрипт генерирует команду “CREATE INDEX” для уже существующего индекса, а в ней мы просто подменяем имя файловой группы."}),(0,N.jsx)(r.Z,{code:"\n-- Исходные параметры\nDECLARE @tableNameForChange SYSNAME = '_InfoRg4683',\n		@indexNameForChange SYSNAME = '_InfoRg4683_ByDims_NNNNNNNNNNBN',\n		@CreateIndexSQL nvarchar(max);\n\n-- Запрос генерирует команду создания индекса\nSELECT @CreateIndexSQL =\n	(' CREATE ' + \n    CASE WHEN I.is_unique = 1 THEN ' UNIQUE ' ELSE '' END  +  \n    I.type_desc COLLATE DATABASE_DEFAULT +' INDEX ' +   \n    I.name  + ' ON '  +  \n    Schema_name(T.Schema_id)+'.'+T.name + ' ( ' + \n    KeyColumns + ' )  ' + \n    ISNULL(' INCLUDE ('+IncludedColumns+' ) ','') + \n    ISNULL(' WHERE  '+I.Filter_definition,'') + ' WITH ( ' + \n    CASE WHEN I.is_padded = 1 THEN ' PAD_INDEX = ON ' ELSE ' PAD_INDEX = OFF ' END + ','  + \n    'FILLFACTOR = '+CONVERT(CHAR(5),CASE WHEN I.Fill_factor = 0 THEN 100 ELSE I.Fill_factor END) + ','  + \n    -- default value \n    'SORT_IN_TEMPDB = OFF '  + ','  + \n    CASE WHEN I.ignore_dup_key = 1 THEN ' IGNORE_DUP_KEY = ON ' ELSE ' IGNORE_DUP_KEY = OFF ' END + ','  + \n    CASE WHEN ST.no_recompute = 0 THEN ' STATISTICS_NORECOMPUTE = OFF ' ELSE ' STATISTICS_NORECOMPUTE = ON ' END + ','  + \n    -- default value  \n    ' DROP_EXISTING = ON '  + ','  + \n    -- default value  \n    ' ONLINE = OFF '  + ','  + \n   CASE WHEN I.allow_row_locks = 1 THEN ' ALLOW_ROW_LOCKS = ON ' ELSE ' ALLOW_ROW_LOCKS = OFF ' END + ','  + \n   CASE WHEN I.allow_page_locks = 1 THEN ' ALLOW_PAGE_LOCKS = ON ' ELSE ' ALLOW_PAGE_LOCKS = OFF ' END  + ' ) ON [' + \n   DS.name + '] ')\nFROM sys.indexes I   \n JOIN sys.tables T ON T.Object_id = I.Object_id    \n JOIN sys.sysindexes SI ON I.Object_id = SI.id AND I.index_id = SI.indid   \n JOIN (SELECT * FROM (  \n    SELECT IC2.object_id , IC2.index_id ,  \n        STUFF((SELECT ' , ' + C.name + CASE WHEN MAX(CONVERT(INT,IC1.is_descending_key)) = 1 THEN ' DESC ' ELSE ' ASC ' END \n    FROM sys.index_columns IC1  \n    JOIN Sys.columns C   \n       ON C.object_id = IC1.object_id   \n       AND C.column_id = IC1.column_id   \n       AND IC1.is_included_column = 0  \n    WHERE IC1.object_id = IC2.object_id   \n       AND IC1.index_id = IC2.index_id   \n    GROUP BY IC1.object_id,C.name,index_id  \n    ORDER BY MAX(IC1.key_ordinal)  \n       FOR XML PATH('')), 1, 2, '') KeyColumns   \n    FROM sys.index_columns IC2   \n    WHERE IC2.Object_id = object_id(@tableNameForChange) \n    GROUP BY IC2.object_id ,IC2.index_id) tmp3 )tmp4   \n  ON I.object_id = tmp4.object_id AND I.Index_id = tmp4.index_id  \n JOIN sys.stats ST ON ST.object_id = I.object_id AND ST.stats_id = I.index_id   \n JOIN sys.data_spaces DS ON I.data_space_id=DS.data_space_id   \n JOIN sys.filegroups FG ON I.data_space_id=FG.data_space_id   \n LEFT JOIN (SELECT * FROM (   \n    SELECT IC2.object_id , IC2.index_id ,   \n        STUFF((SELECT ' , ' + C.name  \n    FROM sys.index_columns IC1   \n    JOIN Sys.columns C    \n       ON C.object_id = IC1.object_id    \n       AND C.column_id = IC1.column_id    \n       AND IC1.is_included_column = 1   \n    WHERE IC1.object_id = IC2.object_id    \n       AND IC1.index_id = IC2.index_id    \n    GROUP BY IC1.object_id,C.name,index_id   \n       FOR XML PATH('')), 1, 2, '') IncludedColumns    \n   FROM sys.index_columns IC2    \n   WHERE IC2.Object_id = object_id(@tableNameForChange)  \n   GROUP BY IC2.object_id ,IC2.index_id) tmp1   \n   WHERE IncludedColumns IS NOT NULL ) tmp2    \nON tmp2.object_id = I.object_id AND tmp2.index_id = I.index_id   \nWHERE I.is_primary_key = 0 AND I.is_unique_constraint = 0 \n	AND I.Object_id = object_id(@tableNameForChange) \n	AND I.name = @indexNameForChange\n\n-- Заменяем исходную файловую группу на необходимую\nSET @CreateIndexSQL = REPLACE(@CreateIndexSQL, 'ON [PRIMARY]', 'ON [FILEGROUP_3]');\n\n-- Пересоздаем индекс\nexec sp_executesql @CreateIndexSQL;\n                ",className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"Параметр “DROP_EXISTING = ON” позволяет избежать ошибки, что такой индекс уже существует. В этом случае СУБД удалит старый индекс и создаст новый."}),(0,N.jsx)(s.xv,{p:!0,children:"Также есть несколько нюансов при пересоздании индексов с новыми файловыми группами:"}),(0,N.jsxs)(s.aV,{type:x.RH.number,children:[(0,N.jsx)("li",{children:"При пересоздании кластерного индекса с новой файловой группой, все остальные индексы таблицы будут также созданы с этой файловой группой."}),(0,N.jsx)("li",{children:"Для большей универсальности имя новой и старой файловой группы можно получать динамически, вместо явного указания в скрипте."}),(0,N.jsx)("li",{children:"Пользователь СУБД, от имени которого выполняется реструктуризация, должен иметь необходимые привилегии для выполнения запросов."})]}),(0,N.jsx)(s.xv,{p:!0,children:"А что на счет остановки реструктуризации, если она начинается на таблице, где этого происходить не должно?"}),(0,N.jsx)(s.xv,{p:!0,children:"В триггере проверяем имя таблицы и/или индекса и если он попадает под запрет, то выполняем:"}),(0,N.jsx)(r.Z,{code:"\nCREATE TRIGGER [StopUpdateInfobase_OnIndexCreate]\nON ALL SERVER\nAFTER CREATE_INDEX\nAS\nBEGIN\n	SET NOCOUNT ON\n\n	DECLARE @SchemaName SYSNAME,\n		@TableName SYSNAME,\n		@DatabaseName SYSNAME,\n		@IndexName SYSNAME;\n\n    SELECT @TableName = EVENTDATA().value('(/EVENT_INSTANCE/TargetObjectName)[1]','SYSNAME')\n    SELECT @SchemaName = EVENTDATA().value('(/EVENT_INSTANCE/SchemaName)[1]','SYSNAME')\n	SELECT @IndexName = EVENTDATA().value('(/EVENT_INSTANCE/ObjectName)[1]','SYSNAME')\n	SELECT @DatabaseName = EVENTDATA().value('(/EVENT_INSTANCE/DatabaseName)[1]','SYSNAME');\n\n	IF(@TableName LIKE '_InfoRg4683' OR @TableName LIKE '_InfoRg4683NG')\n	BEGIN\n		DECLARE @msg nvarchar(max) = 'Реструктуризация таблицы ' + @TableName + ' запрещена!';\n		RAISERROR (@msg, 10, 1); \n\n		THROW 51000, 'Обнаружен запрет реструктуризации таблицы базы данных!', 1;  \n	END\n\nEND\n                ",className:"my-5",language:"sql"}),(0,N.jsx)(s.xv,{p:!0,children:"При попытке запуска обновления информационной базы получим ошибку."}),(0,N.jsx)(s.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-04/split-database-by-files/3. Ошибка в процессе обновления.png",alt:"Ошибка в процессе обновления",size:x.h2.MEDIUM}),(0,N.jsxs)(s.xv,{p:!0,children:["Можно пойти дальше и не ограничиваться отдельными скриптами, а вынести все подобные ограничения и настройки в отдельный инструмент, ",(0,N.jsx)("b",{children:(0,N.jsx)("u",{children:(0,N.jsx)(s.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/1%D0%A1-Extended-Database-Settings-Maintenance",children:"как это было сделано здесь"})})}),"."]}),(0,N.jsx)(s.xv,{title:!0,className:"mt-10 md:text",children:"Послесловие"}),(0,N.jsx)(s.xv,{p:!0,children:"На первый, второй и третий взгляд все это может показаться настоящим монстром, особенно для сопровождения. Что ж, так оно и есть! Остается надеяться, что наступят светлые времена, когда платформа 1С позволит использовать возможности СУБД без таких костылей. А пока на этом все!"}),(0,N.jsx)(s.xv,{p:!0,children:"Удачи в бою!"})]})},850:function(n,e,l){"use strict";l.d(e,{Z:function(){return c}});var N=l(5893),s=l(7294),d=l(4965),i=l(4275),_=l(7340);function E(){let n=(0,_._)(["\n  text-align: left;\n  overflow: hidden;\n  font-size: 14px;\n  border-radius: 6px;\n  overflow: auto;\n  max-height: 350px;\n\n  & .token-line {\n    line-height: 1.3em;\n    height: 1.3em;\n  }\n"]);return E=function(){return n},n}let a=l(964).ZP.pre(E());var c=n=>{let{code:e,className:_,language:E}=n;return(void 0!==l.g?l.g:window).Prism=d.p1,l(1354),l(9016),l(5266),l(2927),l(1315),l(7874),l(6862),(0,N.jsx)("div",{className:(0,i.GF)("bg-blue-500 md:p-5 p-2",_),children:(0,N.jsx)("div",{className:"shadow-lg",children:(0,N.jsx)(d.y$,{theme:d.np.vsDark,code:e,language:null!=E?E:E="tsx",children:n=>{let{className:e,style:l,tokens:d,getLineProps:i,getTokenProps:_}=n;return(0,N.jsx)(a,{className:e,style:l,children:d.map((n,e)=>(0,s.createElement)("div",{...i({line:n,key:e}),key:Math.random()},n.map((n,e)=>(0,s.createElement)("span",{..._({token:n,key:e}),key:Math.random()}))))})}})})})}},9305:function(n,e,l){"use strict";l.d(e,{Ee:function(){return _},Xg:function(){return d},Y7:function(){return r},aV:function(){return a},e9:function(){return c},o_:function(){return x},ty:function(){return E},xv:function(){return i}});var N=l(5152),s=l.n(N);let d=s()(()=>Promise.all([l.e(4838),l.e(4738),l.e(1664),l.e(7167)]).then(l.bind(l,7167)),{loadableGenerated:{webpack:()=>[7167]}}),i=s()(()=>l.e(9179).then(l.bind(l,9179)),{loadableGenerated:{webpack:()=>[9179]}}),_=s()(()=>l.e(1974).then(l.bind(l,1974)),{loadableGenerated:{webpack:()=>[1974]}}),E=s()(()=>l.e(8547).then(l.bind(l,8547)),{loadableGenerated:{webpack:()=>[8547]}}),a=s()(()=>l.e(6806).then(l.bind(l,6806)),{loadableGenerated:{webpack:()=>[6806]}}),c=s()(()=>Promise.all([l.e(1664),l.e(1465)]).then(l.bind(l,1465)),{loadableGenerated:{webpack:()=>[1465]}});s()(()=>l.e(567).then(l.bind(l,567)),{loadableGenerated:{webpack:()=>[567]}});let r=s()(()=>Promise.all([l.e(2004),l.e(4139)]).then(l.bind(l,4139)),{loadableGenerated:{webpack:()=>[4139]}}),x=s()(()=>Promise.all([l.e(3811),l.e(7472),l.e(584),l.e(7870)]).then(l.bind(l,7870)),{loadableGenerated:{webpack:()=>[7870]}})}},function(n){n.O(0,[1102,3811,433,2888,9774,179],function(){return n(n.s=7609)}),_N_E=n.O()}]);