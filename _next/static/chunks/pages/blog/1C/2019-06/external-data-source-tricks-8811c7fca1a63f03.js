(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1856],{57692:function(n,e,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/1C/2019-06/external-data-source-tricks",function(){return a(46444)}])},46444:function(n,e,a){"use strict";a.r(e);var t=a(85893),l=a(97037);a(67294);var r=a(13803),s=a(46416);e.default=()=>(0,t.jsxs)(l.Xg,{blogcentered:!0,children:[(0,t.jsxs)(l.xv,{textAlign:s.PH.RIGHT,quote:!0,children:["Люди, которые думают, будто я ничего не боюсь, когда выполняю все эти трюки, еще более сумасшедшие, чем я.",(0,t.jsx)("br",{}),"(с) Джеки Чан"]}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Некоторые трюки для преодоления ограничений внешних источников данных."}),(0,t.jsx)(l.xv,{title:!0,className:"mt-10 md:text",children:"Содержание"}),(0,t.jsxs)(l.aV,{children:[(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#what-is",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"С чем боремся"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#poligon-test",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Полигон для испытаний"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#just-do-it",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Просто напиши запрос"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#where-my-returns",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Где же возвращаемые параметры"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#result-from-proc",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Вернуть набор из процедуры"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#any-script",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Выполнение любого скрипта"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#danger",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Опасность"})})})}),(0,t.jsx)("li",{children:(0,t.jsx)(l.e9,{href:"#the-end",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Вот и все"})})})})]}),(0,t.jsxs)("section",{id:"section-what-is",children:[(0,t.jsx)(l.xv,{id:"what-is",title:!0,className:"mt-10 md:text",children:"С чем боремся"}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["Использование BULK-операций для ускорения массовой загрузки / обновления данных в базе достаточно частый сценарий, особенно в интеграциях. Для платформы 1С это можно реализовать через внешние источники данных. Но есть серьезные ограничения этого механизма при работе с базой данных, а именно:",(0,t.jsxs)(l.aV,{children:[(0,t.jsx)("li",{children:"Отсутствует возможность вызова хранимых процедур с возвратом значений для OUTPUT-параметров."}),(0,t.jsx)("li",{children:"Также нет возможности получить возвращаемый набор данных из хранимой процедуры."}),(0,t.jsx)("li",{children:"Недоступно выполнение произвольных SQL-скриптов"}),(0,t.jsx)("li",{children:"И другие специфические ограничения."})]})]}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Сегодня мы рассмотрим некоторые пути обхода этих ограничений, а также сделаем несколько особых трюков с этим функционалом платформы 1С."}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:[(0,t.jsx)("b",{children:"Внимание!"})," Все, что Вы увидите дальше - это воистину костыли, которых еще поискать! Не рекомендую использовать их на рабочем окружении, только если ну очень сильно нужно. В остальных случаях лучше использовать ADO."]}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["Ниже не будет описания механизма источника данных, для этого обратитесь к ",(0,t.jsx)(l.e9,{newTab:!0,href:"https://v8.1c.ru/platforma/vneshniy-istochnik-dannyh/",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"официальной документации"})})}),"."]})]}),(0,t.jsxs)("section",{id:"section-poligon-test",children:[(0,t.jsx)(l.xv,{id:"poligon-test",title:!0,className:"mt-10 md:text",children:"Полигон для испытаний"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Все дальнейшие действия будут выполняться на простой базе данных, развернутой на SQL Server. Вот скрипт, если захотите создать ее у себя."}),(0,t.jsx)(r.Z,{code:"\nCREATE TABLE [dbo].[KeyOperations](\n	[ID] [binary](16) NOT NULL,\n	[Name] [nvarchar](150) NOT NULL,\n	[Description] [nvarchar](max) NULL,\n    CONSTRAINT [PK_KeyOperations] PRIMARY KEY CLUSTERED \n    (\n        [ID] ASC\n    )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]\n) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]\nGO\n\nCREATE TABLE [dbo].[PerformanceMeasurements](\n	[KeyOperation] [varchar](34) NOT NULL,\n	[BeginDate] [numeric](15, 0) NOT NULL,\n	[SessionID] [numeric](15, 0) NOT NULL,\n	[PeriodHour] [datetime2](7) NOT NULL,\n	[Duration] [numeric](15, 3) NOT NULL,\n	[UserName] [nvarchar](150) NOT NULL,\n    CONSTRAINT [PK_PerformanceMeasurements] PRIMARY KEY CLUSTERED \n    (\n        [KeyOperation] ASC,\n        [BeginDate] ASC,\n        [SessionID] ASC,\n        [PeriodHour] ASC\n    )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]\n) ON [PRIMARY]\nGO\n\nCREATE PROCEDURE [dbo].[ExecCustomCommand]\n	@SqlCommand nvarchar(max)\nAS\nBEGIN	\n	EXEC sp_executesql @SqlCommand;\nEND\nGO\n\nCREATE PROCEDURE [dbo].[ProcWithOutputParams]\n	@inputParam INT,\n	@outputParam int = NULL OUTPUT,\n	@outputParamOther int = NULL OUTPUT\nAS\nBEGIN\n	SET @outputParam = @inputParam + 10;\n	SET @outputParamOther = @outputParam * 100;\nEND\nGO\n                    ",className:"my-5",language:"sql"}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["Также для примера будет использоваться конфигурация, исходный код которой можно будет ",(0,t.jsx)(l.e9,{newTab:!0,href:"https://github.com/YPermitin/Infostart-Data-Public/tree/master/2019/3.%20%D0%9C%D0%B0%D1%80%D1%82/%D0%A2%D1%80%D1%8E%D0%BA%D0%B8%20%D1%81%20%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%BC%D0%B8%20%D0%B8%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"найти на GitHub"})})}),". Используемая версия платформы 8.3.13.1690, но думаю описанные подходы будут работать и на других версиях."]})]}),(0,t.jsxs)("section",{id:"section-just-do-it",children:[(0,t.jsx)(l.xv,{id:"just-do-it",title:!0,className:"mt-10 md:text",children:"Просто напиши запрос"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"И так, у Вас есть внешняя база данных, которая тесно интегрирована в некоторые решение на платформе 1С. Для интеграции используются внешние источники данных. Исходные метаданные выглядят таким образом."}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/1. Пример объекта.png",alt:"Пример внешнего источника данных",size:s.h2.XS}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Источник включает в себя несколько таблиц и функцию. Не будем останавливаться на назначении каждого объекта, сейчас это добавлено только для примера. Позже Вы сами все увидите."}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Для начала решим простую задачу - добавить таблицу, которая будет показывать текущие активные соединения и текст выполняемого запроса. Для SQL Server запрос может выглядеть так."}),(0,t.jsx)(r.Z,{code:"\nSELECT   \n	s.session_id, \n    r.status, \n    r.cpu_time, \n    Substring(st.TEXT,(r.statement_start_offset / 2) + 1, \n                    ((CASE r.statement_end_offset \n                        WHEN -1 \n                        THEN Datalength(st.TEXT) \n                        ELSE r.statement_end_offset \n                        END - r.statement_start_offset) / 2) + 1) AS statement_text, \n	r.command, \n    s.login_name, \n    s.host_name, \n    s.program_name\nFROM sys.dm_exec_sessions AS s \n	JOIN sys.dm_exec_requests AS r \n		ON r.session_id = s.session_id \n	CROSS APPLY sys.Dm_exec_sql_text(r.sql_handle) AS st \n                    ",className:"my-5",language:"sql"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:'Для этого добавим новую таблицу в источник, но в качестве вида таблицы указать "Выражение". В само выражение вставим SQL-запрос (см. под спойлером выше). Что же в таком простейшем примере может пойти не так? А вот что!'}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/2. Ошибка внешнего источника данных.png",alt:"Пример внешнего источника данных",size:s.h2.MEDIUM}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Идем в конфигуратор и видим странную картину."}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/3. Странности в настройках.png",alt:"Странности в настройках",size:s.h2.SMALL}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Окей! Смирились, простили, сделали запрос одной строкой без переносов. Да, неудобно, но что поделать. Пробуем еще раз получить данные."}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/4. Новая ошибка.png",alt:"Новая ошибка",size:s.h2.MEDIUM}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Что это опять за магия? Все дело в том, что платформа преобразует выражение таблицы к следующему виду."}),(0,t.jsx)(r.Z,{code:"\nSELECT TOP 1000\n    T1.Поле1,\n    T1.Поле2,\n    -- Перечисление полей источника\n    T1.ПолеN\nFROM \n    -- Здесь SQL-запрос из выражения\nAS T1\n                    ",className:"my-5",language:"sql"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Если бы вместо произвольного запроса была указана таблица, то все работало бы отлично. В этом же случае платформа не оборачивает выражение как вложенный запрос, поэтому происходит ошибка. К счастью, исправить ее не сложно - нужно просто обернуть все выражение в круглые скобки, в начале и в конце."}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/5. Трюк.png",alt:"Трюк",size:s.h2.SMALL}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Попробуем еще раз обратиться к таблице."}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/6. Заработало.png",alt:"Заработало",size:s.h2.MEDIUM}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["И, ура! Все получилось. Обратите внимание - мы поймали запрос, который сами и выполняем. Просто в тестовой базе больше никого нет ",":)","."]}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Вот такие особенности при использовании произвольных выражений в таблицах внешних источников данных. Наверняка худшего многие с этим сталкивались и успешно обходили. Но по сравнению с остальными ограничениями и проблемами это лишь небольшая фича."})]}),(0,t.jsxs)("section",{id:"section-where-my-returns",children:[(0,t.jsx)(l.xv,{id:"where-my-returns",title:!0,className:"mt-10 md:text",children:"Где же возвращаемые параметры"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Следующей интересной задачей будет вызов хранимой процедуры. Вроде все просто - добавляем функцию во внешний источник данных, определяем ее параметры, и она уже готова к вызову. Но хранимая процедура у нас не простая (по крайней мере для платформы 1С)! Она содержит выходные параметры, которые заполняются внутри самой процедуры при выполнении, а после возвращаются вызывающему коду."}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"В тестовой базе создана процедура с таким определением."}),(0,t.jsx)(r.Z,{code:"\nREATE PROCEDURE [dbo].[ProcWithOutputParams]\n	@inputParam INT,\n	-- Выходные параметры определены со значением по умолчанию = NULL\n	-- Это сделано для того, чтобы ее можно было вызвать без указания\n	-- выходных параметров\n	@outputParam int = NULL OUTPUT,\n	@outputParamOther int = NULL OUTPUT\nAS\nBEGIN\n	SET @outputParam = @inputParam + 10;\n	SET @outputParamOther = @outputParam * 100;\nEND\n                    ",className:"my-5",language:"sql"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:'Вызвать эту процедуру без выходных параметров просто - нужно добавить функцию внешнего источника и определить выражение "dbo.ProcWithOutputParams(&1)".'}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/7. Вызываем процедуру.png",alt:"Вызываем процедуру",size:s.h2.MEDIUM}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:'Но нам это не подходит, т. к. не позволяет получить назад выходные параметры. Даже если попытаться определить их в выражении "dbo.ProcWithOutputParams(&1, &2, &3)", то при вызове платформа просто не вернет значения в переменные.'}),(0,t.jsx)(r.Z,{code:"\nПерем1 = 100;\nПерем2 = 0;\nПерем3 = 0;\n	\nВнешниеИсточникиДанных.ПримерИсточникаДанных.ProcWithOutputParams(Перем1, Перем2, Перем3);\n\n// Перем2 и Перем3 останутся с исходными значениями.\n                    ",className:"my-5",language:"bsl"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Как же быть и есть ли выход? Выход есть! К сожалению, он не такой элегантный и интуитивно понятный как использование ADO, но позволяет возвращать любые значений назад в код 1С из внешнего источника данных. Для начала нам понадобиться добавить в базу данных хранимую процедуру для произвольного выполнения команд."}),(0,t.jsx)(r.Z,{code:"\nCREATE PROCEDURE [dbo].[ExecCustomCommand]\n	@SqlCommand nvarchar(max)\nAS\nBEGIN	\n	EXEC sp_executesql @SqlCommand;\nEND\n                    ",className:"my-5",language:"sql"}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["Эта процедура позволит выполнять произвольные TSQL-команды. Но это еще не все. Мы до сих пор не можем возвращать данные. Возьмем самый доступный в этой ситуации способ - будем использовать ",(0,t.jsx)(l.e9,{newTab:!0,href:"https://metanit.com/sql/sqlserver/10.4.php",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"глобальную временную таблицу"})})}),", в которую будем вставлять результаты команд и считывать их отдельным SELECT'ом. Вот так будет выглядеть эта таблица."]}),(0,t.jsx)(r.Z,{code:"\n-- Имя глобальной временной таблицы начинается с ##.\n-- Будем считать, что у нас только 1 временная таблица для целей передачи данных,\n-- хотя можно было бы усложнить пример и создавать свои временные таблицы\n-- для каждой сессии\nIF(OBJECT_ID('tempdb..##CallsAndValues_ExternalDataSource') IS NULL)\nBEGIN\n	BEGIN TRY \n		CREATE TABLE ##CallsAndValues_ExternalDataSource\n		(\n			-- Поле идентификатора вызова (какой-то GUID)\n			CallId varchar(36) NOT NULL,\n			-- Результат в виде текста\n			Result nvarchar(max) NULL\n		)\n		-- Создаем индекс для оптимизации поиска\n		CREATE UNIQUE CLUSTERED INDEX [_indx1] ON ##CallsAndValues_ExternalDataSource\n		(\n			[CallId] ASC\n		)\n	END TRY \n	BEGIN CATCH \n		-- При ошибке ничего не делаем\n	END CATCH  \nEND\n                    ",className:"my-5",language:"sql"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Для доступа к значению в этой таблице нужно знать идентификатор вызова. Чтобы упростить доступ можно добавить таблицу во внешний источник данных со следующим выражением."}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/8. Еще трюк.png",alt:"Еще трюк",size:s.h2.MEDIUM}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"После получения значения лучше всего его удалять из таблицы. Также есть нюанс - если попытаться обратиться к таблице до ее создания, то конечно же мы получим ошибку. Для корректной работы необходимо обрабатывать подобные исключения в конфигурации. Вернемся к примеру. Вот так теперь можно вызвать хранимую процедуру и получить результат."}),(0,t.jsx)(r.Z,{code:'\n// Инициализируем идентификатор вызова\nИдентификаторВызова = Новый УникальныйИдентификатор;\nИдентификаторВызова = Строка(ИдентификаторВызова);\nПараметрХранимойПроцедуры = 100;\n\n// Инициализация промежуточной глобальной временной таблицы при необходимости\nКомандаИнициализацииПромежуточнойТаблицы = "\n|IF(OBJECT_ID(\'tempdb..##CallsAndValues_ExternalDataSource\') IS NULL)\n|BEGIN\n|	BEGIN TRY \n|		CREATE TABLE ##CallsAndValues_ExternalDataSource\n|		(\n|			-- Поле идентификатора вызова (какой-то GUID)\n|			CallId varchar(36) NOT NULL,\n|			-- Результат в виде текста\n|			Result nvarchar(max) NULL\n|		)\n|		-- Создаем индекс для оптимизации поиска\n|		CREATE UNIQUE CLUSTERED INDEX [_indx1] ON ##CallsAndValues_ExternalDataSource\n|		(\n|			[CallId] ASC\n|		)\n|	END TRY \n|	BEGIN CATCH \n|		-- При ошибке ничего не делаем\n|	END CATCH  \n|END\n|";\nВнешниеИсточникиДанных.ПримерИсточникаДанных.ExecCustomCommand(КомандаИнициализацииПромежуточнойТаблицы);\n\n// Формируем SQL-команду для вызова хранимой процедуры и сохранения\n// параметров в промежуточную временную таблицу\nКомандаSQL = "\n|SET NOCOUNT ON;\n|\n|DECLARE	@outputParam int,\n|		@outputParamOther int,\n|		@callId nvarchar(36) = \'&ИдентификаторВызова\'\n|\n|EXEC	[dbo].[ProcWithOutputParams]\n|		@inputParam = &ПараметрХранимойПроцедуры,\n|		@outputParam = @outputParam OUTPUT,\n|		@outputParamOther = @outputParamOther OUTPUT\n|\n|DECLARE @xmlResult xml =\n|(\n|	SELECT	@outputParam as N\'outputParam\',\n|			@outputParamOther as N\'outputParamOther\'\n|	FOR XML RAW\n|)\n|\n|DELETE ##CallsAndValues_ExternalDataSource\n|WHERE CallId = @callId;\n|\n|INSERT ##CallsAndValues_ExternalDataSource (CallId, Result)\n|	VALUES(@callId, CAST(@xmlResult AS nvarchar(max)))\n|";	\nКомандаSQL = СтрЗаменить(КомандаSQL, "&ИдентификаторВызова", ИдентификаторВызова);	\nКомандаSQL = СтрЗаменить(КомандаSQL, "&ПараметрХранимойПроцедуры", XMLСтрока(ПараметрХранимойПроцедуры));	\nВнешниеИсточникиДанных.ПримерИсточникаДанных.ExecCustomCommand(КомандаSQL);\n	\n// Получаем результат выполнения в виде строки XML\nЗапрос = Новый Запрос;\nЗапрос.Текст = \n	"ВЫБРАТЬ\n	|	CallsAndValues.Result КАК Result\n	|ИЗ\n	|	ВнешнийИсточникДанных.ПримерИсточникаДанных.Таблица.CallsAndValues КАК CallsAndValues\n	|ГДЕ\n	|	CallsAndValues.ID = &ID";	\nЗапрос.УстановитьПараметр("ID", ИдентификаторВызова);	\nРезультатЗапроса = Запрос.Выполнить();	\nВыборка = РезультатЗапроса.Выбрать();\nВыборка.Следующий();	\nРезультатXML = Выборка.Result;\n\n// Удаляем результат из промежуточной таблицы\nТекстКомандыОчисткиПолученногоЗначения = "\n|DECLARE @sql nvarchar(max) = \'DELETE FROM ##CallsAndValues_ExternalDataSource WHERE CallId = @CallId\';\n|EXECUTE sp_executesql @sql, N\'@CallId varchar(36)\', @CallId = \'" + ИдентификаторВызова + "\'\n|";\nВнешниеИсточникиДанных.ПримерИсточникаДанных.ExecCustomCommand(ТекстКомандыОчисткиПолученногоЗначения);\n\n// Разбираем полученный XML\nПарсер = Новый ЧтениеXML;\nПарсер.УстановитьСтроку(РезультатXML);\nПостроитель = Новый ПостроительDOM; \nДокумент = Построитель.Прочитать(Парсер);\nраз = новый РазыменовательПространствИменDOM(Документ, "");\nРезультатПоиска = Документ.ВычислитьВыражениеXPath("/row", Документ, раз);\nНайденныйЭлемент = РезультатПоиска.ПолучитьСледующий();\noutputParam = НайденныйЭлемент.Атрибуты.ПолучитьИменованныйЭлемент("outputParam").Значение;\noutputParamOther = НайденныйЭлемент.Атрибуты.ПолучитьИменованныйЭлемент("outputParamOther").Значение;\n\n// Выводим исходную XML и полученные значения\nСообщить("XML: " + РезультатXML);\nСообщить("outputParam: " + outputParam);\nСообщить("outputParamOther: " + outputParamOther);\n                    ',className:"my-5",language:"bsl"}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["Общий принцип работы алгоритма следующий:",(0,t.jsxs)(l.aV,{type:s.RH.number,children:[(0,t.jsx)("li",{children:'Инициализируем идентификатор вызова, по которому потом можно будет получить результат. Также подготавливаем все необходимые параметры для процедуры (в нашем случае это один входной параметр "@inputParam" с типом INT).'}),(0,t.jsx)("li",{children:"Проводим инициализацию глобальной временной таблицы, если она еще не создана."}),(0,t.jsx)("li",{children:"Выполняем SQL-команду для вызова хранимой процедуры с последующим преобразованием результата в XML, и сохранением в промежуточную таблицу."}),(0,t.jsx)("li",{children:"Получаем значение XML из промежуточной таблицы и удаляем из нее полученное значение."}),(0,t.jsx)("li",{children:"Выводим результат."})]}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Вот некоторые пояснения к SQL-команде вызова процедуры."}),(0,t.jsx)(r.Z,{code:"\nSET NOCOUNT ON;\n\n-- Инициализация необходимых переменных\nDECLARE	@outputParam int,\n		@outputParamOther int,\n		@callId nvarchar(36) = '&ИдентификаторВызова'\n\n-- Вызов процедуры\nEXEC	[dbo].[ProcWithOutputParams]\n		@inputParam = &ПараметрХранимойПроцедуры,\n		@outputParam = @outputParam OUTPUT,\n		@outputParamOther = @outputParamOther OUTPUT\n\n-- Выбираем выходные параметры с помощью обычного SELECT,\n-- преобразовывая результат к XML с помощью выражения \"FOR XML RAW\"\nDECLARE @xmlResult xml =\n(\n	SELECT	@outputParam as N'outputParam',\n			@outputParamOther as N'outputParamOther'\n	FOR XML RAW\n)\n\n-- Очищаем промежуточную таблицу от значений\n-- с таким же идентификатором вызова\nDELETE ##CallsAndValues_ExternalDataSource\nWHERE CallId = @callId;\n\n-- Добавляем XML в промежуточную таблицу, предварительно\n-- преобразовав ее к строке\nINSERT ##CallsAndValues_ExternalDataSource (CallId, Result)\n	VALUES(@callId, CAST(@xmlResult AS nvarchar(max)))\n                    ",className:"my-5",language:"sql"})]}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Как итог, на стороне 1С у нас есть текст XML, который мы разобрали и получили выходные параметры хранимой процедуры. Остается только продолжить с ними работу (преобразовать к нужному типу, сохранить куда-либо и т.д.)."}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Код получился достаточно объемным. Можно инкапсулировать некоторую функциональность в общем модуле таким способом."}),(0,t.jsx)(r.Z,{code:'\n#Область ПрограммныйИнтерфейс\n\nФункция ВыполнитьПроизвольныйСкрипт(Знач ТекстСкрипта) Экспорт\n	\n	ИнициализацияПромежуточнойТаблицы();\n	\n	ИдентификаторВызова = Новый УникальныйИдентификатор;\n	ИдентификаторВызова = Строка(ИдентификаторВызова);\n	\n	ТекстСкрипта = СтрЗаменить(ТекстСкрипта, "&ИдентификаторВызова", ИдентификаторВызова);\n	\n	ВнешниеИсточникиДанных.ПримерИсточникаДанных.ExecCustomCommand(ТекстСкрипта);	\n	\n	Возврат ПолучитьРезультатВызова(ИдентификаторВызова, Истина);\n	\nКонецФункции\n\n#КонецОбласти\n\n#Область Служебный\n\nПроцедура ИнициализацияПромежуточнойТаблицы()\n	\n	КомандаИнициализацииПромежуточнойТаблицы = "\n	|IF(OBJECT_ID(\'tempdb..##CallsAndValues_ExternalDataSource\') IS NULL)\n	|BEGIN\n	|	BEGIN TRY \n	|		CREATE TABLE ##CallsAndValues_ExternalDataSource\n	|		(\n	|			-- Поле идентификатора вызова (какой-то GUID)\n	|			CallId varchar(36) NOT NULL,\n	|			-- Результат в виде текста\n	|			Result nvarchar(max) NULL\n	|		)\n	|		-- Создаем индекс для оптимизации поиска\n	|		CREATE UNIQUE CLUSTERED INDEX [_indx1] ON ##CallsAndValues_ExternalDataSource\n	|		(\n	|			[CallId] ASC\n	|		)\n	|	END TRY \n	|	BEGIN CATCH \n	|		-- При ошибке ничего не делаем\n	|	END CATCH  \n	|END\n	|";\n	\n	ВнешниеИсточникиДанных.ПримерИсточникаДанных.ExecCustomCommand(КомандаИнициализацииПромежуточнойТаблицы);	\n	\nКонецПроцедуры\n\nФункция ПолучитьРезультатВызова(ИдентификаторВызова, УдалитьЗначениеПослеПолучения = Ложь)\n	\n	Запрос = Новый Запрос;\n	Запрос.Текст = \n		"ВЫБРАТЬ\n		|	CallsAndValues.Result КАК Result\n		|ИЗ\n		|	ВнешнийИсточникДанных.ПримерИсточникаДанных.Таблица.CallsAndValues КАК CallsAndValues\n		|ГДЕ\n		|	CallsAndValues.ID = &ID";	\n	Запрос.УстановитьПараметр("ID", ИдентификаторВызова);	\n	РезультатЗапроса = Запрос.Выполнить();	\n	Выборка = РезультатЗапроса.Выбрать();\n	\n	Если УдалитьЗначениеПослеПолучения Тогда\n		УдалитьЗначениеВызова(ИдентификаторВызова);\n	КонецЕсли;\n	\n	Если Выборка.Следующий() Тогда\n		Возврат Выборка.Result;\n	Иначе\n		Возврат Null;\n	КонецЕсли;\n	\nКонецФункции\n\nПроцедура УдалитьЗначениеВызова(ИдентификаторВызова)\n	\n	ТекстКоманды = "\n	|DECLARE @sql nvarchar(max) = \'DELETE FROM ##CallsAndValues_ExternalDataSource WHERE CallId = @CallId\';\n	|EXECUTE sp_executesql @sql, N\'@CallId varchar(36)\', @CallId = \'" + ИдентификаторВызова + "\'\n	|";\n	\n	ВнешниеИсточникиДанных.ПримерИсточникаДанных.ExecCustomCommand(ТекстКоманды);\n	\nКонецПроцедуры\n\n#КонецОбласти\n                    ',className:"my-5",language:"bsl"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:'В процедуру передается текст SQL-команды для выполнения, при этом в скрипте должен быть указан параметр "&ИдентификаторВызова", чтобы его можно было явно подменить перед выполнением. Если такого параметра в скрипте нет, то получить возвращаемое значение будет нельзя.'}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Алгоритмы можно еще улучшить, но для примера этого должно быть достаточно. Теперь код вызова будет выглядеть более лаконично."}),(0,t.jsx)(r.Z,{code:'\nПараметрХранимойПроцедуры = 100;\n	\nКомандаSQL = "\n|SET NOCOUNT ON;\n|\n|DECLARE	@outputParam int,\n|		@outputParamOther int,\n|		@callId nvarchar(36) = \'&ИдентификаторВызова\'\n|\n|EXEC	[dbo].[ProcWithOutputParams]\n|		@inputParam = &ПараметрХранимойПроцедуры,\n|		@outputParam = @outputParam OUTPUT,\n|		@outputParamOther = @outputParamOther OUTPUT\n|\n|DECLARE @xmlResult xml =\n|(\n|	SELECT	@outputParam as N\'outputParam\',\n|			@outputParamOther as N\'outputParamOther\'\n|	FOR XML RAW\n|)\n|\n|DELETE ##CallsAndValues_ExternalDataSource\n|WHERE CallId = @callId;\n|\n|INSERT ##CallsAndValues_ExternalDataSource (CallId, Result)\n|	VALUES(@callId, CAST(@xmlResult AS nvarchar(max)))\n|";		\nКомандаSQL = СтрЗаменить(КомандаSQL, "&ПараметрХранимойПроцедуры", XMLСтрока(ПараметрХранимойПроцедуры));\n\nРезультатXML = ПомощникРаботыСВнешнимИсточникомДанных.ВыполнитьПроизвольныйСкрипт(КомандаSQL);\n\n// Разбираем полученный XML\nПарсер = Новый ЧтениеXML;\nПарсер.УстановитьСтроку(РезультатXML);\nПостроитель = Новый ПостроительDOM; \nДокумент = Построитель.Прочитать(Парсер);\nраз = новый РазыменовательПространствИменDOM(Документ, "");\nРезультатПоиска = Документ.ВычислитьВыражениеXPath("/row", Документ, раз);\nНайденныйЭлемент = РезультатПоиска.ПолучитьСледующий();\noutputParam = НайденныйЭлемент.Атрибуты.ПолучитьИменованныйЭлемент("outputParam").Значение;\noutputParamOther = НайденныйЭлемент.Атрибуты.ПолучитьИменованныйЭлемент("outputParamOther").Значение;\n\n// Выводим исходную XML и полученные значения\nСообщить("XML: " + РезультатXML);\nСообщить("outputParam: " + outputParam);\nСообщить("outputParamOther: " + outputParamOther);\n                    ',className:"my-5",language:"bsl"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Но работать через ADO все равно будет эффективней!"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Вот и все. Мы добавили немного костылей и палок, теперь внешние источники данных можно использовать для более широкого спектра задач."})]}),(0,t.jsxs)("section",{id:"section-result-from-proc",children:[(0,t.jsx)(l.xv,{id:"result-from-proc",title:!0,className:"mt-10 md:text",children:"Вернуть набор из процедуры"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:'С получением выходных параметров хранимых процедур мы разобрались, но есть и более сложный случай - получить набор записей, который эта процедура вернула. Например, есть служебная процедура "sp_who", которая возвращает текущую активность на сервере.'}),(0,t.jsx)(l.Ee,{className:"my-4",src:"/public/imp_assets/1C/2019-06/external-data-source-tricks/9. Результат вызова процедуры.png",alt:"Результат вызова процедуры",size:s.h2.MEDIUM}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Как же нам получить этот набор данных через внешний источник на стороне 1С? Сделать SELECT к хранимой процедуре нельзя, нужен альтернативный вариант."}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"На самом деле все просто - модифицируем предыдущий пример и получим такую SQL-команду. Самое важное - это передача результатирующего набора процедуры в табличную переменную, который потом можно преобразовать к XML."}),(0,t.jsx)(r.Z,{code:"\nDECLARE @callId nvarchar(36) = '&ИдентификаторВызова'\n\n-- Создаем переменную с типом таблица\nDECLARE @T Table (\n	spid INT NULL, \n	ecid INT NULL, \n	status nvarchar(50) NULL, \n	loginname nvarchar(50) NULL, \n	hostname nvarchar(50) NULL, \n	blk INT NULL, \n	dbname nvarchar(50) NULL, \n	cmd nvarchar(50) NULL, \n	request_id INT null\n);\n-- Вызываем процедуру и сохраняем первый возвращаемый набор в таблицу\nINSERT @T EXEC sp_who;\n\n-- Сохраняем набор записей в XML\nDECLARE @xmlResult xml =\n(\n	SELECT * FROM @T\n	FOR XML RAW\n)\n\nDELETE ##CallsAndValues_ExternalDataSource\nWHERE CallId = @callId;\n\nINSERT ##CallsAndValues_ExternalDataSource (CallId, Result)\n	VALUES(@callId, CAST(@xmlResult AS nvarchar(max)))\n                    ",className:"my-5",language:"sql"}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["Сам по себе способ преобразования значений к XML очень универсален, но имеет некоторые накладные расходы как на сериализацию, так и на десериализацию. Вот более подробная информация по инструкции ",(0,t.jsx)(l.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/xml/for-xml-sql-server?view=sql-server-2017",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:'"FOR XML"'})})}),"."]}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Тут ничего нового не увидите, все аналогично предыдущему примеру."}),(0,t.jsx)(r.Z,{code:"\nКомандаSQL = \"\n|DECLARE @callId nvarchar(36) = '&ИдентификаторВызова'\n|\n|-- Создаем переменную с типом таблица\n|DECLARE @T Table (\n|	spid INT NULL, \n|	ecid INT NULL, \n|	status nvarchar(50) NULL, \n|	loginname nvarchar(50) NULL, \n|	hostname nvarchar(50) NULL, \n|	blk INT NULL, \n|	dbname nvarchar(50) NULL, \n|	cmd nvarchar(50) NULL, \n|	request_id INT null\n|);\n|-- Вызываем процедуру и сохраняем первый возвращаемый набор в таблицу\n|INSERT @T EXEC sp_who;\n|\n|-- Сохраняем набор записей в XML\n|DECLARE @xmlResult xml =\n|(\n|	SELECT * FROM @T\n|	FOR XML RAW\n|)\n|\n|DELETE ##CallsAndValues_ExternalDataSource\n|WHERE CallId = @callId;\n|\n|INSERT ##CallsAndValues_ExternalDataSource (CallId, Result)\n|	VALUES(@callId, CAST(@xmlResult AS nvarchar(max)))\";\n	\nРезультатXML = ПомощникРаботыСВнешнимИсточникомДанных.ВыполнитьПроизвольныйСкрипт(КомандаSQL);\n\n// Далее необходимо разобрать XML\n                    ",className:"my-5",language:"bsl"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Парсинг результата опустим, он не имеет для примера большого значения."}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Теперь у Вас должно быть представление, что работать с хранимыми процедурами через внешний источник данных можно, хоть и выглядит это мягко говоря странно."})]}),(0,t.jsxs)("section",{id:"section-any-script",children:[(0,t.jsx)(l.xv,{id:"any-script",title:!0,className:"mt-10 md:text",children:"Выполнение любого скрипта"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"ЕНа самом деле мы получили возможность работать не только с хранимыми процедурами, но выполнять абсолютно любой SQL-скрипт и получать результат любого вида. Главное чтоб его можно было преобразовать в XML. В новых редакциях SQL Server результат можно возвращать также и в JSON-формате."}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Например, с помощью внешнего источника данных теперь можно делать то, что раньше казалось недоступным!"}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Обновление статистики"})}),(0,t.jsx)(r.Z,{code:'\nКомандаSQL = "\n|USE [PerfMonitoring];\n|UPDATE STATISTICS [dbo].[PerformanceMeasurements] WITH FULLSCAN;";\n		\nРезультатXML = ПомощникРаботыСВнешнимИсточникомДанных.ВыполнитьПроизвольныйСкрипт(КомандаSQL);\n                    ',className:"my-5",language:"bsl"})]}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Удаление таблицы"})}),(0,t.jsx)(r.Z,{code:'\nКомандаSQL = "\n|USE [PerfMonitoring];\n|DROP TABLE [dbo].[KeyOperations];";\n	\nРезультатXML = ПомощникРаботыСВнешнимИсточникомДанных.ВыполнитьПроизвольныйСкрипт(КомандаSQL);\n                    ',className:"my-5",language:"bsl"})]}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:[(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"Удаление базы данных"})}),(0,t.jsx)(r.Z,{code:'\nКомандаSQL = "\n|USE [PerfMonitoring];\n|DROP DATABASE [PerfMonitoring];";\n		\nРезультатXML = ПомощникРаботыСВнешнимИсточникомДанных.ВыполнитьПроизвольныйСкрипт(КомандаSQL);\n                    ',className:"my-5",language:"bsl"})]})]}),(0,t.jsxs)("section",{id:"section-danger",children:[(0,t.jsx)(l.xv,{id:"danger",title:!0,className:"mt-10 md:text",children:"Опасность"}),(0,t.jsxs)(l.xv,{textAlign:s.PH.JUSTIFY,children:["Подобный подход работы с базой имеет ряд существенных недостатков:",(0,t.jsxs)(l.aV,{type:s.RH.number,children:[(0,t.jsx)("li",{children:"Сложность сопровождения, ведь вместо обычных SQL-скриптов приходиться предусматривать маневры для возврата значений на сторону 1С."}),(0,t.jsx)("li",{children:"Множество избыточных действий могут влиять на производительность (использование временных таблиц, преобразование результатов запросов в XML и обратно и др.)."}),(0,t.jsx)("li",{children:"Большой удар по безопасности, т.к. теперь из кода 1С можно выполнить любую SQL-команду. Конечно, правами учетной записи SQL-сервера можно себя обезопасить, но для этого также потребуется время и ресурсы на настройку и сопровождение."}),(0,t.jsxs)("li",{children:["Также неграмотное составление SQL-команд может привести к неоптимальной работе SQL Server. Например, если вместо передачи значений в запрос использовать не параметры, а явное указание значения. В этом случае кэширование планов запросов не будет эффективно работать. Вот интересный материал ",(0,t.jsx)(l.e9,{newTab:!0,href:"https://habr.com/ru/articles/272807/",children:(0,t.jsx)("b",{children:(0,t.jsx)("u",{children:"про динамические SQL-запросы"})})}),"."]})]})]})]}),(0,t.jsxs)("section",{id:"section-the-end",children:[(0,t.jsx)(l.xv,{id:"the-end",title:!0,className:"mt-10 md:text",children:"Вот и все"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Может быть кому-нибудь это будет полезно, но используйте это только когда больше нет выхода. Вместо этих костылей лучше использовать ADO. Судите сами, вот так будет выглядеть вызов хранимой процедуры с выходными параметрами."}),(0,t.jsx)(r.Z,{code:'\nСтрокаСоединения = "DRIVER={SQL Server};SERVER=<ИмяСервера>;UID=<Логин>;PWD=<Пароль>;Trusted_Connection=False;APP=PerfMonitoring;DATABASE=PerfMonitoring;LANGUAGE=русский";\n\nПараметрХранимойПроцедуры = 100;\n\nConnection  = Новый COMОбъект("ADODB.Connection");\nConnection.CursorLocation = 3;\nConnection.CommandTimeout = 60;\nConnection.ConnectionTimeOut = 60;\nConnection.Open(СтрокаСоединения);	\n\nCommand = Новый COMОбъект("ADODB.Command");\nCommand.ActiveConnection = Connection;\n\nCommand.CommandText = "ProcWithOutputParams";\nCommand.CommandType = 4; // adCmdStoredProc	\n\nТипINT = 3; // adinteger\nТипПараметраВходящего = 1;\nТипПараметраИсходящего = 2;\n\nCommand.Parameters.Append(Command.CreateParameter("@inputParam", ТипINT, ТипПараметраВходящего));\nCommand.Parameters.Append(Command.CreateParameter("@outputParam", ТипINT, ТипПараметраИсходящего));\nCommand.Parameters.Append(Command.CreateParameter("@outputParamOther", ТипINT, ТипПараметраИсходящего));\nCommand.Parameters("@inputParam").Value = ПараметрХранимойПроцедуры; \nCommand.Execute();\n\noutputParam = Command.Parameters("@outputParam").Value;\noutputParamOther = Command.Parameters("@outputParamOther").Value;\n\nСообщить("outputParam: " + outputParam);\nСообщить("outputParamOther: " + outputParamOther);\n                    ',className:"my-5",language:"bsl"}),(0,t.jsx)(l.xv,{textAlign:s.PH.JUSTIFY,children:"Так стоит ли усложнять? После этого все то, что мы делали выше, кажется бессмысленным. Но решать конечно же только Вам!"})]})]})},12250:function(n,e,a){"use strict";var t,l;a.d(e,{b:function(){return t}}),(l=t||(t={})).Min="350px",l.Standard="700px",l.Large="1000x",l.Unlimited=""},13803:function(n,e,a){"use strict";var t=a(37340),l=a(85893),r=a(67294),s=a(14965),i=a(54951),c=a(41686),d=a(12250);function u(){let n=(0,t._)(["\n        text-align: left;\n        overflow: hidden;\n        font-size: 14px;\n        border-radius: 6px;\n        overflow: auto;\n\n        & .token-line {\n            line-height: 1.3em;\n            height: 1.3em;\n        }\n    "]);return u=function(){return n},n}function x(){let n=(0,t._)(["\n        max-height: ","\n    "]);return x=function(){return n},n}e.Z=n=>{let{code:e,className:t,language:m,maxHeight:o=d.b.Standard}=n;(void 0!==a.g?a.g:window).Prism=s.p1,a(61354),a(79016),a(2731),a(35266),a(92927),a(51315),a(57874),a(86862);let h=null!=o?o:d.b.Standard,E=c.ZP.pre(u()),T=(0,c.ZP)(E)(x(),h);return(0,l.jsx)("div",{className:(0,i.GF)("bg-blue-500 md:p-1 p-2",t),children:(0,l.jsx)("div",{className:"shadow-lg",children:(0,l.jsx)(s.y$,{theme:s.np.vsDark,code:e.trim(),language:null!=m?m:m="tsx",children:n=>{let{className:e,style:a,tokens:t,getLineProps:s,getTokenProps:i}=n;return(0,l.jsx)(T,{className:e,style:a,children:t.map((n,e)=>(0,r.createElement)("div",{...s({line:n,key:e}),key:Math.random()},n.map((n,e)=>(0,r.createElement)("span",{...i({token:n,key:e}),key:Math.random()}))))})}})})})}},97037:function(n,e,a){"use strict";a.d(e,{Ee:function(){return i},Xg:function(){return r},Y7:function(){return x},aV:function(){return d},e9:function(){return u},o_:function(){return m},tf:function(){return o},ty:function(){return c},xv:function(){return s}});var t=a(5152),l=a.n(t);let r=l()(()=>Promise.all([a.e(549),a.e(4738),a.e(4838),a.e(1664),a.e(1274)]).then(a.bind(a,91274)),{loadableGenerated:{webpack:()=>[91274]}}),s=l()(()=>Promise.all([a.e(4454),a.e(7897)]).then(a.bind(a,97897)),{loadableGenerated:{webpack:()=>[97897]}}),i=l()(()=>Promise.all([a.e(3536),a.e(2726)]).then(a.bind(a,2726)),{loadableGenerated:{webpack:()=>[2726]}}),c=l()(()=>Promise.all([a.e(549),a.e(378)]).then(a.bind(a,90378)),{loadableGenerated:{webpack:()=>[90378]}}),d=l()(()=>Promise.all([a.e(9300),a.e(7200)]).then(a.bind(a,7200)),{loadableGenerated:{webpack:()=>[7200]}}),u=l()(()=>Promise.all([a.e(1664),a.e(8681)]).then(a.bind(a,28681)),{loadableGenerated:{webpack:()=>[28681]}});l()(()=>a.e(2857).then(a.bind(a,22857)),{loadableGenerated:{webpack:()=>[22857]}});let x=l()(()=>Promise.all([a.e(2004),a.e(3070)]).then(a.bind(a,63070)),{loadableGenerated:{webpack:()=>[63070]}}),m=l()(()=>Promise.all([a.e(162),a.e(4380),a.e(3959),a.e(6050),a.e(239),a.e(8568)]).then(a.bind(a,32215)),{loadableGenerated:{webpack:()=>[32215]}}),o=l()(()=>Promise.all([a.e(162),a.e(1664),a.e(3959),a.e(6050),a.e(4205)]).then(a.bind(a,84205)),{loadableGenerated:{webpack:()=>[84205]}})}},function(n){n.O(0,[4104,2888,9774,179],function(){return n(n.s=57692)}),_N_E=n.O()}]);