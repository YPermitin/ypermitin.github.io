(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[974],{6905:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/SQLServer/2019-05/monitoring-with-extended-events-and-other",function(){return s(6239)}])},6239:function(e,n,s){"use strict";s.r(n);var r=s(5893),t=s(9305);s(7294);var a=s(850),l=s(7105);n.default=()=>(0,r.jsxs)(t.Xg,{blogcentered:!0,children:[(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Немного истории"}),(0,r.jsx)(t.xv,{p:!0,children:"Как показывает практика, во многих компаниях малого и среднего бизнеса (а иногда и крупного) можно столкнуться с отсутствием должного обслуживания серверов баз данных. В самом крайнем случае это выражается в наличии неэффективной стратегии бэкапирования или, о ужас, ее полном отсутствии! Представьте, что произойдет, если после аварии не удастся восстановить базу со всеми данными о деятельности компании?"}),(0,r.jsx)(t.xv,{p:!0,children:"Приходилось ли Вам сталкиваться с системными администраторами, которые в случае проблем производительности и стабильности баз 1С отвечают:"}),(0,r.jsxs)(t.aV,{children:[(0,r.jsx)("li",{children:"Это не наша проблема! Обращайтесь к разработчикам 1С."}),(0,r.jsx)("li",{children:"С нашей стороны все в порядке, это 1С так работает."}),(0,r.jsx)("li",{children:"Какая еще 1С? Мне нужно настроить AD, а также провести миграцию некоторых серверов в облака."}),(0,r.jsx)("li",{children:"(просто молча убегают в закат) и др. странные ситуации."})]}),(0,r.jsx)(t.xv,{p:!0,children:"Знакомо? С одной стороны админов понять можно, ведь для исправления подобных проблем нужны время и знания (иногда специфические), за которые работодатель и платить то не всегда готов. С другой стороны, если не администратор должен за этим следить, то кто? Админа БД не везде можно найти и нанять."}),(0,r.jsxs)(t.xv,{p:!0,children:["Разработчики 1С также не всегда имеют необходимые компетенции и получается замкнутый круг. Разработчики показывают пальцем на админа, а админ на “этих” 1Сников. Причем у разработчиков даже прав доступа может не быть для решения проблем. В итоге бизнес заказывает внешний аудит производительности ",":)"]}),(0,r.jsxs)(t.xv,{p:!0,children:["Как тут быть? Все просто (ну, почти) - нужно кооперироваться. Можно настроить мониторинг на SQL Server силами админа, а результаты показывать разработчикам 1С и обсуждать что нужно для решения проблем. Согласитесь, сесть раз в неделю или раз в месяц и разобрать проблемы - займет намного меньше сил и нервов, если продолжать спихивать друг на друга ответственность и конфликтовать. ",(0,r.jsx)("b",{children:"* Конечно, это работает только при адекватности всех сторон."})]}),(0,r.jsx)(t.xv,{p:!0,children:"Сегодня в статье мы рассмотрим простые способы настройки мониторинга SQL Server с помощью Extended Events и с некоторыми другими способами, а также продемонстрируем как собранные данные интерпретировать и что показать 1Сникам."}),(0,r.jsx)(a.Z,{code:"\nВнимание! Статья не является полным руководством. \nЗдесь Вы найдете общую информацию и примеры, \nа также ссылки на полезные материалы по связанным темам.\n                ",className:"my-5",language:"text"}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Extended Events vs. SQL Profiler (SQL Trace)"}),(0,r.jsxs)(t.xv,{p:!0,children:["Прежде чем перейти непосредственно к примерам настроек сбора данных, нужно пояснить почему все же предлагается использовать Extended Events вместо ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/tools/sql-server-profiler/sql-server-profiler?view=sql-server-ver16",children:"SQL Profiler"})})}),". Несомненно, SQL Profiler остается одним из самых используемых инструментов для диагностики работы SQL Server, несмотря на то, что считается устаревшим. Не зря Microsoft предупреждает, что он может быть удален в будущих версиях СУБД, ведь ему на смену давно пришел более продвинутый инструмент - ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server?view=sql-server-ver16",children:"Extended Events"})})}),"."]}),(0,r.jsxs)(t.xv,{p:!0,children:["SQL Profiler является графической надстройкой для ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/relational-databases/sql-trace/sql-trace?view=sql-server-ver16",children:"SQL Trace"})})}),", с помощью которой он собирает данные, а после выводит их в графический интерфейс приложения. Как и SQL Profiler, SQL Trace считается устаревшим инструментом и может быть удален в будущем. Так почему же расширенные события лучше старых добрых трасс?"]}),(0,r.jsxs)(t.aV,{type:l.RH.number,children:[(0,r.jsxs)("li",{children:["SQL Trace находится в режиме поддержки и не дополняется новым функционалом. Также он изначально содержал меньше доступных событий для анализа. К тому же, Extended Events содержит больше информации о событиях. Сравните возможности SQL Trace и Extended Events для различных редакций SQL Server по количеству доступных событий.",(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/1. XEvets vs SQL Trace.png",alt:"XEvets vs SQL Trace",size:l.h2.MEDIUM})]}),(0,r.jsx)("li",{children:"Значительно меньшее влияние на производительность при включенном сборе данных, причем имеются расширенные настройки, с помощью которых на это можно влиять."}),(0,r.jsx)("li",{children:"Настройки сбора данных (события, фильтры и др.) можно менять на активных сессиях, прямо во время сбора данных."}),(0,r.jsx)("li",{children:"Доступен хэш запросов, чтобы идентифицировать одинаковые тексты запросов."}),(0,r.jsx)("li",{children:"Можно настроить различные способы хранения логов, причем одновременно в нескольких вариантах."}),(0,r.jsx)("li",{children:"Встроенные инструменты в SQL Server Managment Studio и инструкции TSQL для работы с ними."}),(0,r.jsxs)("li",{children:["Поддержка PowerShell ",":)"]}),(0,r.jsx)("li",{children:"И еще многое другое."})]}),(0,r.jsx)(t.xv,{p:!0,children:"Все еще используйте SQL Profiler / SQL Trace? Я тоже! Но, SQL Profiler только для тестовых баз, где нужно быстро посмотреть, что там за запрос. Если же нужно выполнять работы на рабочем окружении или настраивать мониторинг, то только Extended Events!"}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Собираем данные"}),(0,r.jsx)(t.xv,{p:!0,children:"И так, Вы собираетесь использовать расширенные события, но куда смотреть? В SQL Server Managment Studio в разделе “Управление ➡️ Расширенные события ➡️ Сеансы” Вы можете найти список всех сеансов расширенных событий."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/2. Сессии сбора данных.png",alt:"Сессии сбора данных",size:l.h2.SMALL}),(0,r.jsx)(t.xv,{p:!0,children:"Здесь же можно добавить новый сеанс расширенных событий с помощью мастера, так и с помощью полной настройки вручную с нуля. Также можно управлять состоянием каждого сеанса (остановить или запустить), удалить его или сформировать скрипт T-SQL на основе существующего объекта."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/3. Создание новой сессии.png",alt:"Создание новой сессии",size:l.h2.XS}),(0,r.jsx)(t.xv,{p:!0,children:"Рассматривать процесс создания сеанса с помощью графического интерфейса мы не будем. Вместо этого создадим основные сеансы расширенных событий с помощью T-SQL."}),(0,r.jsx)(t.xv,{p:!0,children:"Помните! Все что описано ниже лишь примеры и их нужно адаптировать под конкретную ситуацию: устанавливать фильтры по базе, настраивать хранение сеансов, добавлять другие необходимые события или удалять лишние, изменять состав собираемых полей и так далее. Главное начать, а там уже все будет проще!"}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Тяжелые запросы по CPU"}),(0,r.jsxs)(t.xv,{p:!0,children:["Обычно всех интересуют долгие по времени выполнения запросы, или запросы отбирающие больше всего ресурсов CPU. Это не одно и то же, ведь на сервере может быть включен параллелизм, тогда затраченное процессорное время не будет равно времени выполнения запроса даже приблизительно. Для отслеживания событий по CPU достаточно использовать два события: ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/rpc-completed-event-class?view=sql-server-ver16",children:"RPC:Completed"})})})," и ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/sql-batchcompleted-event-class?view=sql-server-ver16",children:"SQL:BatchCompleted"})})}),". Первое событие возникает при вызове процедур, которые обычно делает платформа 1С через обращение к ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql?view=sql-server-ver16",children:"sp_executesql"})})}),". Практически во всех остальных случаях это второе событие выполнения пакета запросов."]}),(0,r.jsx)(t.xv,{p:!0,children:"Также стоит учитывать, чтоб сбор абсолютно всех запросов особо смысла не имеет и их нужно отфильтровать от “шума”. Для этого можно установить фильтр по полю времени выполнения события (поле “duration”). Значения там хранятся в микросекундах. Обычно я собираю запросы, которые выполняются более 5 секунд (то есть более 5000000 микросекунд)."}),(0,r.jsxs)(t.xv,{p:!0,children:["Чтобы создать сеанс сбора таких запросов воспользуется следующим скриптом. ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Diagnostics/Extended-Events/%D0%A2%D1%8F%D0%B6%D0%B5%D0%BB%D1%8B%D0%B5%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D0%BF%D0%BE%20CPU.sql",children:"Оригинальный скрипт находится здесь."})})})]}),(0,r.jsx)(a.Z,{code:"\n-- Анализ тяжелых запросов по CPU\n\nCREATE EVENT SESSION [HeavyQueryByCPU] ON SERVER\n-- Класс событий RPC:Completed указывает, что удаленный вызов процедуры завершен.\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/rpc-completed-event-class?view=sql-server-2017\nADD EVENT sqlserver.rpc_completed(\n    ACTION(\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.nt_username,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.username)\n    WHERE ([duration]>(5000000))),\n-- Класс событий SQL:BatchCompleted указывает на завершение выполнения пакета языка Transact-SQL.\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/sql-batchcompleted-event-class?view=sql-server-2017\nADD EVENT sqlserver.sql_batch_completed(\n    ACTION (\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.nt_username,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.username)\n    WHERE ([duration]>(5000000)))\nADD TARGET package0.event_file(SET \n    -- Путь к файлу хранения логов. Если не указан, то используется путь к каталогу логов SQL Server\n    filename=N'HeavyQueryByCPU.xel',\n    -- Максимальный размер файла в мегабайтах\n    max_file_size=(1024),\n    -- Максимальное количество файлов, после чего начнется перезапись логов в более старых файлах.\n    max_rollover_files=(5))\nWITH (\n    MAX_MEMORY=4096 KB,\n    EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,\n    MAX_DISPATCH_LATENCY=15 SECONDS,\n    MAX_EVENT_SIZE=0 KB,\n    MEMORY_PARTITION_MODE=NONE,\n    TRACK_CAUSALITY=OFF,\n    STARTUP_STATE=OFF)\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"При использовании не забудьте указать путь, где будут хранится файлы с результатами логирования."}),(0,r.jsx)(t.xv,{p:!0,children:"Таким образом, мы соберем все запросы, которые выполняются более 5 секунд, а дальше уже сможем агрегировать их и получить свой TOP по нагрузке."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Тяжелые запросы по объему данных"}),(0,r.jsx)(t.xv,{p:!0,children:"На втором месте для поиска тяжелых запросов используется объем логических чтений. Именно логических. То есть тех, которые были выполнены из оперативной памяти. Это важно, т.к. SQL Server кэширует страницы, полученные с диска в буферный кэш, то есть в оперативную память. Именно поэтому SQL Server такой прожорливый в части использования RAM (особенно если его не ограничить в настройках инстанса), но зато позволяет значительно повысить производительность. Тут главное соблюдать баланс."}),(0,r.jsx)(t.xv,{p:!0,children:"Сбор тяжелых запросов по логическим чтениям позволит определить те запросы, которые чаще всего используют буферный кэш, тем самым “вымывая” из него данные для других запросов. Что это значит? Допустим, на сервере 32 ГБ оперативной памяти. Бухгалтер запустил отчет, запрос которого благодаря усилиями разработчика, считал 25 ГБ данных. Тем самым весь буфферный кэш SQL Server теперь используется этим отчетом, а остальные запросы будут вынуждены обращаться к диску и заново получать страницы, помещать их в кэш. Фактически, пользователи столкнуться с замедлением работы информационной системы. Описание, конечно, общее, но смысл должен быть понятен."}),(0,r.jsxs)(t.xv,{p:!0,children:["Собирать будем те же события, что и для CPU: ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/rpc-completed-event-class?view=sql-server-ver16",children:"RPC:Completed"})})})," и ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/sql-batchcompleted-event-class?view=sql-server-ver16",children:"SQL:BatchCompleted"})})}),". Для избавления от избыточного логирования событий в этом случае необходимо поставить фильтр на поле с размером прочитанных данных (то есть “logical reads”). На практике все зависит от конкретной системы и размера базы. Обычно использую значение фильтра от 10000 до 50000 прочитанных страниц (то есть от ~80 МБ до ~400 МБ, т.к. 1 страница = 8 КБ)."]}),(0,r.jsx)(t.xv,{p:!0,children:"Для создания сеанса сбора тяжелых запросов по считываемому объему данных из кэша используем скрипт.Оригинальный скрипт здесь."}),(0,r.jsx)(a.Z,{code:"\n-- Анализ тяжелых запросов по чтению данных\n\nCREATE EVENT SESSION [HeavyQueryByReads] ON SERVER \n-- Класс событий RPC:Completed указывает, что удаленный вызов процедуры завершен.\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/rpc-completed-event-class?view=sql-server-2017\nADD EVENT sqlserver.rpc_completed(\n    ACTION (\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.nt_username,\n        sqlserver.query_hash,\n        sqlserver.query_plan_hash,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.username)\n    WHERE ([logical_reads]>(50000))),\n-- Класс событий SQL:BatchCompleted указывает на завершение выполнения пакета языка Transact-SQL .\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/sql-batchcompleted-event-class?view=sql-server-2017\nADD EVENT sqlserver.sql_batch_completed(\n    ACTION (\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.nt_username,\n        sqlserver.query_hash,\n        sqlserver.query_plan_hash,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.username)\n    WHERE ([logical_reads]>(50000)))\nADD TARGET package0.event_file(SET \n    -- Путь к файлу хранения логов. Если не указан, то используется путь к каталогу логов SQL Server\n    filename=N'HeavyQueryByReads.xel',\n    -- Максимальный размер файла в мегабайтах\n    max_file_size=(1024),\n    -- Максимальное количество файлов, после чего начнется перезапись логов в более старых файлах.\n    max_rollover_files=(5))\nWITH (\n    MAX_MEMORY=4096 KB,\n    EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,\n    MAX_DISPATCH_LATENCY=15 SECONDS,\n    MAX_EVENT_SIZE=0 KB,\n    MEMORY_PARTITION_MODE=NONE,\n    TRACK_CAUSALITY=OFF,\n    STARTUP_STATE=OFF)\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"При необходимости измените настройки под себя."}),(0,r.jsx)(t.xv,{p:!0,children:"В итоге будем иметь статистику какие запросы у нас “прожорливые” по чтению."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Анализ блокировок и взаимоблокировок"}),(0,r.jsx)(t.xv,{p:!0,children:"В платформе 1С реализован собственный менеджер блокировок. Всем известные управляемые блокировки должны были повысить производительность, что в принципе и сделали. Но, конечно же, отказа от использования блокировок на уровне СУБД не произошло, т.к. поддержание целостности данных никто не отменял. Поэтому мониторинг блокировок и взаимоблокировок на уровне СУБД является также актуальным."}),(0,r.jsx)(t.xv,{p:!0,children:"Для получения информации о возникших таймаутах на блокировках, ожиданиях на блокировках и взаимоблокировках можно воспользоваться следующими способоми."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Регулярный сбор информации об ожиданиях, таймаутах и взаимоблокировках"}),(0,r.jsxs)(t.xv,{p:!0,children:["Для минимального влияния на работу базы данных и сервера СУБД рекомендую собирать информацию об ожиданиях на блокировках с помощью механизма ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/blocked-process-report-event-class?view=sql-server-ver15",children:"отчетов по заблокированным процессам"})})}),". Он включается в свойствах сервера и выполняет сбор статистики с заданной периодичностью (обычно 5 секунд достаточно). При этом сбора информации обо всех установленных блокировках не производится, что снижает нагрузку на сервер. Мы получим только необходимую информацию о том, какой процесс кого ждал, какие запросы выполнялись и так далее."]}),(0,r.jsx)(t.xv,{p:!0,children:"Дополняем сессию сбора событиями отчета по взаимоблокировкам, чтобы в этот же отчет получить информацию о взаимоблокировках, их XML-граф и связаную информацию."}),(0,r.jsxs)(t.xv,{p:!0,children:["Информацию о событиях читайте в официальной документации: ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/blocked-process-report-event-class?view=sql-server-ver16",children:"Blocked Process Report"})})})," и ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/dynamics365/business-central/dev-itpro/administration/monitor-database-deadlocks",children:"Deadlock XML Report"})})}),"."]}),(0,r.jsx)(t.xv,{p:!0,children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Diagnostics/Extended-Events/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA%20%D0%B8%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA%20%D1%81%20%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E%20%D0%BE%D1%82%D1%87%D0%B5%D1%82%D0%BE%D0%B2.sql",children:"Оригинал скрипта здесь."})})})}),(0,r.jsx)(a.Z,{code:"\n-- Анализ блокировок и взаимоблокировок с помощью отчетов\n\n-- Предварительно нужно включить события отчетов заблокированных процессов\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/blocked-process-report-event-class?view=sql-server-ver15\nEXEC sp_configure 'show advanced options', 1 ;\nGO\nRECONFIGURE ;\nGO\nEXEC sp_configure 'blocked process threshold', '5';\nRECONFIGURE\nGO\n\n-- Далее создаем сессию сбор данных событий заблокированных процессов и взаимоблокировок\n\nCREATE EVENT SESSION [BlocksAndDeadlocksAnalyse] ON SERVER\nADD EVENT sqlserver.blocked_process_report(\n    ACTION(sqlserver.client_app_name,\n           sqlserver.client_hostname,\n           sqlserver.database_name)) ,\nADD EVENT sqlserver.xml_deadlock_report (\n    ACTION(sqlserver.client_app_name,\n           sqlserver.client_hostname,\n           sqlserver.database_name))\nADD TARGET package0.asynchronous_file_target\n(SET filename = N'LockAndDeadlockAnalyzeReports.xel',\n     metadatafile = N'LockAndDeadlockAnalyzeReports.xem',\n     max_file_size=(5000),\n     max_rollover_files=10)\nWITH (MAX_DISPATCH_LATENCY = 5SECONDS)\nGO\n\n/*\nРезультат сессии содержит подробную информацию о событиях блокировок и взаимоблокировок:\n- Какая сессия какие блокировала\n- Сколько происходило ожидание на блокироваке\n- Какие запросы участвовали с обоих сторон\n- И другая информация\n*/\n\nALTER EVENT SESSION [BlocksAndDeadlocksAnalyse] ON SERVER \n WITH (STARTUP_STATE=ON)\nGO\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"В целом, данных подход позволяет взять под контроль абсолютное большинство проблем с ожиданиями на блокировках, таймаутами или взаимоблокировками. При этом минимально влияя на работу сервера СУБД и базы данных в частности."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Детальный анализ работы блокировочного механизма"}),(0,r.jsx)(t.xv,{p:!0,children:"Второй способ с более детальным анализом можно использовать следующий, но он может сильно повлиять на работу сервера баз данных. Используйте в тех случаях, когда ранее описанный метод не позволяет проанализировать причины происходящих проблем."}),(0,r.jsxs)(t.xv,{p:!0,children:["Создаем сессию сбора информации обо всех возникших блокировках в системе, их отмене и таймаутах. При этом информацию записываем в файл, но с ограничением максимального размера в 1 ГБ. Максимальное количество файлов установим в 3. Выбранные события для сессии это: ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"lock:Acquired",children:"Lock:Acquired"})})})," (возникновение блокировки), ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/relational-databases/event-classes/lock-cancel-event-class?view=sql-server-ver16",children:"Lock:Cancel"})})})," (отмена блокировки), ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-timeout-event-class?view=sql-server-ver16",children:"Lock:Timeout"})})})," (таймаут на блокировке). Еще дополнительно можно собирать данные по событию ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-escalation-event-class?view=sql-server-ver16",children:"Lock:Escalation"})})})," (эскалация блокировки), но это по необходимости."]}),(0,r.jsx)(t.xv,{p:!0,children:"Сеанс собирает данные обо всех возникающих блокировках, отмененных блокировках и таймаутах. На нагруженных системах он может очень быстро увеличиваться в размерах, что потребует дискового пространства. Обычно сбор этих сведений выполняется в период пиковых нагрузок или в моменты времени, когда проблема с блокировками проявляется."}),(0,r.jsx)(t.xv,{p:!0,children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Diagnostics/Extended-Events/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA.sql",children:"Оригинальный скрипт здесь."})})})}),(0,r.jsx)(a.Z,{code:"\n-- Анализ блокировок\n\nCREATE EVENT SESSION [LockAnalyze] ON SERVER\n-- Класс событий Lock:Acquired указывает, что была получена блокировка для ресурса\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-acquired-event-class?view=sql-server-2017\nADD EVENT sqlserver.lock_acquired(\n    ACTION (\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.nt_username,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.username\n        )\n    ),\n-- Класс событий Lock:Cancel сигнализирует, что получение блокировки на ресурс было отменено\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-cancel-event-class?view=sql-server-2017\nADD EVENT sqlserver.lock_cancel(\n    ACTION (\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.nt_username,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.username\n        )\n    ),\n-- Класс событий Lock:Timeout указывает на то, что запрос на захват некоторого ресурса превысил время ожидания\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-timeout-event-class?view=sql-server-2017\nADD EVENT sqlserver.lock_timeout(\n    WHERE ([duration]>(1) AND [resource_0]<>(0)))\nADD TARGET package0.event_file(SET \n    -- Путь к файлу хранения логов. Если не указан, то используется путь к каталогу логов SQL Server\n    filename=N'LockAnalyze.xel',\n    -- Максимальный размер файла в мегабайтах\n    max_file_size=(1024),\n    -- Максимальное количество файлов, после чего начнется перезапись логов в более старых файлах.\n    max_rollover_files=(5))\nWITH (\n    MAX_MEMORY=4096 KB,\n    EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,\n    MAX_DISPATCH_LATENCY=15 SECONDS,\n    MAX_EVENT_SIZE=0 KB,\n    MEMORY_PARTITION_MODE=NONE,\n    TRACK_CAUSALITY=OFF,\n    STARTUP_STATE=OFF\n)\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Может понадобиться изменить настройки куда будет сохраняться файл с логами, а также ограничения на макс. размер файла и их количество."}),(0,r.jsx)(t.xv,{p:!0,children:"После этого, для анализа данных собранных логов лучше перенести их в отдельную базу данных. Последующий анализ заключается в поиске запроса, который блокировал выполнение текущей инструкции и привел к таймауту."}),(0,r.jsxs)(t.xv,{p:!0,children:["Также есть другой способ для оперативного анализа кто и что блокирует. Для этого создадим сессию с доп. событием ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/relational-databases/event-classes/lock-released-event-class?view=sql-server-ver16",children:"SQL:LockReleased"})})}),", которое показывает снятие блокировки с ресурса. Вот так будут выглядеть скрипты оперативного анализа блокировок."]}),(0,r.jsx)(a.Z,{code:"\nIF EXISTS(SELECT * FROM sys.server_event_sessions WHERE name='LockAnalyze_Operational')  \n    DROP EVENT SESSION LockAnalyze_Operational ON SERVER  \nGO  \n\nDECLARE @dbid int  \n-- Для фильтра по базе данных\nSELECT @dbid = db_id('<ИмяБазыДанных>')  \nIF @dbid IS NULL  \nBEGIN  \n    RETURN  \nEND  \n\n-- Создаем сессию для анализа блокировок\nDECLARE @sql nvarchar(1024)  \nSET @sql = '  \nCREATE EVENT SESSION LockAnalyze_Operational ON SERVER  \nADD EVENT sqlserver.lock_acquired   \n    (action   \n        ( sqlserver.sql_text, sqlserver.database_id, sqlserver.tsql_stack,  \n         sqlserver.plan_handle, sqlserver.session_id)  \n    WHERE ( database_id=' + cast(@dbid as nvarchar) + ' AND resource_0!=0)   \n    ),  \nADD EVENT sqlserver.lock_released   \n    (WHERE ( database_id=' + cast(@dbid as nvarchar) + ' AND resource_0!=0 ))  \nADD TARGET package0.pair_matching   \n    ( SET begin_event=''sqlserver.lock_acquired'',   \n            begin_matching_columns=''database_id, resource_0, resource_1, resource_2, transaction_id, mode'',   \n            end_event=''sqlserver.lock_released'',   \n            end_matching_columns=''database_id, resource_0, resource_1, resource_2, transaction_id, mode'',  \n    respond_to_memory_pressure=1)  \nWITH (max_dispatch_latency = 1 seconds)'  \nEXEC (@sql)  \n\nALTER EVENT SESSION LockAnalyze_Operational ON SERVER  \nSTATE = START  \n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Ждем выполнения проблемной нагрузки."}),(0,r.jsx)(a.Z,{code:"\n-- Сохраняем данные сессии во временную таблицу для последующего анализа\nSELECT   \n	objlocks.value('(action[@name=\"session_id\"]/value)[1]', 'int')  \n        AS session_id,  \n    objlocks.value('(data[@name=\"database_id\"]/value)[1]', 'int')   \n        AS database_id,  \n    objlocks.value('(data[@name=\"resource_type\"]/text)[1]', 'nvarchar(50)' )   \n        AS resource_type,  \n    objlocks.value('(data[@name=\"resource_0\"]/value)[1]', 'bigint')   \n        AS resource_0,  \n    objlocks.value('(data[@name=\"resource_1\"]/value)[1]', 'bigint')   \n        AS resource_1,  \n    objlocks.value('(data[@name=\"resource_2\"]/value)[1]', 'bigint')   \n        AS resource_2,  \n    objlocks.value('(data[@name=\"mode\"]/text)[1]', 'nvarchar(50)')   \n        AS mode,  \n    objlocks.value('(action[@name=\"sql_text\"]/value)[1]', 'varchar(MAX)')   \n        AS sql_text,  \n    CAST(objlocks.value('(action[@name=\"plan_handle\"]/value)[1]', 'varchar(MAX)') AS xml)   \n        AS plan_handle,      \n    CAST(objlocks.value('(action[@name=\"tsql_stack\"]/value)[1]', 'varchar(MAX)') AS xml)   \n        AS tsql_stack  \nINTO #unmatched_locks  \nFROM (  \n    SELECT CAST(xest.target_data as xml)   \n        lockinfo  \n    FROM sys.dm_xe_session_targets xest  \n    JOIN sys.dm_xe_sessions xes ON xes.address = xest.event_session_address  \n    WHERE xest.target_name = 'pair_matching' AND xes.name = 'LockAnalyze_Operational'  \n) heldlocks  \nCROSS APPLY lockinfo.nodes('//event[@name=\"lock_acquired\"]') AS T(objlocks)\n\n\n-- Получаем результаты анализа\nSELECT \n	ul.session_id [Сессия]\n	,ul.[database_id] AS [ID базы данных]\n	,ul.resource_type AS [Тип ресурса]\n	,ul.resource_0 AS [Ресурс0]\n	,ul.resource_1 AS [Ресурс1]\n	,ul.resource_2 AS [Ресурс2]\n	,ul.mode AS [Режим блокировки]\n	,ul.sql_text AS [Текст запроса]\n	,ul.plan_handle AS [Идентификатор плана запроса]\nFROM #unmatched_locks ul  \n    INNER JOIN sys.dm_tran_locks tl ON ul.database_id = tl.resource_database_id AND ul.resource_type = tl.resource_type  \n    WHERE resource_0 IS NOT NULL  \n    AND session_id IN   \n        (SELECT blocking_session_id FROM sys.dm_exec_requests WHERE blocking_session_id != 0)  \n    AND tl.request_status='wait'  \n    AND REPLACE(ul.mode, 'LCK_M_', '' ) = tl.request_mode  \n\n-- Удаляем временную таблицу и сессию расширенных событий\nDROP TABLE #unmatched_locks  \nDROP EVENT SESSION FindBlockers ON SERVER  \n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Так мы получим информацию о причинах таймаутов анализируя меньший объем логов, чем в первом примере."}),(0,r.jsxs)(t.xv,{p:!0,children:["Для сбора и последующего анализа причин взаимоблокировок можно использовать сессию, в которой собираются данные событий ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-deadlock-event-class?view=sql-server-ver16",children:"Lock:Deadlock"})})}),", ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-deadlock-chain-event-class?view=sql-server-ver16",children:"Lock:Deadlock Chain"})})})," и ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/dynamics365/business-central/dev-itpro/administration/monitor-database-deadlocks",children:"Deadlock XML Report"})})})," для построения графического отчета."]}),(0,r.jsx)(t.xv,{p:!0,children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Diagnostics/Extended-Events/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA.sql",children:"Оригинал скрипта здесь."})})})}),(0,r.jsx)(a.Z,{code:"\n-- Анализ взаимоблокировок\n\nCREATE EVENT SESSION [DeadlockAnalyze] ON SERVER \n-- Класс событий Lock:Deadlock предназначен для отслеживания возникновения взаимоблокировок и объектов, которые в них участвуют.\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-deadlock-event-class?view=sql-server-2017\nADD EVENT sqlserver.lock_deadlock(\n    ACTION(\n            sqlserver.client_app_name,\n            sqlserver.client_hostname,\n            sqlserver.client_pid,sqlserver.database_id,\n            sqlserver.nt_username,\n            sqlserver.server_principal_name,\n            sqlserver.session_id,\n            sqlserver.sql_text,\n            sqlserver.transaction_id,\n            sqlserver.username\n        )\n    ),\n-- Класс событий Lock:Deadlock Chain используется для регистрации условий возникновения взаимоблокировок.\n-- https://docs.microsoft.com/ru-ru/sql/relational-databases/event-classes/lock-deadlock-chain-event-class?view=sql-server-2017\nADD EVENT sqlserver.lock_deadlock_chain(\n    ACTION(\n            sqlserver.client_app_name,\n            sqlserver.client_hostname,\n            sqlserver.client_pid,\n            sqlserver.database_id,\n            sqlserver.nt_username,\n            sqlserver.server_principal_name,\n            sqlserver.session_id,\n            sqlserver.sql_text,\n            sqlserver.transaction_id,\n            sqlserver.username\n        )\n    ),\n-- Создает отчет о событии взаимоблокировки в формате XML\nADD EVENT sqlserver.xml_deadlock_report(\n    ACTION(\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.nt_username,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.username\n        )\n    )\nADD TARGET package0.event_file(SET\n        -- Путь к файлу хранения логов. Если не указан, то используется путь к каталогу логов SQL Server\n        filename=N'DeadlockAnalyze.xel',\n        -- Максимальный размер файла в мегабайтах\n        max_file_size=(10),\n        -- Максимальное количество файлов, после чего начнется перезапись логов в более старых файлах.\n        max_rollover_files=(5)\n    )\nWITH (\n        MAX_MEMORY=4096 KB,\n        EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,\n        MAX_DISPATCH_LATENCY=15 SECONDS,\n        MAX_EVENT_SIZE=0 KB,\n        MEMORY_PARTITION_MODE=NONE,\n        TRACK_CAUSALITY=OFF,\n        STARTUP_STATE=OFF\n    )\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Как обработать отчет по взаимоблокировкам"}),(0,r.jsx)(t.xv,{p:!0,children:"В обоих вариантах сбора информации о блакировках используется сбор XML-отчета о взаимоблокировке. Обработать его можно одинаково в обоих случаях."}),(0,r.jsx)(t.xv,{p:!0,children:"Обычно взаимоблокировки достаточно редкое явление, но мониторить их нужно в любом случае. Чтобы получить файл графа взаимоблокировки (*.xdl) из XML расширенного события необходимо скопировать вот этот значение в отдельный файл с расширением “xdl”."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/4. Граф взаимоблокировок.png",alt:"Граф взаимоблокировок",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"После этого файл графа можно открывать в SQL Server Managment Studio."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/5. Удобное чтение графа взаимоблокировки.png",alt:"Удобное чтение графа взаимоблокировки",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"Остальные события помогут найти конкретные запросы и причины их появления."}),(0,r.jsx)(t.xv,{p:!0,children:"Желаю Вам отсутствия взаимоблокировок!"}),(0,r.jsx)(t.xv,{p:!0,children:"Теперь Вы знаете как собрать информацию о запросах, приводящих к появлению таймаутов на блокировках и взаимоблокировкам."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Ошибки, ошибки, ошибки"}),(0,r.jsxs)(t.xv,{p:!0,children:["Было бы не плохо также отслеживать любые ошибки, происходящие на уровне СУБД. Для этого воспользуемся скриптом для сбора всех ошибок с помощью события ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://learn.microsoft.com/en-us/sql/relational-databases/errors-events/database-engine-events-and-errors?view=sql-server-ver16",children:"“SQL:ErrorReported”"})})}),"."]}),(0,r.jsx)(t.xv,{p:!0,children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Diagnostics/Extended-Events/%D0%90%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%20%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA.sql",children:"Оригинальный скрипт здесь."})})})}),(0,r.jsx)(a.Z,{code:"\n-- Анализ ошибок\n\nCREATE EVENT SESSION [Errors] ON SERVER \nADD EVENT sqlserver.error_reported(\n    ACTION (\n        sqlserver.client_app_name,\n        sqlserver.client_hostname,\n        sqlserver.client_pid,\n        sqlserver.database_id,\n        sqlserver.is_system,\n        sqlserver.nt_username,\n        sqlserver.server_principal_name,\n        sqlserver.session_id,\n        sqlserver.sql_text,\n        sqlserver.transaction_id,\n        sqlserver.transaction_sequence,\n        sqlserver.username)\n    WHERE ([severity]>(10)))\nADD TARGET package0.event_file(SET \n    -- Путь к файлу хранения логов. Если не указан, то используется путь к каталогу логов SQL Server\n    filename=N'Errors.xel',\n    -- Максимальный размер файла в мегабайтах\n    max_file_size=(10),\n    -- Максимальное количество файлов, после чего начнется перезапись логов в более старых файлах.\n    max_rollover_files=(5))\nWITH (\n    MAX_MEMORY=4096 KB,\n    EVENT_RETENTION_MODE=ALLOW_SINGLE_EVENT_LOSS,\n    MAX_DISPATCH_LATENCY=15 SECONDS,\n    MAX_EVENT_SIZE=0 KB,\n    MEMORY_PARTITION_MODE=NONE,\n    TRACK_CAUSALITY=OFF,\n    STARTUP_STATE=OFF)\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Может пригодиться для диагностики не только проблем SQL Server, но и ошибок при выполнении запросов платформой 1С."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Какой у нас план?"}),(0,r.jsx)(t.xv,{p:!0,children:"Иногда для диагностики проблем необходимо получить план запроса. Собирать планы всех запросов может быть не лучшим решением, т.к. значительно увеличит размер собираемых логов и в особых случаях может повлиять на производительность сервера."}),(0,r.jsx)(t.xv,{p:!0,children:"Поэтому лучше использовать такие пути получения плана запроса:"}),(0,r.jsxs)(t.aV,{children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Perfomance/%D0%90%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D0%B8%20%D0%BF%D0%BB%D0%B0%D0%BD%D1%8B%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F.sql",children:"этот скрипт"})})}),"этот скрипт и посмотрите ее план."]}),(0,r.jsxs)("li",{children:["Найти план выполнения по тексту запроса, если он еще содержится в кэше. ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Perfomance/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%BF%D0%BB%D0%B0%D0%BD%D0%B0%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0%20%D0%BF%D0%BE%20%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%83%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0.sql",children:"Вот пример скрипта."})})})]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Diagnostics/Extended-Events/%D0%A1%D0%B1%D0%BE%D1%80%20%D0%BF%D0%BB%D0%B0%D0%BD%D0%BE%D0%B2%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2.sql",children:"Собирать все планы выполнения"})})})," и повесить сервер с помощью Extended Events. Серьезно! Это только для ознакомления и применяется в редких случаях, особенно на продакшене."]}),(0,r.jsxs)("li",{children:["Есть и другие способы получить план. ",(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://www.sqlshack.com/how-to-obtain-sql-execution-plans-using-different-methods/",children:"Вот дополнительная информация по этому поводу."})})})]})]}),(0,r.jsxs)(t.xv,{p:!0,children:["Теперь, когда у Вас есть план запроса, Вы можете составить свой план работ! ",":)","."]}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Анализируй это"}),(0,r.jsx)(t.xv,{p:!0,children:"Собрать данные недостаточно, их еще нужно проанализировать! И тут платформа 1С приготовила нам некоторые сюрпризы. Разберем пример сбора и анализа данных собранных тяжелых запросов по CPU, а также анализ событий по таймаутам на блокировках. Все примеры будут очень похожи."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Перенос в отдельную базу данных"}),(0,r.jsx)(t.xv,{p:!0,children:"И так, сессия Extended Events работает уже несколько рабочих дней и пора перейти к анализу собранных ей данных. Для начала остановим сессию."}),(0,r.jsx)(t.xv,{p:!0,children:"Сделать это можно либо через интерфейс."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/6. Остановка сессии сбора.png",alt:"Остановка сессии сбора",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"Либо через TSQL."}),(0,r.jsx)(a.Z,{code:"\nALTER EVENT SESSION <ИмяСессии> ON SERVER  \nSTATE = STOP;  -- START для запуска\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Ничего сложного."}),(0,r.jsx)(t.xv,{p:!0,children:"Далее копируем файлы XEL с собранными данными на сервер логов или локальный компьютер, т.к. выполнять анализ данных на рабочем сервере дело рисковое, ведь он может “съесть” значительную часть ресурсов."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/7. Файлы расширенных событий.png",alt:"Файлы расширенных событий",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"Для удобной работы с логами лучше всего переносить их в базу данных. Конечно, есть возможность работы с ними без сохранения в базу, но это может значительно усложнить процесс обработки и анализа. Например, так мы не сможем повторно работать с данными эффективно, а для данных в базе мы могли бы создать индексы. Кроме того, для платформы 1С собранные данные нужно подвергать постобработке, к которой мы еще вернемся ниже. И так, как же перенести данные расширенных событий в базу."}),(0,r.jsx)(t.xv,{p:!0,children:"Исходим из того, что база данных для обработки логов уже создана. Нам лишь нужно эти логи туда загрузить. Для этого запустим SQL Server Managment Studio и перейдем в “Файл ➡️ Открыть ➡️ Объединить файлы расширенных событий….”."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/8. Объединение файлов расширенных событий для чтения.png",alt:"Объединение файлов расширенных событий для чтения",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"После добавляем в список все файлы, которые хотим обработать. Это намного удобнее, чем загружать каждый отдельный файл логов в базу. Ожидаем некоторое время, пока SSMS не обработает все события. После этого запускаем мастер выгрузки событий в таблицу базы данных."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/9. Экспорт расширенный событий в таблицу базы.png",alt:"Экспорт расширенный событий в таблицу базы",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"Вводим данные аутентификации, после чего необходимо выбрать базу данных, её схему (по умолчанию “dbo”) и имя таблицы для загрузки данных."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/10. Выбор целевой таблицы.png",alt:"Выбор целевой таблицы",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"Ожидаем завершение операции экспорта."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/11. Просмотр событий.png",alt:"Просмотр событий",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"На этом все, SSMS создал таблицу и загрузил туда данные расширенных событий."}),(0,r.jsx)(t.xv,{p:!0,children:"Для ознакомительных целей упомянем и способ работы с собранными логами без сохранения в базу данных, но при работе с большим массивом логов он неэффективен."}),(0,r.jsx)(t.xv,{p:!0,children:"Чтение файлов XEL через T-SQL выполняется с помощью sys.fn_xe_file_target_read_file. Каждое событие хранится в виде XML и вся задача сводится к разбору этих данных для представления в виде таблицы с отдельными колонками."}),(0,r.jsx)(a.Z,{code:"\nselect\n	n.value('(action[@name=\"database_name\"]/value)[1]', 'nvarchar(128)') as database_name,\n    n.value('(@name)[1]', 'varchar(50)') as event_name,\n    n.value('(@package)[1]', 'varchar(50)') AS package_name,\n    n.value('(@timestamp)[1]', 'datetime2') AS [utc_timestamp],\n    n.value('(data[@name=\"duration\"]/value)[1]', 'int') as duration,\n    n.value('(data[@name=\"cpu_time\"]/value)[1]', 'int') as cpu,\n    n.value('(data[@name=\"physical_reads\"]/value)[1]', 'int') as physical_reads,\n    n.value('(data[@name=\"logical_reads\"]/value)[1]', 'int') as logical_reads,\n    n.value('(data[@name=\"writes\"]/value)[1]', 'int') as writes,\n    n.value('(data[@name=\"row_count\"]/value)[1]', 'int') as row_count,\n    n.value('(data[@name=\"statement\"]/value)[1]', 'nvarchar(max)') as statement\nfrom (\n	select cast(event_data as XML) as event_data\n	from sys.fn_xe_file_target_read_file('Q:\\SQLTraces\\254-sp-sql6\\QueryStatistics\\QueryAnalysis*.xel', null, null, null)) ed\n	cross apply ed.event_data.nodes('event') as q(n)\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Если файлов XEL несколько, то есть возможность указать шаблон имени файла через “*”, как это сделано в примере выше."}),(0,r.jsx)(t.xv,{p:!0,children:"Этот способ не всегда удобен, т.к. не позволяет делать постобработку, группировку данных, использовать индексы для быстрого поиска и так далее."}),(0,r.jsx)(t.xv,{p:!0,children:"И так, мы подготовили логи для дальнейшей обработки, но как оказалось это еще не все. Для быстрой и эффективной работы нам необходимо добавить ключевое поле в таблицу, изменить некоторые колонки и добавить кластерный индекс. Например, вот так:"}),(0,r.jsx)(a.Z,{code:'\n-- Добавляем уникальное поле ID для каждой записи\nALTER TABLE [dbo].[QueryAnalysis] ADD ID INT IDENTITY(1,1);\n\n-- Изменяем тип колонки "database_name" с "nvarchar(max)" на "nvarchar(150)",\n-- чтобы его можно было использовать в индексах\nALTER TABLE [dbo].[QueryAnalysis] ALTER COLUMN [database_name] nvarchar(150) NOT NULL;\n\n-- Добавляем кластерный индекс по периоду, имени базы и ключу записи\nCREATE UNIQUE CLUSTERED INDEX CIX_Timestamp_DatabaseName_ID ON [dbo].[QueryAnalysis] \n(\n	[timestamp (UTC)], \n	[database_name], \n	[ID]\n);\n\n-- Добавляем индекс для быстрого поиска по "ID" + "timestamp (UTC)".\n-- Для оптимизации включены покрывающие поля, которые содержат тексты запросов, \n-- но это приводит к увеличению размера базы с логами.\nCREATE UNIQUE NONCLUSTERED INDEX [UI_ID_Timestamp] ON [dbo].[QueryAnalysis]\n(\n	[ID] ASC,\n	[timestamp (UTC)] ASC\n)\nINCLUDE ( 	\n	[batch_text],\n	[sql_text],\n	[database_name],\n	[statement]\n);\n\n-- Если есть возможность, то можно включить сжатие PAGE на уровне таблиц и индексов для базы с логами.\n-- Так можно значительно сэкономить место.\n                ',className:"my-5",language:"sql"}),(0,r.jsxs)(t.xv,{p:!0,children:["Эти шаги совсем не обязательные и могут изменяться в зависимости от состава собираемых полей в сессиях. Имеет смысл выполнять эти манипуляции только если данных для анализа много и планируется делать различные запросы для обработки этих записей. Нужен ли индекс, если в логах 10 записей? ",":)"]}),(0,r.jsx)(t.xv,{p:!0,children:"Отлично, теперь у нас есть таблица с загруженными логами и индекс для эффективной обработки данных."}),(0,r.jsx)(t.xv,{p:!0,children:"Эти действия могут отличаться, если состав собираемых полей с помощью Extended Events другой, но общий принцип должен быть понятен. Финальный вариант таблицы с логами выглядит так."}),(0,r.jsx)(t.Ee,{className:"my-4",src:"/public/imp_assets/SQLServer/2019-05/monitoring-with-extended-events-and-other/12. Результат выгрузки событий.png",alt:"Результат выгрузки событий",size:l.h2.MEDIUM}),(0,r.jsx)(t.xv,{p:!0,children:"Осталось решить проблему постобработки данных."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Постобработка. Или грабли от 1С"}),(0,r.jsxs)(t.xv,{p:!0,children:["Для SQL-запросов платформы есть одна большая особенность (другие мелкие нюансы можно не рассматривать): имена временных таблиц в запросах могут иметь случайные имена вида “","#tt<","Тут случайны номер, который присвоит платформа 1С",">","”. Аналогично обстоят дела и с именами параметров: @P1, @P2 … @PN."]}),(0,r.jsx)(t.xv,{p:!0,children:"Поэтому было бы не плохо привести их имена к общему виду. Например, к “#ttN” для временных таблиц и @PN для имен параметров."}),(0,r.jsx)(t.xv,{p:!0,children:"Есть множество способов сделать постобработку данных. От написания различных программ на C#, Pyton и так далее, до использования самой 1С. Мы же сейчас пойдем другим путем и используем инструмент, который изначально есть на любом Win-сервере. Это PowerShell!"}),(0,r.jsx)(a.Z,{code:'\n# Строка подключения к базе\n# Примеры:\n#   - аутентификация средствами NTLM: "Server=<Имя сервера>;Database=<Имя базы>;Integrated Security=TRUE;"\n#   - аутентификация средствами SQL Server: "Data Source=<Имя сервера>;user=<Имя пользователя>;password=<Пароль>;Initial Catalog=<Имя базы>"\n$connectionString = "<Строка подключения>";\n# Таблица с логами Extended Events\n$tableWithLogName = "<Имя таблицы с логами>";\n# Размер порции для обработки записей\n$portion = 100;\n# Таймаут подключения для команд\n$sqlCmdTimeoutSeconds = 180;\n\ntry\n{\n    $sqlConnection = new-object system.data.SqlClient.SQLConnection($connectionString);\n    $sqlConnection.Open();\n    $sqlConnectionForUpdate = new-object system.data.SqlClient.SQLConnection($connectionString);\n    $sqlConnectionForUpdate.Open();\n\n    # Проверяем наличие колонок в логах\n    $batch_text_exist = $false;\n    $sql_text_exist = $false;\n    $statement_exist = $false;\n    $database_name_exist = $false;\n    $sqlCmd = New-Object System.Data.SqlClient.SqlCommand\n    $sqlCmd.Connection = $sqlConnection\n    $sqlCmd.CommandTimeout = $sqlCmdTimeoutSeconds;\n    $sqlCmd.CommandText = "\n        SELECT \n	        cls.column_for_check AS [Name]\n	        ,CASE WHEN cl_info.column_id IS NOT NULL THEN 1 ELSE 0 END AS [exist]\n        FROM (\n		        SELECT \'batch_text\' column_for_check\n		        UNION ALL\n		        SELECT \'sql_text\' column_for_check\n		        UNION ALL\n		        SELECT \'statement\' column_for_check\n		        UNION ALL\n		        SELECT \'database_name\' column_for_check\n	        ) cls \n	        LEFT JOIN sys.columns cl_info\n	        ON cls.column_for_check = cl_info.[name]\n		        AND cl_info.[Object_ID] = Object_ID(N\'dbo." + $tableWithLogName + "\')";\n    $reader = $sqlCmd.ExecuteReader()\n    if($reader.HasRows -eq $true)\n    {\n        while ($reader.Read()) \n        {\n            if($reader["Name"] -eq "batch_text")\n            {\n                if($reader["exist"] -eq 1)\n                {\n                    $batch_text_exist = $true;\n                }\n            } elseif($reader["Name"] -eq "sql_text")\n            {\n                if($reader["exist"] -eq 1)\n                {\n                    $sql_text_exist = $true;\n                }\n            } elseif($reader["Name"] -eq "statement")\n            {\n                if($reader["exist"] -eq 1)\n                {\n                    $statement_exist = $true;\n                }\n            } elseif($reader["Name"] -eq "database_name")\n            {\n                if($reader["exist"] -eq 1)\n                {\n                    $database_name_exist = $true;\n                }\n            }\n        }\n    }\n    $reader.Close()  \n\n    if($batch_text_exist -eq $false -and\n        $sql_text_exist -eq $false -and\n        $statement_exist -eq $false)\n    {\n        $sqlConnection.Close();\n        $sqlConnectionForUpdate.Close();\n        Write-Host "Таблица ""$tableWithLogName"" не содержит данных для обработки!";\n        return;\n    }\n\n    $lastRowID = 0;\n    $finish = $false;\n\n    $fieldForJob = ($(if ($batch_text_exist) {"[batch_text],"} Else {""}) +  "\n	              " + $(if ($sql_text_exist) {"[sql_text],"} Else {""}) +  "    \n	              " + $(if ($statement_exist) {"[statement],"} Else {""})).Trim();\n    $fieldForJob = $fieldForJob.Substring(0, $fieldForJob.Length - 1);\n\n    $fieldsForUpdateLogRecord = ($(if ($batch_text_exist) {"     [batch_text] = @new_batch_text,"} Else {""}) +  "\n	                " + $(if ($statement_exist) {"     [statement] = @new_statement,"} Else {""}) +  "    \n	                " + $(if ($sql_text_exist) {"     [sql_text] = @new_sql_text,"} Else {""})).Trim();\n    $fieldsForUpdateLogRecord = $fieldsForUpdateLogRecord.Substring(0, $fieldsForUpdateLogRecord.Length - 1);\n\n    Do\n    {    \n        $sqlCmd = New-Object System.Data.SqlClient.SqlCommand\n        $sqlCmd.Connection = $sqlConnection\n        $sqlCmd.CommandTimeout = $sqlCmdTimeoutSeconds;\n        $sqlCmd.CommandText = "\n            SELECT TOP (" + $portion + ")\n	              -- Ключевые поля\n	              [ID]\n                  " + $(if ($database_name_exist) {",[database_name]"} Else {""}) +  "	          \n                  ,[timestamp (UTC)] AS [timestamp]\n                  -- Поля для обработки\n                  ," + $fieldForJob +  "       \n              FROM [dbo].[" + $tableWithLogName + "]\n              WHERE [ID] > @lastRowID\n              ORDER BY\n	              -- Сортировка по ключевым полям\n	              [ID]\n	              ,[timestamp (UTC)]";\n\n        $paramLastRowId = $sqlCmd.Parameters.Add("@lastRowID", $lastRowID);\n        $reader = $sqlCmd.ExecuteReader()\n    \n        if($reader.HasRows -eq $true)\n        {\n            while ($reader.Read()) \n            {\n           \n                $rowID = $reader["ID"];\n                $DatabaseName =  $(if ($database_name_exist) { $reader["database_name"] } Else { "" });\n                $timestamp = $reader["timestamp"];                       \n\n                if($batch_text_exist -eq $true)\n                {\n                    $batch_text = $reader["batch_text"];\n                    $batch_text = $batch_text -replace "#tt[\\d]+", "ttN";\n                    $batch_text = $batch_text -replace "@P[\\d]+", "@PN";\n                }\n\n                if($sql_text_exist -eq $true)\n                {\n                    $sql_text = $reader["sql_text"];\n                    $sql_text = $sql_text -replace "#tt[\\d]+", "ttN";\n                    $sql_text = $sql_text -replace "@P[\\d]+", "@PN";\n                }\n\n                if($statement_exist -eq $true)\n                {\n                    $statement = $reader["statement"];\n                    $statement = $statement -replace "#tt[\\d]+", "ttN";\n                    $statement = $statement -replace "@P[\\d]+", "@PN";\n                }\n\n                # Обновляем данные в записи\n                $sqlCmd_updateLogRecord = New-Object System.Data.SqlClient.SqlCommand\n                $sqlCmd_updateLogRecord.Connection = $sqlConnectionForUpdate\n                $sqlCmd_updateLogRecord.CommandTimeout = $sqlCmdTimeoutSeconds;\n                $sqlCmd_updateLogRecord.CommandText = "\n                    UPDATE [dbo].[" + $tableWithLogName + "] SET\n                    " + $fieldsForUpdateLogRecord +  "       \n                    WHERE [timestamp (UTC)] = @timestamp\n                    " + $(if ($database_name_exist) {"AND [database_name] = @databaseName"} Else {""}) +  "	                \n	                    AND [ID] = @RowID";\n                $newParam = $sqlCmd_updateLogRecord.Parameters.Add("RowID", $rowID);\n                if($database_name_exist)\n                {\n                    $newParam = $sqlCmd_updateLogRecord.Parameters.Add("databaseName", $DatabaseName);\n                }\n                $newParam = $sqlCmd_updateLogRecord.Parameters.Add("timestamp", $timestamp);\n                if($batch_text_exist)\n                {\n                    $newParam = $sqlCmd_updateLogRecord.Parameters.Add("new_batch_text", $batch_text);\n                }\n                if($statement_exist)\n                {\n                    $newParam = $sqlCmd_updateLogRecord.Parameters.Add("new_statement", $statement);\n                }\n                if($sql_text_exist)\n                {\n                    $newParam = $sqlCmd_updateLogRecord.Parameters.Add("new_sql_text", $sql_text);\n                }\n                $resultExec = $sqlCmd_updateLogRecord.ExecuteNonQuery();\n\n                $lastRowID = $rowID;          \n            }\n        } Else \n        {\n            $finish = $true;\n        } \n    \n        $reader.Close();\n        Write-Host "Последний обработанный идентификатор строки: " $rowID;\n\n    } while($finish -ne $true)\n}\ncatch \n{\n    Write-Error $_.Exception.Message;\n}\nfinally \n{\n    $sqlConnection.Close();\n    $sqlConnectionForUpdate.Close()\n}\n                ',className:"my-5",language:"powershell"}),(0,r.jsx)(t.xv,{p:!0,children:"Можно этот скрипт значительно ускорить за счет операций BulkInsert, кэширования в памяти и других способов, но есть ли смысл?"}),(0,r.jsx)(t.xv,{p:!0,children:"Используете другой подход? Было бы интересно узнать, пишите в комментариях."}),(0,r.jsx)(t.xv,{p:!0,children:"Теперь мы готовы агрегировать данные для поиска проблемных запросов."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Смотрим результаты"}),(0,r.jsx)(t.xv,{p:!0,children:"Ничего сверхъестественного здесь нет. Просто группируем данные по тексту запроса и сортируем либо по CPU, либо по логическим чтениям."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Анализ запросов по CPU и чтениям"}),(0,r.jsx)(t.xv,{p:!0,children:"Предположим, что мы загрузили данные сессии “” в одноименную таблицу. Теперь нам лишь нужно получить самые тяжелые запросы по CPU. Выполним такой запрос."}),(0,r.jsx)(a.Z,{code:"\nSELECT TOP (10) \n	  DB_NAME([database_id]) AS [database_name]\n	  ,[sql_text]\n      ,SUM([cpu_time]) [cpu_time]\n      ,SUM([duration]) [duration]\n      ,SUM([physical_reads]) [physical_reads]\n      ,SUM([logical_reads]) [logical_reads]\n      ,SUM([writes]) [writes]\n      ,SUM([row_count]) [row_count]\n  FROM [dbo].[HeavyQueryByCPU]\n  GROUP BY DB_NAME([database_id])\n	  ,[sql_text]\n  ORDER BY [cpu_time] DESC\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"В итоге, имеем 10 самых тяжелых запросов по использованию ресурсов CPU."}),(0,r.jsx)(t.xv,{p:!0,children:"Примерно такой же запрос был бы, если бы мы обрабатывали результаты сбора тяжелых запросов по чтениям."}),(0,r.jsx)(t.xv,{p:!0,children:"Собранные логи по блокировкам также можно изучить запросом"}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Анализ блокировок"}),(0,r.jsx)(t.xv,{p:!0,children:"Собранную информацию о таймаутах и установленных блокировках можно анализировать по разному. Можно найти для каждого таймаута блокирующую для него транзакцию и конкретный запрос. Чтобы не усложнять пример, рассмотрим простейший случай."}),(0,r.jsx)(t.xv,{p:!0,children:"Допустим, мы загрузили результаты сбора данных о таймаутах на блокировках в таблицу “LockAnalyze”, выполнили постобработку запросов. Далее вот таким простым запросом получаем список таймаутов и блокирующих сессий для него."}),(0,r.jsx)(a.Z,{code:"\nSELECT\n		timeouts.[timestamp]\n		,timeouts.[mode]\n		,timeouts.[transaction_id]\n		,timeouts.[database_id]\n		,timeouts.[resource_0]\n		,timeouts.[resource_1]\n		,timeouts.[resource_2]\n		-- Информация что было заблокировано\n		,locks.sql_text\n		,locks.[timestamp] AS [lock_timestamp]\n		,locks.[transaction_id] AS [lock_transaction_id]\n	FROM\n	(SELECT \n		  [timestamp]\n		  ,[mode]      \n		  ,[transaction_id]\n		  ,[database_id]  \n		  -- Заблокированные ресурсы    \n		  ,[resource_0]\n		  ,[resource_1]\n		  ,[resource_2]	  \n	  FROM [dbo].[LockAnalyze]\n	  WHERE [name] = 'lock_timeout') timeouts\n		LEFT JOIN [dbo].[LockAnalyze] AS [locks]\n		ON timeouts.[database_id] = locks.[database_id]\n			AND timeouts.[resource_0] = locks.[resource_0]\n			AND timeouts.[resource_1] = locks.[resource_1]\n			AND timeouts.[resource_2] = locks.[resource_2]\n			AND timeouts.[timestamp] > locks.[timestamp]\n			AND locks.[name] = 'lock_acquired'\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"То есть мы попытались найти для каждого таймаута соответствующую установленную блокировку, которая стала причиной проблемы. Сопоставление сделали по ресурсам (поля resource_0, resource_1, resource_2), базе данных и учитывая время таймаута."}),(0,r.jsx)(t.xv,{p:!0,children:"Конечно, такой анализ не даст точных результатов, а при большом объеме логов может показать множества лишней информации. В этом случае нужно будет усложнять запрос. Также может понадобиться добавить в сессию сбор событий Lock:Released."}),(0,r.jsx)(t.xv,{p:!0,children:"Основное, что требуется здесь понять, так это общий подход к поиску причин таймаутов на блокировках. Наиболее эффективным способом определения причин появления проблем с блокировками является расследование “на горячую”, которое было описано в примерах выше."}),(0,r.jsx)(t.xv,{p:!0,children:"И напоследок посмотрим ошибки SQL Server."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Анализ ошибок"}),(0,r.jsx)(t.xv,{p:!0,children:"Проанализируем самые частые ошибки на сервере СУБД и источники их возникновения."}),(0,r.jsx)(a.Z,{code:"\nSELECT TOP 10  \n	  DB_NAME([database_id]) AS [database_name]\n	  ,[client_hostname]\n      ,[client_app_name]\n      ,[message]\n      ,[username]      \n      ,[sql_text]\n	  ,COUNT(*) AS [error_count]\n  FROM [dbo].[Errors]\n  GROUP BY \n	  DB_NAME([database_id])    \n	  ,[client_hostname]\n      ,[client_app_name]\n      ,[message]\n      ,[username]      \n      ,[sql_text]\n  ORDER BY [error_count] DESC\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Конечно, как устранить ошибки мы сразу не узнаем, но повод для расследования ситуации появится."}),(0,r.jsx)(t.xv,{p:!0,children:"Запросы можно адаптировать под свои настройки расширенных событий."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"А как же технологический журнал?"}),(0,r.jsx)(t.xv,{p:!0,children:"Конечно, использовать технологический журнал можно для анализа тяжелых запросов и блокировок, даже планы запроса можно собрать. Но вот незадача! Влияние ТЖ на производительность системы может быть на столько высоко, что фактически остановит основную работу. Именно поэтому встроенные средства SQL Server намного лучше для диагностики проблем на уровне СУБД."}),(0,r.jsx)(t.xv,{p:!0,children:"Но, к сожалению, без технологического журнала все равно не обойтись. Вместе с простым мониторингом SQL Server он поможет решать такие задачи."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Поиск мест в модулях конфигурации"}),(0,r.jsx)(t.xv,{p:!0,children:"Допустим, мониторинг нашел, что подобный запрос находится в TOP 10 по нагрузке на CPU."}),(0,r.jsx)(a.Z,{code:"\nINSERT INTO #tt1 WITH(TABLOCK)\n    (_Q_000_F_000, _Q_000_F_001, _Q_000_F_002, _Q_000_F_003)\nSELECT\n    T1.Q_001_F_000_,\n    T1.Q_001_F_001_,\n    0x01,\n    @P1\nFROM (\n    SELECT\n            1.0 AS Q_001_F_000_,\n            @P2 AS Q_001_F_001_\n    UNION ALL\n        SELECT\n            2.0,\n            @P3\n    UNION ALL\n        SELECT\n            3.0,\n            @P4) T1\n                ",className:"my-5",language:"sql"}),(0,r.jsx)(t.xv,{p:!0,children:"Как найти где именно он выполняется в конфигурации 1С? С помощью настройки ТЖ."}),(0,r.jsx)(a.Z,{code:'\n<?xml version="1.0" encoding="UTF-8"?>\n<config xmlns="http://v8.1c.ru/v8/tech-log">\n    <dump create="false"/>\n    <log location="<Путь к каталогу для сохранения логов>" history="48">\n        <event>\n            <eq property="name" value="dbmssql"/>\n            <like property="Sql" value="%INSERT INTO%"/>\n            <like property="Sql" value="%SELECT%"/>\n            <like property="Sql" value="%0x01%"/>\n            <like property="Sql" value="%FROM (%"/>\n            <like property="Sql" value="%SELECT%"/>\n            <like property="Sql" value="%1.0%"/>\n            <like property="Sql" value="%UNION ALL%"/>\n            <like property="Sql" value="%SELECT%"/>\n            <like property="Sql" value="%2.0%"/>\n            <like property="Sql" value="%UNION ALL%"/>\n            <like property="Sql" value="%SELECT%"/>\n            <like property="Sql" value="%3.0%"/>\n        </event>\n        <property name="all"/>\n    </log>\n</config>\n                ',className:"my-5",language:"xml"}),(0,r.jsx)(t.xv,{p:!0,children:"В итоге, в одном из файлов логов мы получим модуль и строчку кода, откуда платформа генерирует этот запрос."}),(0,r.jsx)(a.Z,{code:"\n22:24.869011-1,DBMSSQL,6,process=rphost,p:processName=1C-Plus-MSOffice,OSThread=4760,t:clientID=12,t:applicationName=1CV8C,t:computerName=SRV-1C-MAIN,t:connectID=5,SessionID=2,Usr=DefUser,AppID=1CV8C,Trans=0,dbpid=59,Sql=\"INSERT INTO #tt1 WITH(TABLOCK) (_Q_000_F_000, _Q_000_F_001, _Q_000_F_002, _Q_000_F_003) SELECT\nT1.Q_001_F_000_,\nT1.Q_001_F_001_,\n0x01,\n?\nFROM (SELECT\n1.0 AS Q_001_F_000_,\n? AS Q_001_F_001_\nUNION ALL SELECT\n2.0,\n?\nUNION ALL SELECT\n3.0,\n?) T1\np_0: 40181231000000\np_1: 'Тест 1'\np_2: 'Тест 2'\np_3: 'Тест 3'\n\",Rows=0,RowsAffected=3,Context='Форма.Вызов : Отчет.ВыгрузкаРезультатаКомпоновки.Форма.ФормаОтчета.Модуль.ВыгрузитьВAccessНаСервере\nОтчет.ВыгрузкаРезультатаКомпоновки.Форма.ФормаОтчета.Форма : 43 : РаботаСAccessКлиентСервер.ПолучитьОграниченияВыгрузкиБазы(,2,)\n	ОбщийМодуль.РаботаСAccessСервер.Модуль : 55 : Возврат ВыгрузитьИсточникВБазуДанных(\n		ОбщийМодуль.РаботаСAccessСервер.Модуль : 123 : Стр = ПолучитьСледующуюЗапись(ИсточникДанных, НомерЗаписи);\n			ОбщийМодуль.РаботаСAccessСервер.Модуль : 302 : СледующаяЗапись = ИсточникДанных.Следующий();'\n                ",className:"my-5",language:"text"}),(0,r.jsx)(t.xv,{p:!0,children:"Для настройки ТЖ в этом случае нужно учитывать, что некоторые части SQL-запросов платформы могут изменяться (имена временных таблиц, имена полей вложенного запроса и др.). Поэтому лучше всего стараться использовать те части, которые точно не изменятся (имя таблиц или имена полей в базе, конструкции языка запросов и др)."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Поиск ошибок, связанных с работой СУБД"}),(0,r.jsx)(t.xv,{p:!0,children:"Вообще, рекомендуется собирать информацию об исключительных ситуация на сервере 1С в постоянном режиме. Для этого настраивается технологический журнал с таким содержимым файла настроек."}),(0,r.jsx)(a.Z,{code:'\n<config xmlns="http://v8.1c.ru/v8/tech-log">\n    <log location="<Путь к каталогу для сохранения логов>" history="168">\n        <event>\n            <eq property="Name" value="EXCP"/>\n        </event>\n        <event>\n            <eq property="Name" value="EXCPCNTX"/>\n        </event>\n        <event>\n            <eq property="Name" value="ADMIN"/>\n        </event>\n                <event>\n            <eq property="Name" value="PROC"/>\n        </event>\n        <event>\n            <eq property="Name" value="ATTN"/>\n        </event>\n        <event>\n            <eq property="Name" value="QERR"/>\n        </event>\n        <event>\n            <eq property="Name" value="SCOM"/>\n        </event>\n        <event>\n            <eq property="Name" value="CONN"/>\n        </event>\n        <property name="all">\n        </property>\n    </log>\n</config>\n                ',className:"my-5",language:"xml"}),(0,r.jsx)(t.xv,{p:!0,children:"Подобная настройка технологического журнала не создает заметной нагрузки на сервере и позволяет фиксировать события сбоев в работе его компонентов. При этом фиксируются и те ошибки, которые возникают при обращении к СУБД (таймауты на блокировках и др.)."}),(0,r.jsx)(t.xv,{subtitle:!0,className:"mt-10 md:text",children:"Послесловие по ТЖ"}),(0,r.jsx)(t.xv,{p:!0,children:"Это только те задачи, которые можно решить с минимальной затратой ресурсов. В статье мы не будем подробно останавливаться на работе ТЖ, но с его помощью можно решить множество других вопросов, с которыми Extended Events не в силах помочь:"}),(0,r.jsxs)(t.aV,{children:[(0,r.jsx)("li",{children:"Анализ и поиск проблем с управляемыми блокировками."}),(0,r.jsx)("li",{children:"Поиск узких мест производительности в коде конфигураций."}),(0,r.jsx)("li",{children:"Проверка работы сервера, кластера."}),(0,r.jsx)("li",{children:"И многое другое."})]}),(0,r.jsx)(t.xv,{p:!0,children:"То есть без технологического журнала все равно никуда, но для диагностики проблем СУБД лучше использовать нативные инструменты."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Что еще можно / нужно собирать"}),(0,r.jsx)(t.xv,{p:!0,children:"Выше уже было сказано, что статья не является полным руководством, поэтому кратко рассмотрим что еще можно собирать для мониторинга. Кроме тех данных, что мы собирали с помощью расширенных событий, обязательно нужно мониторить:"}),(0,r.jsxs)(t.aV,{children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"/pages/DevOps/2022-06/windows-perfomance-counter-and-powershell.tsx",children:"С помощью счетчиков производительности ОС Windows: "})})}),(0,r.jsxs)(t.aV,{children:[(0,r.jsx)("li",{children:"Загрузку оборудования"}),(0,r.jsx)("li",{children:"Внутренние показатели SQL Server."})]})]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/tree/master/SQL-Server-Maintenance/Service-Database",children:"Статистику обслуживания базы данных:"})})}),(0,r.jsxs)(t.aV,{children:[(0,r.jsx)("li",{children:"Один и более раз в день сохранять информацию о состоянии индексов в базу данных с логами с помощью Job\\’а или другим способом. Можно использовать этот скрипт."}),(0,r.jsx)("li",{children:"Сохранять информацию о состоянии статистик в базу с логами также один или несколько раз в сутки. Например, этим скриптом."}),(0,r.jsx)("li",{children:"Фиксировать операции обслуживания индексов и статистик. Например, в этом скрипте обслуживания выделено место, где эту информацию можно записывать в базу (имя таблицы, имя обслуживаемого объекта, тип операции, дата запуска и дата завершения)."})]})]}),(0,r.jsxs)("li",{children:["Другую необходимую информацию:",(0,r.jsxs)(t.aV,{children:[(0,r.jsx)("li",{children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Perfomance/%D0%A0%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D0%BD%D1%83%D1%82%D0%B0%D1%8F%20%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0%20%D0%BF%D0%BE%20%D0%BE%D0%B6%D0%B8%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F%D0%BC.sql",children:"Статистику по ожиданиям."})})})}),(0,r.jsx)("li",{children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Databases-Info/%D0%A0%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%20%D0%B2%D1%81%D0%B5%D1%85%20%D0%B1%D0%B0%D0%B7.sql",children:"Размер баз."})})})}),(0,r.jsx)("li",{children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://github.com/YPermitin/SQLServerTools/blob/master/SQL-Server-Databases-Info/%D0%A0%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D1%8B%20%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86.sql",children:"Размер таблиц."})})})}),(0,r.jsx)("li",{children:"И многое другое."})]})]})]}),(0,r.jsx)(t.xv,{p:!0,children:"Конечный вариант собираемых данных полностью зависит от целей мониторинга и должен быть адаптирован под Вашу ситуацию."}),(0,r.jsx)(t.xv,{p:!0,children:"Конечно, можно использовать стандартные средства Windows и SQL Server, но можно взять в помощь какую-либо систему мониторинга. Например, Zabbix, или вообще все логи выгружать в ElasticSearch. Тут все зависит от потребностей."}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Уровень Enterprise!"}),(0,r.jsx)(t.xv,{p:!0,children:"Вы дочитали до сюда с вопросом “А проще нельзя сделать”? Конечно, можно! Если бы выполнять мониторинг приходилось всегда через подобную ручную работу, то реагировать на проблемы производительности не всегда бы удавалось. Тем более на больших, высоконагруженных системах. Тут на помощь приходят инструменты мониторинга:"}),(0,r.jsxs)(t.aV,{children:[(0,r.jsx)("li",{children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://v8.1c.ru/tekhnologii/tekhnologii-krupnykh-vnedreniy/korporativnyy-instrumentalnyy-paket/",children:"Корпоративный инструментальный пакет (в его составе ЦУП)"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"https://softpoint.ru/solutions/perfexpert/",children:"Softpoint PerfExpert"})})})}),(0,r.jsx)("li",{children:(0,r.jsx)("b",{children:(0,r.jsx)("u",{children:(0,r.jsx)(t.e9,{newTab:!0,href:"http://www.gilev.ru/",children:"Сервисы Gilev.ru"})})})})]}),(0,r.jsx)(t.xv,{p:!0,children:"По крайней мере именно с этими инструментами приходилось работать за последние годы. На мой взгляд, самым продвинутым и эффективным остается PerfExpert, но это мое субъективное мнение."}),(0,r.jsxs)(t.xv,{p:!0,children:["Конечно, весь мониторинг можно организовать самостоятельно, но на это уйдет гораздо больше времени, а про сопровождение вообще лучше не говорить ",":)","."]}),(0,r.jsx)(t.xv,{title:!0,className:"mt-10 md:text",children:"Это еще не все"}),(0,r.jsx)(t.xv,{p:!0,children:"Мы рассмотрели преимущества использования Extended Events для диагностики работы СУБД и некоторые нюансы в контексте платформы 1С. Кратко пробежались по некоторым приемам работы с технологическим журналом и другим направлениям развития мониторинга."}),(0,r.jsx)(t.xv,{p:!0,children:"Главное, что нужно понять, так это существующий большой разрыв в инструментах диагностики платформы 1С и SQL Server, причем не в пользу первой. Конечно, без ТЖ никуда, но для мониторинга СУБД и оперативной диагностики запросов, блокировок, взаимоблокировок и ошибок лучше использовать собственные инструменты SQL Server."})]})},850:function(e,n,s){"use strict";s.d(n,{Z:function(){return o}});var r=s(5893),t=s(7294),a=s(4965),l=s(4275),i=s(7340);function c(){let e=(0,i._)(["\n  text-align: left;\n  overflow: hidden;\n  font-size: 14px;\n  border-radius: 6px;\n  overflow: auto;\n  max-height: 350px;\n\n  & .token-line {\n    line-height: 1.3em;\n    height: 1.3em;\n  }\n"]);return c=function(){return e},e}let d=s(964).ZP.pre(c());var o=e=>{let{code:n,className:i,language:c}=e;return(void 0!==s.g?s.g:window).Prism=a.p1,s(1354),s(9016),s(5266),s(2927),s(1315),s(7874),s(6862),(0,r.jsx)("div",{className:(0,l.GF)("bg-blue-500 md:p-5 p-2",i),children:(0,r.jsx)("div",{className:"shadow-lg",children:(0,r.jsx)(a.y$,{theme:a.np.vsDark,code:n,language:null!=c?c:c="tsx",children:e=>{let{className:n,style:s,tokens:a,getLineProps:l,getTokenProps:i}=e;return(0,r.jsx)(d,{className:n,style:s,children:a.map((e,n)=>(0,t.createElement)("div",{...l({line:e,key:n}),key:Math.random()},e.map((e,n)=>(0,t.createElement)("span",{...i({token:e,key:n}),key:Math.random()}))))})}})})})}},9305:function(e,n,s){"use strict";s.d(n,{Ee:function(){return i},Xg:function(){return a},aV:function(){return d},e9:function(){return o},o_:function(){return x},ty:function(){return c},xv:function(){return l}});var r=s(5152),t=s.n(r);let a=t()(()=>Promise.all([s.e(4838),s.e(4738),s.e(4817),s.e(1664),s.e(7167)]).then(s.bind(s,7167)),{loadableGenerated:{webpack:()=>[7167]}}),l=t()(()=>s.e(9179).then(s.bind(s,9179)),{loadableGenerated:{webpack:()=>[9179]}}),i=t()(()=>s.e(1974).then(s.bind(s,1974)),{loadableGenerated:{webpack:()=>[1974]}}),c=t()(()=>s.e(8547).then(s.bind(s,8547)),{loadableGenerated:{webpack:()=>[8547]}}),d=t()(()=>s.e(6806).then(s.bind(s,6806)),{loadableGenerated:{webpack:()=>[6806]}}),o=t()(()=>Promise.all([s.e(1664),s.e(1465)]).then(s.bind(s,1465)),{loadableGenerated:{webpack:()=>[1465]}});t()(()=>s.e(567).then(s.bind(s,567)),{loadableGenerated:{webpack:()=>[567]}}),t()(()=>Promise.all([s.e(2004),s.e(4139)]).then(s.bind(s,4139)),{loadableGenerated:{webpack:()=>[4139]}});let x=t()(()=>Promise.all([s.e(5507),s.e(7472),s.e(584),s.e(7870)]).then(s.bind(s,7870)),{loadableGenerated:{webpack:()=>[7870]}})}},function(e){e.O(0,[1102,2888,9774,179],function(){return e(e.s=6905)}),_N_E=e.O()}]);